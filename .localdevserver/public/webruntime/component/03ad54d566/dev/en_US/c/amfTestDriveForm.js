Webruntime.moduleRegistry.define('c/amfTestDriveForm', ['lwc', 'webruntime/configProvider', 'force/lds', 'lightning/configProvider', 'aura', 'aura-instrumentation'], function (lwc, configProvider, lds, configProvider$1, aura, auraInstrumentation) { 'use strict';

    function stylesheet(hostSelector, shadowSelector, nativeShadow) {
      return ".container" + shadowSelector + "{background-color: white;min-width: 800px;}\n.titleCon" + shadowSelector + "{font-size: 1.6rem;display: flex;align-items: center;justify-content: center;}\n.nextButton" + shadowSelector + " {margin-top: 5%;padding-right: 2rem;padding-left: 2rem;}\n.slds-section__title-action" + shadowSelector + "{height: 50px;}\n.sectionContent" + shadowSelector + "{width: 94%;margin-left: 3%;margin-bottom: 2%;}\n.btnContainer" + shadowSelector + "{margin-top: 3%;display: flex;align-items: center;justify-content: center;}\n";
    }
    var _implicitStylesheets = [stylesheet];

    function stylesheet$1(hostSelector, shadowSelector, nativeShadow) {
      return ".container" + shadowSelector + "{margin: 2%;}\n.choiceCon" + shadowSelector + "{width: 100%;padding: 30px;display: flex;align-items: center;justify-content: center;}\n.choiceCon" + shadowSelector + " img" + shadowSelector + "{height: 240px;}\n.choiceSet" + shadowSelector + "{width: 90%;margin-left:5%;}\n.choiceCol" + shadowSelector + "{width: 100%;}\n.choiceSet" + shadowSelector + " .slds-col" + shadowSelector + "{margin-top: 3%;height: 70px;width: 100%;display: flex;flex-direction: column;align-items: center;justify-content: center;}\n.imgCon" + shadowSelector + "{background-position: center;background-size:contain;background-repeat:no-repeat;display:inline-block;width:100%;height:70px;}\n.choiceCol" + shadowSelector + " h3" + shadowSelector + "{text-align: center;}\n.selectedChoice" + shadowSelector + "{-webkit-filter: brightness(1.2) grayscale(.1) opacity(.9);-moz-filter: brightness(1.2) grayscale(.1) opacity(.9);filter: brightness(1.2) grayscale(.1) opacity(.9);}\n.drinkcard-cc" + shadowSelector + "{cursor:pointer;-webkit-transition: all 100ms ease-in;-moz-transition: all 100ms ease-in;transition: all 100ms ease-in;-webkit-filter: brightness(1.8) grayscale(1) opacity(.7);-moz-filter: brightness(1.8) grayscale(1) opacity(.7);filter: brightness(1.8) grayscale(1) opacity(.7);}\n.drinkcard-cc:hover" + shadowSelector + "{-webkit-filter: brightness(1.2) grayscale(.1) opacity(.9);-moz-filter: brightness(1.2) grayscale(.1) opacity(.9);filter: brightness(1.2) grayscale(.1) opacity(.9);}\n.modelType" + shadowSelector + "{position: absolute;bottom: -8%;left: 0%;}\n.modelTypeNone" + shadowSelector + "{position: absolute;bottom: -2%;left: 0%;}\n";
    }
    var _implicitStylesheets$1 = [stylesheet$1];

    function tmpl($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        t: api_text,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "container": true
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "choiceCon": true
        },
        key: 3
      }, [api_element("img", {
        attrs: {
          "src": $cmp.currentChoice
        },
        key: 4
      }, [])]), api_element("div", {
        classMap: {
          "choiceSet": true,
          "slds-grid": true,
          "slds-gutters": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-col": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "choiceCol": true,
          "selectedChoice": true
        },
        attrs: {
          "data-id": "img1"
        },
        key: 7,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleChoice))
        }
      }, [api_element("div", {
        classMap: {
          "imgCon": true
        },
        style: $cmp.img1,
        key: 8
      }, []), api_element("h3", {
        key: 9
      }, [api_text("Model 1")])])]), api_element("div", {
        classMap: {
          "slds-col": true
        },
        key: 10
      }, [api_element("div", {
        classMap: {
          "choiceCol": true,
          "drinkcard-cc": true
        },
        attrs: {
          "data-id": "img2"
        },
        key: 11,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleChoice))
        }
      }, [api_element("div", {
        classMap: {
          "imgCon": true
        },
        style: $cmp.img2,
        key: 12
      }, []), api_element("h3", {
        key: 13
      }, [api_text("Model 2")])])]), api_element("div", {
        classMap: {
          "slds-col": true
        },
        key: 14
      }, [api_element("div", {
        classMap: {
          "choiceCol": true,
          "drinkcard-cc": true
        },
        attrs: {
          "data-id": "img3"
        },
        key: 15,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleChoice))
        }
      }, [api_element("div", {
        classMap: {
          "imgCon": true
        },
        style: $cmp.img3,
        key: 16
      }, []), api_element("h3", {
        key: 17
      }, [api_text("Model 3")])])])])])];
    }

    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];

    if (_implicitStylesheets$1) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets$1);
    }
    tmpl.stylesheetTokens = {
      hostAttribute: "lwc-amfVehicleChoice_amfVehicleChoice-host",
      shadowAttribute: "lwc-amfVehicleChoice_amfVehicleChoice"
    };

    var VEHICLE_IMAGES = `${configProvider.getBasePath()}/assets/cd55ed26a9/vwDemoPackFiles`;

    class amfVehicleChoice extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.img1Url = VEHICLE_IMAGES + '/images/vehicles/model1.jpg';
        this.img2Url = VEHICLE_IMAGES + '/images/vehicles/model2.jpg';
        this.img3Url = VEHICLE_IMAGES + '/images/vehicles/model3.jpg';
        this.img1 = `background-image:url(${this.img1Url})`;
        this.img2 = `background-image:url(${this.img2Url})`;
        this.img3 = `background-image:url(${this.img3Url})`;
        this.currentChoice = this.img1Url;
      }

      radioCheck(event) {
        //event.target.style.filter = 'none';
        let el = event.target.closest(".drinkcard-cc");
        el.style.filter = 'none';
        this.template.querySelector('.modelType').className = 'modelTypeNone';
        console.log(el);
        console.log(el.previousElementSibling);
      }

      handleChoice(event) {
        let el = event.target.closest(".choiceCol");

        if (el.classList.contains('drinkcard-cc')) {
          console.log(el);
          let selected = this.template.querySelector('.selectedChoice');
          console.log(selected);
          selected.classList.remove('selectedChoice');
          selected.classList.add('drinkcard-cc');
          el.classList.remove('drinkcard-cc');
          el.classList.add('selectedChoice'); //Set selected image

          el.getAttribute('data-id') === 'img1' ? this.currentChoice = this.img1Url : null;
          el.getAttribute('data-id') === 'img2' ? this.currentChoice = this.img2Url : null;
          el.getAttribute('data-id') === 'img3' ? this.currentChoice = this.img3Url : null;
        }
      }

    }

    lwc.registerDecorators(amfVehicleChoice, {
      track: {
        currentChoice: 1
      }
    });

    var _cAmfVehicleChoice = lwc.registerComponent(amfVehicleChoice, {
      tmpl: _tmpl
    });

    function stylesheet$2(hostSelector, shadowSelector, nativeShadow) {
      return ".mainContainer" + shadowSelector + "{display: flex;align-items: center;justify-content: center;width: 80%;margin-left: 10%;margin-top: 5%;max-width: 1000px;}\n.choiceCon" + shadowSelector + "{width: 300px;}\n";
    }
    var _implicitStylesheets$2 = [stylesheet$2];

    function tmpl$1($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        h: api_element,
        t: api_text
      } = $api;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true,
          "mainWrapper": true
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "mainContainer": true
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-visual-picker": true
        },
        key: 4
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "id": api_scoped_id("visual-picker-87"),
          "name": "options"
        },
        props: {
          "value": "visual-picker-86"
        },
        key: 5
      }, []), api_element("label", {
        attrs: {
          "for": `${api_scoped_id("visual-picker-87")}`
        },
        key: 6
      }, [api_element("span", {
        classMap: {
          "slds-visual-picker__figure": true,
          "slds-visual-picker__text": true,
          "slds-align_absolute-center": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-media__figure": true,
          "slds-media__figure_fixed-width": true,
          "slds-align_absolute-center": true,
          "slds-m-left_xx-small": true
        },
        key: 8
      }, [api_element("span", {
        classMap: {
          "slds-icon_container": true,
          "slds-icon-utility-knowledge_base": true
        },
        key: 9
      }, [api_element("svg", {
        classMap: {
          "slds-icon": true,
          "slds-icon-text-default": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 10
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#home")
        },
        key: 11
      }, [])])])]), api_element("div", {
        classMap: {
          "slds-media__body": true,
          "slds-border_left": true,
          "slds-p-around_small": true,
          "choiceCon": true
        },
        key: 12
      }, [api_element("h2", {
        classMap: {
          "slds-truncate": true,
          "slds-text-heading_small": true
        },
        attrs: {
          "title": "Share the knowledge"
        },
        key: 13
      }, [api_text("home pick-up")]), api_element("p", {
        classMap: {
          "slds-m-top_small": true
        },
        key: 14
      }, [api_text("A dealer near you will bring the car to your doorstep, so that you can enjoy the ride.")])])]), api_element("span", {
        classMap: {
          "slds-icon_container": true,
          "slds-visual-picker__text-check": true
        },
        key: 15
      }, [api_element("svg", {
        classMap: {
          "slds-icon": true,
          "slds-icon-text-check": true,
          "slds-icon_x-small": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 16
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#check")
        },
        key: 17
      }, [])])])])]), api_element("div", {
        classMap: {
          "slds-visual-picker": true
        },
        key: 18
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "id": api_scoped_id("visual-picker-86"),
          "name": "options"
        },
        props: {
          "value": "visual-picker-86"
        },
        key: 19
      }, []), api_element("label", {
        attrs: {
          "for": `${api_scoped_id("visual-picker-86")}`
        },
        key: 20
      }, [api_element("span", {
        classMap: {
          "slds-visual-picker__figure": true,
          "slds-visual-picker__text": true,
          "slds-align_absolute-center": true
        },
        key: 21
      }, [api_element("div", {
        classMap: {
          "slds-media__figure": true,
          "slds-media__figure_fixed-width": true,
          "slds-align_absolute-center": true,
          "slds-m-left_xx-small": true
        },
        key: 22
      }, [api_element("span", {
        classMap: {
          "slds-icon_container": true,
          "slds-icon-utility-knowledge_base": true
        },
        key: 23
      }, [api_element("svg", {
        classMap: {
          "slds-icon": true,
          "slds-icon-text-default": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 24
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#travel_and_places")
        },
        key: 25
      }, [])])])]), api_element("div", {
        classMap: {
          "slds-media__body": true,
          "slds-border_left": true,
          "slds-p-around_small": true,
          "choiceCon": true
        },
        key: 26
      }, [api_element("h2", {
        classMap: {
          "slds-truncate": true,
          "slds-text-heading_small": true
        },
        attrs: {
          "title": "Share the knowledge"
        },
        key: 27
      }, [api_text("Go to dealer")]), api_element("p", {
        classMap: {
          "slds-m-top_small": true
        },
        key: 28
      }, [api_text("You get to the dealer. You will be directly in car heaven.")])])]), api_element("span", {
        classMap: {
          "slds-icon_container": true,
          "slds-visual-picker__text-check": true
        },
        key: 29
      }, [api_element("svg", {
        classMap: {
          "slds-icon": true,
          "slds-icon-text-check": true,
          "slds-icon_x-small": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 30
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#check")
        },
        key: 31
      }, [])])])])])])])];
    }

    var _tmpl$1 = lwc.registerTemplate(tmpl$1);
    tmpl$1.stylesheets = [];

    if (_implicitStylesheets$2) {
      tmpl$1.stylesheets.push.apply(tmpl$1.stylesheets, _implicitStylesheets$2);
    }
    tmpl$1.stylesheetTokens = {
      hostAttribute: "lwc-amfTestDriveLocation_amfTestDriveLocation-host",
      shadowAttribute: "lwc-amfTestDriveLocation_amfTestDriveLocation"
    };

    class amfTestDriveLocation extends lwc.LightningElement {}

    var _cAmfTestDriveLocation = lwc.registerComponent(amfTestDriveLocation, {
      tmpl: _tmpl$1
    });

    function tmpl$2($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("form", {
        className: $cmp.formClass,
        props: {
          "noValidate": true
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleSubmit)),
          "registeroutputfield": _m1 || ($ctx._m1 = api_bind($cmp.handleRegister)),
          "registerinputfield": _m2 || ($ctx._m2 = api_bind($cmp.handleRegister)),
          "registerfielddependency": _m3 || ($ctx._m3 = api_bind($cmp.registerDependentField)),
          "updatedependentfields": _m4 || ($ctx._m4 = api_bind($cmp.updateDependentFields)),
          "error": _m5 || ($ctx._m5 = api_bind($cmp.handleError))
        }
      }, [api_slot("", {
        key: 3
      }, [], $slotset)])];
    }

    var _tmpl$2 = lwc.registerTemplate(tmpl$2);
    tmpl$2.slots = [""];
    tmpl$2.stylesheets = [];
    tmpl$2.stylesheetTokens = {
      hostAttribute: "lightning-recordEditForm_recordEditForm-host",
      shadowAttribute: "lightning-recordEditForm_recordEditForm"
    };

    var labelApiNameMismatch = 'API Name {0} is invalid, did you mean "{1}?"';

    var labelInvalidId = 'Error in fetching record: invalid record id.';

    /*
     * Constants to use UI API.
     *
     * The values must match those used in UI API responses.
     */
    const DensityValues = {
      COMFY: 'comfy',
      COMPACT: 'compact',
      AUTO: 'auto'
    };
    const LabelAlignValues = {
      STACKED: 'stacked',
      HORIZONTAL: 'horizontal'
    };
    /**
     * Field types.
     * source: TODO - add ui sdk java class
     */

    const FieldTypes = {
      ADDRESS: 'Address',
      BASE64: 'Base64',
      BOOLEAN: 'Boolean',
      COMPLEX_VALUE: 'ComplexValue',
      CURRENCY: 'Currency',
      DATE: 'Date',
      DATETIME: 'DateTime',
      DOUBLE: 'Double',
      RICH_TEXTAREA: 'RichTextArea',
      DECIMAL: 'Decimal',
      EMAIL: 'Email',
      ENCRYPTED_STRING: 'EncryptedString',
      INT: 'Int',
      LOCATION: 'Location',
      MULTI_PICKLIST: 'MultiPicklist',
      PLAIN_TEXTAREA: 'PlainTextArea',
      PERCENT: 'Percent',
      PHONE: 'Phone',
      PICKLIST: 'Picklist',
      REFERENCE: 'Reference',
      STRING: 'String',
      TEXT: 'Text',
      TEXTAREA: 'TextArea',
      TIME: 'Time',
      URL: 'Url',
      PERSON_NAME: 'PersonName',
      SWITCHABLE_PERSON_NAME: 'SwitchablePersonName'
    };
    /**
     * Localized field types.
     * source: com.force.util.soql.functions.SoqlFunctions.fieldSupportsToLabel(String, String)
     */

    const LocalizedFieldTypes = [FieldTypes.MULTI_PICKLIST, FieldTypes.PICKLIST, FieldTypes.CURRENCY, FieldTypes.DATE, FieldTypes.DATETIME];

    const Fields = FieldTypes;
    const UNSUPPORTED_REFERENCE_FIELDS = ['OwnerId', 'CreatedById', 'LastModifiedById'];
    const labelAlignValues = LabelAlignValues;
    const densityValues = DensityValues;

    const getCompoundValue = (field, record, fieldInfo, objectInfo) => {
      if (FieldTypes.LOCATION === fieldInfo.dataType) {
        const prefix = field.slice(0, field.indexOf('__c'));
        const longitude = record.fields[prefix + '__Longitude__s'].value;
        const latitude = record.fields[prefix + '__Latitude__s'].value;
        return {
          longitude,
          latitude
        };
      } // fields with no value, it must be derived from the constituant fields


      const compoundFields = getCompoundFields(field, record, objectInfo);
      const ret = {};
      compoundFields.forEach(childField => {
        if (record.fields[childField]) {
          ret[childField] = record.fields[childField].value;
        }
      });
      return ret;
    };
    /**
     * Given a record will determine if it is a PersonAccount or not
     * @param {Object} record the record to check
     *
     * @returns {boolean} true if the record is a personAccount
     */


    function isPersonAccount(record) {
      if (record.apiName !== 'Account' && record.apiName !== 'PersonAccount') {
        return false;
      }

      return record.fields.IsPersonAccount ? record.fields.IsPersonAccount.value : false;
    }
    /**
    /**
     *
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} record the record
     * @param {object} objectInfo a single object info defining the field
     * @return {array} a list of constituent fields
     */

    function getCompoundFields(field, record, objectInfo) {
      return Object.keys(objectInfo.fields).filter(key => {
        return key !== field && record.fields[key] && objectInfo.fields[key].compoundFieldName === field;
      });
    }

    const getReferenceInfo = (record, fieldInfo) => {
      const relationshipName = fieldInfo.relationshipName; // TODO: handle multiple referenceToInfos

      const relationshipNameFields = fieldInfo.referenceToInfos[0].nameFields;
      const relationship = record.fields[relationshipName];

      if (!relationship || !relationship.value) {
        return {
          referenceId: null,
          displayValue: null
        };
      } // TODO: Should references support localized fields and thus return a value to complement their displayValue?


      const referenceField = relationship.value.fields;
      const displayValue = relationship.displayValue || relationshipNameFields.reduce((acc, nameField) => {
        const thisField = referenceField[nameField];

        if (thisField) {
          return acc + ' ' + thisField.value;
        }

        return acc;
      }, '').trim();
      return {
        referenceId: referenceField.Id.value,
        displayValue
      };
    };
    /**
     * Get a UiField from a field on a record.
     * objectInfo and objectInfos are optional but at least one must be present
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} record the record
     * @param {object} objectInfo a single object info defining the field
     * @return {array} a UiField representing the field.
     */


    const getUiField = (field, record, objectInfo) => {
      const fieldInfo = objectInfo.fields[field];

      if (!fieldInfo) {
        throw new Error(`Field [${field}] was not found`);
      }

      const personAccount = isPersonAccount(record);
      const value = isCompoundField(field, objectInfo, personAccount) ? getCompoundValue(field, record, fieldInfo, objectInfo) : record.fields[field] && record.fields[field].value; // TODO - handle formatting
      // ui sdk formats these field types: currency, date, datetime, time (/ui-services-api/java/src/ui/services/api/soql/FormatFunctionHelper.java
      // ui sdk localizes based on com.force.util.soql.functions.SoqlFunctions.fieldSupportsToLabel(String, String)
      // thomas will expose this in objectInfo but until then i can pivot on that logic
      // - if [currency date datetime time] use value
      // - else if diplayValue is present use it
      // - else use value

      let result = {
        type: fieldInfo.dataType,
        extraTypeInfo: fieldInfo.extraTypeInfo,
        label: fieldInfo.label,
        inlineHelpText: fieldInfo.inlineHelpText,
        value
      };
      result = Object.assign(result, fieldInfo);

      if (fieldInfo.reference) {
        const referenceInfo = getReferenceInfo(record, fieldInfo);
        result.value = referenceInfo.referenceId;
        result.displayValue = referenceInfo.displayValue;
      } else {
        // provide the display value for localizable field types
        const includeDisplayValue = LocalizedFieldTypes.includes(fieldInfo.dataType);

        if (includeDisplayValue) {
          result.displayValue = record.fields[field].displayValue;
        }
      }

      return result;
    };
    /**
     * Determine if any field in a list of fields
     * is updateable
     * @param {array} fields list of constituent fields
     * @param {object} record the record
     * @param {object} objectInfo object info
     *
     * @returns {Boolean} true if any of the fields are updateable, otherwise false
     */

    function compoundFieldIsUpdateable(fields, record, objectInfo) {
      // if any constituent field is updateable, the field is
      for (let i = 0; i < fields.length; i++) {
        if (objectInfo.fields[fields[i]].updateable) {
          return true;
        }
      }

      return false;
    }
    /**
     *
     * Determines if a field actually has contituent fields,
     * because some fields might identify themselves as compound
     * but without constituent fields we can't treat them as compound
     *
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} objectInfo a single object info defining the field
     * @param {boolean} personAccount if this object is a PersonAccount (Name is compound)
     *                                  https://help.salesforce.com/articleView?id=account_person.htm&type=5
     * @returns {boolean} true if the field is a compound field, false if it is not
     */

    function isCompoundField(field, objectInfo, personAccount = false) {
      const fieldInfo = objectInfo.fields[field];

      if (!fieldInfo) {
        // a field that does not exist is not compound
        // this is safety to prevent gacks and probably should not generally happen
        return false;
      }

      if (fieldInfo.compound === false) {
        return false;
      }

      const keys = Object.keys(objectInfo.fields);

      for (let i = 0; i < keys.length; i++) {
        if (keys[i] !== field && objectInfo.fields[keys[i]].compoundFieldName === field) {
          // special case for when person accounts are enabled, but this is not a personAccount. In this case
          // the Name field of an account looks like a compound field but is not.
          if (objectInfo.apiName === 'Account' && objectInfo.fields[keys[i]].compoundFieldName === 'Name' && !personAccount) {
            return false;
          }

          return true;
        }
      }

      return false;
    }
    /**
     * Normalize the given error object.
     * @param  {Error | Object} err This could be a javascript Error or an error emitted from LDS (ErrorResponse).
     * @return {Object} An object with a string message and a string detail
     */

    function parseError(err) {
      let message = '',
          output = {},
          detail = '';

      if (err) {
        if (err.body && err.body.output) {
          // ErrorResponse with Record Output Error
          // https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_error_with_output.htm
          message = err.body.message;

          if (err.body.output.errors.length > 0) {
            detail = err.body.output.errors[0].message;
          } // output is part of the recordUi error response,
          // so we will include it.


          output = JSON.parse(JSON.stringify(err.body.output));
        } else if (Array.isArray(err.body) && err.body.length > 0) {
          // ErrorResponse with normal UIAPI error.
          message = err.body[0].message;
          detail = err.body[0].errorCode;
        } else if (err.body && err.body.message) {
          // ErrorResponse with body that has a message.
          message = err.body.message;
        } else if (err.body) {
          // ErrorResponse with unknown body.
          message = err.body;
        } else if (err.statusText) {
          // ErrorResponse with no body.
          message.err = err.statusText;
        } else if (err.message) {
          // Vanilla js error.
          message = err.message;
        } else {
          // Unknown error.
          message = err;
        }
      }

      return {
        message,
        detail,
        output
      };
    }
    function createErrorEvent(err) {
      const {
        message,
        detail
      } = parseError(err);
      const error = new Error(message);
      return new ErrorEvent('error', {
        error,
        message,
        detail
      });
    }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(Object(source)); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    function filterByPicklistsInForm(objectInfo, picklistValues, fields) {
      const picklistsInForm = getPicklistFields(objectInfo, fields);
      return filterPicklistValues(picklistValues, picklistsInForm);
    }
    function formHasPicklists(objectInfo, fields) {
      return getPicklistFields(objectInfo, fields).size > 0;
    }

    function getPicklistFields(objectInfo, fields) {
      const picklistFields = new Set();

      for (const fieldName in objectInfo.fields) {
        if (objectInfo.fields.hasOwnProperty(fieldName)) {
          const field = objectInfo.fields[fieldName];

          if (field.dataType === Fields.PICKLIST || field.dataType === Fields.MULTI_PICKLIST) {
            // need to check the parent for compound fields
            const fieldNameToCheck = field.compoundFieldName || fieldName;

            if (fields.includes(`${objectInfo.apiName}.${fieldNameToCheck}`)) {
              picklistFields.add(field.apiName);
            }
          }
        }
      }

      return picklistFields;
    }

    function filterPicklistValues(picklistsByRecordType, picklistsInForm) {
      return Object.keys(picklistsByRecordType).filter(key => picklistsInForm.has(key)).reduce((obj, key) => {
        return _objectSpread({}, obj, {
          [key]: picklistsByRecordType[key]
        });
      }, {});
    }

    /**
     * This file exists just to reduce code duplication
     * between the aura and raptor implementations
     * of record-edit-form
     */
    const OUTPUT_FIELD_TAGNAME = 'LIGHTNING-OUTPUT-FIELD';

    function normalizeRecord(newRecord) {
      const normalizedRecord = Object.assign({}, newRecord);
      normalizedRecord.fields = {};
      Object.keys(newRecord.fields).forEach(field => {
        if (newRecord.fields[field] && typeof newRecord.fields[field] === 'object') {
          normalizedRecord.fields[field] = newRecord.fields[field];
        } else {
          normalizedRecord.fields[field] = {
            value: newRecord.fields[field]
          };
        }
      });
      return normalizedRecord;
    }

    async function ldsUpdateRecord(newRecord, originalRecord, objectInfo) {
      newRecord.id = originalRecord.id;
      newRecord.apiName = null;
      const newRecordEdit = lds.generateRecordInputForUpdate(normalizeRecord(newRecord), objectInfo);
      const recordToSave = lds.createRecordInputFilteredByEditedFields(newRecordEdit, originalRecord);
      return lds.updateRecord(recordToSave);
    }
    async function ldsCreateRecord(newRecord, objectInfo) {
      const normalizedRecord = normalizeRecord(newRecord);
      const recordToSave = lds.generateRecordInputForCreate(normalizedRecord, objectInfo);
      return lds.createRecord(recordToSave);
    }
    /**
     *
     * Create or edit a record. If no original record is
     * specified create the record, otherwise update it
     * @param {recordInput} newRecord the dirty fields to change
     * @param {recordInput} originalRecord the original record
     * @param {objectInfo} objectInfo info about the object
     * @returns {Promise} Resovled when record is created or saved
     */

    async function createOrSaveRecord(newRecord, originalRecord, objectInfo) {
      if (originalRecord) {
        return ldsUpdateRecord(newRecord, originalRecord, objectInfo);
      }

      return ldsCreateRecord(newRecord, objectInfo);
    }
    /**
     * Returns a map of fieldNames : values
     * for an *array* of inputField components
     *
     * @param {lightningInputField[]} inputFields components
     * @returns {Object} map of fieldNames: values
     */

    function getFormValues(inputFields) {
      const values = {};
      inputFields.forEach(field => {
        if (field.readonly) {
          return;
        } // compound fields need to be flattened


        if (field.value && typeof field.value === 'object') {
          // geoloc compounds have weird field names
          if (field.value.longitude) {
            const prefix = field.fieldName.slice(0, field.fieldName.indexOf('__c'));
            values[prefix + '__Longitude__s'] = field.value.longitude;
            values[prefix + '__Latitude__s'] = field.value.latitude;
          } else {
            Object.assign(values, field.value);
          }
        } else {
          values[field.fieldName] = field.value;
        }
      });
      return values;
    }
    /**
     * Normalize the given error object.
     * @param  {Error | Object} err This could be a javascript Error or an error emitted from LDS (ErrorResponse).
     * @return {Object} An object with a string message and a string detail
     */

    function parseError$1(err) {
      let message = '',
          output = {},
          detail = '';

      if (err) {
        if (err.body && err.body.output) {
          // ErrorResponse with Record Output Error
          // https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_error_with_output.htm
          message = err.body.message;

          if (err.body.output.errors.length > 0) {
            detail = err.body.output.errors[0].message;
          } else if (err.body.detail) {
            detail = err.body.detail;
          } // output is part of the recordUi error response,
          // so we will include it.


          output = JSON.parse(JSON.stringify(err.body.output));
        } else if (Array.isArray(err.body) && err.body.length > 0) {
          // ErrorResponse with normal UIAPI error.
          message = err.body[0].message;
          detail = err.body[0].errorCode;
        } else if (err.body && err.body.message) {
          // ErrorResponse with body that has a message.
          message = err.body.message;
          detail = err.body.detail ? err.body.detail : '';
        } else if (err.body) {
          // ErrorResponse with unknown body.
          message = err.body;
        } else if (err.statusText) {
          // ErrorResponse with no body.
          message.err = err.statusText;
        } else if (err.message) {
          // Vanilla js error.
          message = err.message;
        } else {
          // Unknown error.
          message = err;
        }
      }

      return {
        message,
        detail,
        output
      };
    }
    function createErrorEvent$1(err) {
      const parsed = parseError$1(err);
      return new CustomEvent('error', {
        detail: parsed
      });
    }
    /**
     * Creates a list of fully qualified
     * fieldnames with no duplicates
     */

    class FieldSet$1 {
      /**
       *
       * @param {String} objectApiName The object name
       */
      constructor(objectApiName) {
        this._set = new Set();
        this._apiName = objectApiName;
      }

      set objectApiName(objectApiName) {
        this._apiName = objectApiName;
      }
      /**
       * Add a single field
       * @param {String} val unqualified field name
       */


      add(val) {
        this._set.add(val);
      }
      /**
       * Add a list of fieldnames
       * @param {Array} arr Array of unqualified field names
       */


      concat(arr) {
        arr.forEach(item => {
          this.add(item);
        });
      } // using a method here rather than a getter
      // because this seemed clearer

      /**
       * @returns {Array} a list of fully qualified field names
       */


      getList() {
        const apiName = this._apiName;
        return [...this._set].map(field => {
          return `${apiName}.${field}`;
        });
      }
      /**
       * @returns {Array} a list of unqualified field names
       */


      getUnqualifiedList() {
        return [...this._set];
      }

    }
    /**
     *
     * Calls `reportValidity` on every input field, returns true
     * if all fields are valid, false if any are not
     *
     * @param {Array} inputFields list of input fields to validate
     * @returns {Boolean} true if all fields are false, true otherwise
     */


    function validateForm(inputFields) {
      let isValid = true;
      inputFields.forEach(cmp => {
        // output fields are always valid, the second clause is defensive in case
        // somebody passes the wrong type of component in this array
        if (cmp.tagName === OUTPUT_FIELD_TAGNAME || !cmp.reportValidity) {
          return;
        }

        if (!cmp.reportValidity()) {
          isValid = false;
        }
      });
      return isValid;
    }
    /**
     * Convenience function because you can't use
     * Set() in aura directly, also this
     * puts the "qualification" of fields in one place
     *
     * @param {String} objectApiName An object api name (entity name) to qualify fields
     * @returns {FieldSet} Field set has one method: add() to add a fieldname and one attribute list,
     *                     which you can use to get the qualified list of api names (an array)
     */

    function getFieldSet$1(objectApiName) {
      return new FieldSet$1(objectApiName);
    }

    class LightningResizeObserver {
      constructor(resizeCallback) {
        this._resizeObserverAvailable = typeof ResizeObserver === 'function';

        const delayedCallback = callback => {
          if (this._running) {
            return;
          }

          this._running = true; // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(() => {
            callback();
            this._running = false;
          }, 60);
        };

        this._delayedResizeCallback = delayedCallback.bind(this, resizeCallback);

        if (this._resizeObserverAvailable) {
          this._resizeObserver = new ResizeObserver(this._delayedResizeCallback);
        }
      }

      observe(lightningElement) {
        // Using requestAnimationFrame as the element may not be physically in the DOM yet.
        this._requestAnimationId = requestAnimationFrame(() => {
          const domElement = lwc.unwrap(lightningElement);

          if (this._resizeObserverAvailable) {
            this._resizeObserver.observe(domElement);
          } else if (!this._hasWindowResizeHandler) {
            window.addEventListener('resize', this._delayedResizeCallback);
            this._hasWindowResizeHandler = true;
          }
        });
      }

      disconnect() {
        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }

        if (this._requestAnimationId) {
          cancelAnimationFrame(this._requestAnimationId);
        }

        window.removeEventListener('resize', this._delayedResizeCallback);
        this._hasWindowResizeHandler = false;
      }

    }

    /**
     * Width breakpoint for changing desnification setting
     */
    const APP_DENSIFICATION_BREAKPOINT = 650;
    const appDensityValues = {
      COMFY: 'VIEW_ONE',
      COMPACT_AUTO: 'VIEW_TWO'
    };

    function assert(condition, message) {
      {
        if (!condition) {
          throw new Error(message);
        }
      }
    }

    /**
    An emitter implementation based on the Node.js EventEmitter API:
    https://nodejs.org/dist/latest-v6.x/docs/api/events.html#events_class_eventemitter
    **/
    class EventEmitter {
      constructor() {
        this.registry = {};
      }
      /**
      Registers a listener on the emitter
      @method EventEmitter#on
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      on(name, listener) {
        this.registry[name] = this.registry[name] || [];
        this.registry[name].push(listener);
        return this;
      }
      /**
      Registers a listener on the emitter that only executes once
      @method EventEmitter#once
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      once(name, listener) {
        const doOnce = function () {
          listener.apply(null, arguments);
          this.removeListener(name, doOnce);
        }.bind(this);

        this.on(name, doOnce);
        return this;
      }
      /**
      Synchronously calls each listener registered with the specified event
      @method EventEmitter#emit
      @param {String} name - The name of the event
      @return {Boolean} - Returns `true` if the event had listeners, `false` otherwise
      **/


      emit(name, ...args) {
        const listeners = this.registry[name];
        let count = 0;

        if (listeners) {
          listeners.forEach(listener => {
            count += 1;
            listener.apply(null, args);
          });
        }

        return count > 0;
      }
      /**
      Removes the specified `listener` from the listener array for the event named `name`
      @method EventEmitter#removeListener
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      removeListener(name, listener) {
        const listeners = this.registry[name];

        if (listeners) {
          for (let i = 0, len = listeners.length; i < len; i += 1) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              return this;
            }
          }
        }

        return this;
      }

    }

    const urlRegexString = "((?:(?:https?|ftp):\\/\\/(?:[\\w\\-\\|=%~#\\/+*@\\.,;:\\?!']|&){0,2047}(?:[\\(\\)\\.\\w=\\/+#-]*)[^\\s()\\.<>,;\\[\\]`'\"])|(?:\\b(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW)(?!@(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW))(?:/[\\w\\-=?/.&;:%~,+@#*]{0,2048}(?:[\\w=/+#-]|\\([^\\s()]*\\)))?(?:$|(?=\\.$)|(?=\\.\\s)|(?=[^\\w\\.]))))";
    const emailRegexString = '([\\w-\\.\\+_]{1,64}@(?:[\\w-]){1,255}(?:\\.[\\w-]{1,255}){1,10})';
    const tagRegexString = '(<a[\\s]+[^>]+[^/]>[\\s\\S]*?</a>|<a[\\s]+[^>]+/>|' + '<i?frame[\\s]+[^>]+[^/]>[\\s\\S]*?</i?frame>|<i?frame[\\s]+[^>]+/>|' + '<area[\\s]+[^>]+[^/]>[\\s\\S]*?</area>|<area[\\s]+[^>]+/>|' + '<link[\\s]+[^>]+[^/]>[\\s\\S]*?</link>|<link[\\s]+[^>]+/>|' + '<img[\\s]+[^>]+[^/]>[\\s\\S]*?</img>|<img[\\s]+[^>]+>|' + '<form[\\s]+[^>]+[^/]>[\\s\\S]*?</form>|<form[\\s]+[^>]+/>|' + '<body[\\s]+[^>]+[^/]>[\\s\\S]*?</body>|<body[\\s]+[^>]+/>|' + '<head[\\s]+[^>]+[^/]>[\\s\\S]*?</head>|<head[\\s]+[^>]+/>|' + '<input[\\s]+[^>]+[^/]>[\\s\\S]*?</input>|<input[\\s]+[^>]+/>|' + '<button[\\s]+[^>]+[^/]>[\\s\\S]*?</button>|<button[\\s]+[^>]+/>|' + '<blockquote[\\s]+[^>]+[^/]>[\\s\\S]*?</blockquote>|<blockquote[\\s]+[^>]+/>|' + '<q[\\s]+[^>]+[^/]>[\\s\\S]*?</q>|<q[\\s]+[^>]+/>|' + '<del[\\s]+[^>]+[^/]>[\\s\\S]*?</del>|<del[\\s]+[^>]+/>|' + '<ins[\\s]+[^>]+[^/]>[\\s\\S]*?</ins>|<ins[\\s]+[^>]+/>)';
    const createHttpHref = function (url) {
      let href = url;

      if (url.toLowerCase().lastIndexOf('http', 0) !== 0 && url.toLowerCase().lastIndexOf('ftp', 0) !== 0) {
        href = `http://${href}`;
      }

      return href;
    };
    const createEmailHref = function (email) {
      return `mailto:${email}`;
    };

    /**
     * Create a deep copy of an object or array
     * @param {object|array} o - item to be copied
     * @returns {object|array} copy of the item
     */

    /**
     * Utility function to generate an unique guid.
     * used on state objects to provide a performance aid when iterating
     * through the items and marking them for render
     * @returns {String} an unique string ID
     */
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }

    function classListMutation(classList, config) {
      Object.keys(config).forEach(key => {
        if (typeof key === 'string' && key.length) {
          if (config[key]) {
            classList.add(key);
          } else {
            classList.remove(key);
          }
        }
      });
    }

    /**
    A string normalization utility for attributes.
    @param {String} value - The value to normalize.
    @param {Object} config - The optional configuration object.
    @param {String} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
    @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
    @return {String} - The normalized value.
    **/
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = '',
        validValues,
        toLowerCase = true
      } = config;
      let normalized = typeof value === 'string' && value.trim() || '';
      normalized = toLowerCase ? normalized.toLowerCase() : normalized;

      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }

      return normalized;
    }
    /**
    A boolean normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeBoolean(value) {
      return typeof value === 'string' || !!value;
    }
    function normalizeArray(value) {
      if (Array.isArray(value)) {
        return value;
      }

      return [];
    }
    /**
    A aria attribute normalization utility.
    @param {Any} value - A single aria value or an array of aria values
    @return {String} - A space separated list of aria values
    **/

    function normalizeAriaAttribute(value) {
      let arias = Array.isArray(value) ? value : [value];
      arias = arias.map(ariaValue => {
        if (typeof ariaValue === 'string') {
          return ariaValue.replace(/\s+/g, ' ').trim();
        }

        return '';
      }).filter(ariaValue => !!ariaValue);
      return arias.length > 0 ? arias.join(' ') : null;
    }

    const keyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    };
    const buffer = {};
    /**
     * Runs an action and passes the string of buffered keys typed within a short time period.
     * Use for type-ahead like functionality in menus, lists, comboboxes, and similar components.
     *
     * @param {CustomEvent} event A keyboard event
     * @param {Function} action function to run, it's passed the buffered text
     */

    function runActionOnBufferedTypedCharacters(event, action) {
      const letter = event.key;

      if (letter.length > 1) {
        // Not an individual character/letter, but rather a special code (like Shift, Backspace, etc.)
        return;
      } // If we were going to clear what keys were typed, don't yet.


      if (buffer._clearBufferId) {
        clearTimeout(buffer._clearBufferId);
      }

      buffer._keyBuffer = buffer._keyBuffer || [];

      buffer._keyBuffer.push(letter);

      const matchText = buffer._keyBuffer.join('').toLowerCase();

      action(matchText); // eslint-disable-next-line lwc/no-set-timeout

      buffer._clearBufferId = setTimeout(() => {
        buffer._keyBuffer = [];
      }, 700);
    }

    const isIE11 = isIE11Test(navigator);
    const isChrome = isChromeTest(navigator); // The following functions are for tests only

    function isIE11Test(navigator) {
      // https://stackoverflow.com/questions/17447373/how-can-i-target-only-internet-explorer-11-with-javascript
      return /Trident.*rv[ :]*11\./.test(navigator.userAgent);
    }
    function isChromeTest(navigator) {
      // https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
      return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }

    /**
     * Set an attribute on an element, if it's a normal element
     * it will use setAttribute, if it's an LWC component
     * it will use the public property
     *
     * @param {HTMLElement} element The element to act on
     * @param {String} attribute the attribute to set
     * @param {Any} value the value to set
     */
    function smartSetAttribute(element, attribute, value) {
      if (element.tagName.match(/^LIGHTNING/i)) {
        attribute = attribute.replace(/-\w/g, m => m[1].toUpperCase());
        element[attribute] = value ? value : null;
      } else if (value) {
        element.setAttribute(attribute, value);
      } else {
        element.removeAttribute(attribute);
      }
    }

    const CONTENT_SEPARATOR = '\n';
    /**
    <template>
        <span lwc:dom="manual" class="visually-hidden"></span>
        <input>
    </template>

    class Foo extends LightningElement {
        constructor() {
            super();
            this.ariaObserver = new ContentMutation(this);
        }

        @track ariaLabeledbyValue = '';

        @api
        get ariaLabeledby() {
            return this.ariaLabeledbyValue; // whatever they set, is what they get back.
        }
        set ariaLabeledby(refs) {
            this.ariaLabeledbyValue = refs;
            this.ariaObserver.link('input', 'aria-labeledby', refs, 'span.visually-hidden');
        }

        renderedCallback() {
            this.ariaObserver.sync();
        }
    }
    **/

    function getAttr(elm, attr) {
      if (elm.tagName.match(/lightning/i)) {
        return elm[attr];
      }

      return elm.getAttribute(attr);
    }

    function extractElements(root, selector) {
      if (typeof selector !== 'string' || selector === '') {
        return [];
      }

      return [].slice.call(root.querySelectorAll(selector));
    }

    function extractContent(elements) {
      return elements.map(element => element.textContent).filter(text => text.length).join(CONTENT_SEPARATOR);
    }

    function splitIds(ids) {
      return (ids + '').trim().split(/\s+/);
    }

    function hashIds(ids) {
      return (ids + '').trim().split(/\s+/).reduce((r, v) => {
        r[v] = 1;
        return r;
      }, {});
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and dupe
    // them, and add the new ones.


    function addAriaRefWhenNeeded(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const suffix = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          suffix.push(newIds[i]);
        }
      }

      if (suffix.length !== 0) {
        smartSetAttribute(elm, attrName, oldIds + (oldIds.length === 0 ? '' : ' ') + suffix.join(' '));
      }
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and remove
    // them when possible in preparation for some new values.


    function removeAriaRefWhenPossible(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const newValues = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          newValues.push(newIds[i]);
        }
      }

      smartSetAttribute(elm, attrName, newValues.join(' '));
    }

    class ContentMutation {
      constructor(component) {
        this.template = component.template;
        this.isNative = this.template.constructor.toString().match(/\[native code\]/);
        this.state = {};
        this.liveIds = {};
        this.guid = guid();
      }

      connectLiveIdRef(refs, callback) {
        const selector = (refs + '').trim().split(/\s+/).map(ref => `[id*="${ref}"]`).join(',');
        const liveId = {
          selector,
          callback
        };
        this.liveIds[refs] = liveId;
      }

      link(innerSelector, attrName, ids, placeholderContainerSelector) {
        let attrState = this.state[attrName];

        if (attrState) {
          // note: we don't support linking to a different innerSelector,
          // attrName, or placeholderContainerSelector
          if (!this.isNative) {
            const elm = this.template.querySelector(innerSelector);

            if (elm) {
              // removing the old ids if possible before setting the new ones
              removeAriaRefWhenPossible(elm, attrName, attrState.ids);
            }

            attrState.ids = ids;
          }
        } else {
          attrState = this.state[attrName] = {
            ids,
            innerSelector,
            placeholderContainerSelector
          };
        }

        if (this.isNative) {
          attrState.outerSelector = (ids + '').trim().split(/\s+/).map(ref => `#${ref}`).join(',');
          attrState.placeholder = document.createElement('span');
          attrState.placeholder.id = `auto-link-${attrName}-${this.guid}`;
        }

        if (this.template.host.parentNode) {
          this.privateUpdate(attrName);
        }
      }

      sync() {
        if (!this.template.host.parentNode) {
          throw new Error(`Invalid sync invocation. It can only be invoked during renderedCallback().`);
        }

        if (this.isNative && !this.mo) {
          this.privateConnect();
        }

        for (const attrName in this.state) {
          if (this.state.hasOwnProperty(attrName)) {
            this.privateUpdate(attrName);
          }
        } // live idRef feature is a no-op in native


        if (!this.isNative) {
          this.privateUpdateLiveIds();
        }
      }

      privateExtractIds(elements) {
        return elements.map(el => {
          return el.getAttribute('id');
        }).join(' ');
      }

      privateUpdateLiveIds() {
        const root = this.template.host.getRootNode(); // if not connected do nothing

        if (!root) {
          return;
        }

        for (const liveId in this.liveIds) {
          if (this.liveIds.hasOwnProperty(liveId)) {
            const thisId = this.liveIds[liveId];

            if (!thisId.elements) {
              // element refs are cached
              thisId.elements = Array.prototype.slice.call(root.querySelectorAll(thisId.selector));
            }

            const newIds = this.privateExtractIds(thisId.elements); // only fire calback if the value changed

            if (newIds !== thisId.ids) {
              thisId.callback(newIds);
              thisId.ids = newIds;
            }
          }
        }
      }

      privateUpdate(attrName) {
        const {
          innerSelector
        } = this.state[attrName];
        const elm = this.template.querySelector(innerSelector);

        if (!elm) {
          return; // nothing to update
        }

        let computedIds;

        if (this.isNative) {
          const {
            outerSelector,
            content,
            placeholder,
            placeholderContainerSelector
          } = this.state[attrName];
          const newContent = extractContent(extractElements(this.root, outerSelector));

          if (content !== newContent) {
            this.state[attrName].content = placeholder.textContent = newContent;
          }

          if (!placeholder.parentNode) {
            // inserting the placeholder once
            const container = this.template.querySelector(placeholderContainerSelector);

            if (container) {
              container.appendChild(placeholder);
            }
          }

          computedIds = placeholder.id;
        } else {
          computedIds = this.state[attrName].ids;
        }

        addAriaRefWhenNeeded(elm, attrName, computedIds);
      }

      privateConnect() {
        // caching root ref
        this.root = this.template.host.getRootNode(); // creating the observer once

        const mo = new MutationObserver(() => {
          if (!this.template.host.parentNode) {
            return; // do nothing when the template is not connected
          }

          this.sync();
        });
        mo.observe(this.root, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }

    }

    // hide panel on scroll

    const ALLOWED_DOMAINS = new Set(['www.youtube.com', 'player.vimeo.com', 'play.vidyard.com']);
    function hasOnlyAllowedVideoIframes(htmlString) {
      if (htmlString && htmlString.indexOf('<iframe') > -1) {
        const parsedHtml = new DOMParser().parseFromString(htmlString, 'text/html');
        const iframesList = Array.prototype.slice.call(parsedHtml.querySelectorAll('iframe'));
        return iframesList.length > 0 && !iframesList.some(iframe => !isUrlAllowed(iframe.src));
      }

      return false;
    }

    function isUrlAllowed(url) {
      const anchor = document.createElement('a');
      anchor.href = url;
      return anchor.protocol === 'https:' && ALLOWED_DOMAINS.has(anchor.hostname);
    }

    /**
     * @param {HTMLElement} element Element to act on
     * @param {Object} values values and attributes to set, if the value is
     *                        falsy it the attribute will be removed
     */

    function synchronizeAttrs(element, values) {
      if (!element) {
        return;
      }

      const attributes = Object.keys(values);
      attributes.forEach(attribute => {
        smartSetAttribute(element, attribute, values[attribute]);
      });
    }
    /**
     * Get the actual DOM id for an element
     * @param {HTMLElement|String} el The element to get the id for (string will just be returned)
     *
     * @returns {String} The DOM id or null
     */

    function getRealDOMId(el) {
      if (el && typeof el === 'string') {
        return el;
      } else if (el) {
        return el.getAttribute('id');
      }

      return null;
    }
    const URL_CHECK_REGEX = /^(\/+|\.+|ftp|http(s?):\/\/)/i;
    function isAbsoluteUrl(url) {
      return URL_CHECK_REGEX.test(url);
    }
    const DEFAULT_ZINDEX_BASELINE = 9000;
    /**
     * Returns the zIndex baseline from slds zIndex variable --lwc-zIndexModal.
     * @returns {Number} zIndex baseline
     */

    function getZIndexBaseline() {
      const value = (window.getComputedStyle(document.documentElement) || document.documentElement.style).getPropertyValue('--lwc-zIndexModal');
      const base = parseInt(value, 10);
      return isNaN(base) ? DEFAULT_ZINDEX_BASELINE : base;
    }

    function doNormalization(val, cmpInterface) {
      const normalized = normalizeString(val, {
        fallbackValue: densityValues.AUTO,
        validValues: [densityValues.AUTO, densityValues.COMPACT, densityValues.COMFY]
      });
      cmpInterface.setDensityPrivate(normalized);
      setLabelAlignment(cmpInterface);
    }
    function setLabelAlignment(cmpInterface) {
      const fieldLabelAlignment = cmpInterface.getLabelAlignmentPrivate();

      if (isDensityComfy(cmpInterface)) {
        if (fieldLabelAlignment !== labelAlignValues.STACKED) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.STACKED);
          wireLabelAlignment(cmpInterface);
        }
      } else if (isDensityCompact(cmpInterface)) {
        if (fieldLabelAlignment !== labelAlignValues.HORIZONTAL) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.HORIZONTAL);
          wireLabelAlignment(cmpInterface);
        }
      }
    } // Only density auto with wired density compact needs resize observer
    // If density is auto with wired comfy we can disconnect the observer or not connect it

    function resetResizeObserver(cmp, cmpInterface) {
      if (cmp._resizeObserver && !isWiredDensityAuto(cmpInterface)) {
        // If we have a resize observer and the density is not auto it means it was changed
        // to not auto, we should disconnect the resize observer.
        cmp._resizeObserver.disconnect();

        cmp._resizeObserver = undefined;
      } else if (isWiredDensityAuto(cmpInterface)) {
        // No resize observer and density is auto, we should setup the resize observer
        cmp._resizeObserver = setupResizeObserver(cmpInterface);
      }
    }

    function isWiredDensityAuto(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      const wiredDensity = configProvider$1.getOneConfig().densitySetting;
      return density === densityValues.AUTO && wiredDensity !== appDensityValues.COMFY;
    }

    function isDensityComfy(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      return density === densityValues.AUTO && configProvider$1.getOneConfig().densitySetting === appDensityValues.COMFY || density === densityValues.COMFY;
    }

    function isDensityCompact(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      return isWiredDensityAuto(cmpInterface) || density === densityValues.COMPACT;
    }

    function setupResizeObserver(cmpInterface) {
      const containerEle = cmpInterface.getContainerElement();
      const resizeObserver = new LightningResizeObserver(cmpInterface.getResizeObserverCallback(resizeObserverCallback));
      resizeObserver.observe(containerEle);
      return resizeObserver;
    }

    function resizeObserverCallback(cmpInterface) {
      const containerEle = cmpInterface.getContainerElement();

      if (containerEle) {
        const containerWidth = containerEle.getBoundingClientRect().width;
        const fieldLabelAlignment = cmpInterface.getLabelAlignmentPrivate();
        let alignmentChanged = false;

        if (containerWidth < APP_DENSIFICATION_BREAKPOINT && fieldLabelAlignment !== labelAlignValues.STACKED) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.STACKED);
          alignmentChanged = true;
        }

        if (containerWidth >= APP_DENSIFICATION_BREAKPOINT && fieldLabelAlignment !== labelAlignValues.HORIZONTAL) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.HORIZONTAL);
          alignmentChanged = true;
        }

        if (alignmentChanged) {
          wireLabelAlignment(cmpInterface);
        }
      }
    }

    function wireLabelAlignment(cmpInterface) {
      const recordUi = cmpInterface.getRecordUi();

      if (recordUi) {
        const fields = cmpInterface.getInputOutputFields();
        recordUi.labelAlignment = cmpInterface.getLabelAlignmentPrivate();

        for (let i = 0; i < fields.length; i += 1) {
          fields[i].wireRecordUi(recordUi);
        }
      }
    }

    // NOTE: lightning-record-utils is a public library. adding new utils here means we
    // will have to support it until the end of time. Consider adding the util to
    // lightning-utils-private instead if it's something we can live with as
    // internal-only.

    /**
     * This is a prettified copy-paste of the force:records#to18 method.
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     *
     * @param {String} recordId - a 15- or 18-char record id.
     * @return {String|null} - an 18-char record id, null if an invalid record id was provided.
     */
    function normalizeRecordId(recordId) {
      if (!recordId) {
        return null;
      }

      if (recordId.length === 15) {
        let suffix = '';
        const CASE_DECODE_STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456'; // Build the 3 character suffix

        for (let set = 0; set < 3; ++set) {
          let decodeValue = 0;

          for (let bit = 0; bit < 5; bit++) {
            const c = recordId.charAt(set * 5 + bit);

            if (c >= 'A' && c <= 'Z') {
              decodeValue += 1 << bit;
            }
          }

          suffix += CASE_DECODE_STRING.charAt(decodeValue);
        }

        return recordId + suffix;
      } else if (recordId.length === 18) {
        return recordId;
      }

      return null;
    }

    class DependencyManager {
      // map of fieldName -> {fieldElement, controllerName}
      // map of controllerFieldName -> [dependentFieldNames]
      // map of picklist fieldName -> picklistValues
      // cache of picklist options, fieldName-controllerValue -> picklistOptions
      constructor(dependencyInfo) {
        this._fieldValues = {};
        this._dependencyMap = {};
        this._picklistMap = {};
        this._optionsCache = {};

        if (dependencyInfo) {
          registerDependencyInfo.call(this, dependencyInfo);
        }
      }

      registerDependencyInfo(dependencyInfo) {
        registerDependencyInfo.call(this, dependencyInfo);
      }

      registerField(fieldInfo) {
        registerField.call(this, fieldInfo);
      }

      handleFieldValueChange(fieldName, fieldValue) {
        handleFieldValueChange.call(this, fieldName, fieldValue);
      }

    }

    function registerDependencyInfo({
      dependentFields,
      picklistValues
    }) {
      // mainly needed for tests to clear the existing maps before each test
      clearMaps.call(this);

      if (dependentFields) {
        buildDependencyMap.call(this, dependentFields);
      }

      if (picklistValues) {
        Object.assign(this._picklistMap, picklistValues);
      }
    }

    function buildDependencyMap(config) {
      for (const prop in config) {
        if (config.hasOwnProperty(prop)) {
          const result = Object.keys(config[prop]).reduce((prev, key) => {
            prev.push(key);
            return prev;
          }, []);

          if (result.length > 0) {
            this._dependencyMap[prop] = result;
          }

          buildDependencyMap.call(this, config[prop]);
        }
      }
    }

    function registerField({
      fieldName,
      fieldElement
    }) {
      // add field to fieldValues map
      if (!(fieldName in this._fieldValues)) {
        this._fieldValues[fieldName] = {
          controllerName: getControllerName.call(this, fieldName),
          fieldElement
        };
      }

      initializeField.call(this, fieldName);
    }

    function initializeField(fieldName) {
      const field = this._fieldValues[fieldName];
      const hasController = field.controllerName !== undefined; // controller could be registered after the dependent field. Avoid initializing the dependent before the controller is registered.

      const controllerNotRegistered = hasController && this._fieldValues[field.controllerName] === undefined;

      if (controllerNotRegistered) {
        return;
      } // checkbox fields don't have options, only need to update its dependents


      if (this._picklistMap[fieldName] !== undefined) {
        const controllerValue = getControllerValue.call(this, fieldName);
        const picklistOptions = getPicklistOptions.call(this, fieldName, controllerValue);
        updateFieldOptions(fieldName, field.fieldElement, picklistOptions);
      } // If controller field is registered after the dependent field, we have to update the dependents with the correct controller value


      const fieldValue = getFieldValue(fieldName, field.fieldElement);
      updateDependentFields.call(this, fieldName, fieldValue);
    }

    function handleFieldValueChange(fieldName, fieldValue) {
      updateDependentFields.call(this, fieldName, fieldValue);
    }

    function updateDependentFields(fieldName, fieldValue) {
      const dependentFieldNames = this._dependencyMap[fieldName] || [];

      if (!dependentFieldNames.length) {
        return;
      } // update the options on all of the fields that depend on the field


      for (let i = 0, len = dependentFieldNames.length; i < len; i++) {
        const dependentFieldName = dependentFieldNames[i];
        const field = this._fieldValues[dependentFieldName];

        if (field) {
          const newOptions = getPicklistOptions.call(this, dependentFieldName, fieldValue);
          updateFieldOptions(dependentFieldName, field.fieldElement, newOptions);
        }
      }
    }

    function getControllerName(fieldName) {
      return Object.keys(this._dependencyMap).find(key => this._dependencyMap[key].includes(fieldName));
    }

    function getControllerValue(fieldName) {
      const field = this._fieldValues[fieldName];
      const controllerField = this._fieldValues[field.controllerName]; // Value on the controller field could have been set to the picklist default value.
      // However, initially we may not have access to the controller field depending on the order that the fields are registered.

      let controllerValue;

      if (controllerField) {
        controllerValue = getFieldValue(field.controllerName, controllerField.fieldElement);
      }

      return controllerValue;
    }

    function getFieldValue(fieldName, fieldElement) {
      const fieldValue = fieldElement.getFieldValue(); // for compound fields like address, the value is an object

      if (typeof fieldValue === 'object' && fieldValue !== null) {
        return fieldValue[fieldName];
      }

      return fieldValue;
    }

    function getPicklistOptions(fieldName, controllerValue) {
      const cacheKey = getOptionsUniqueKey({
        fieldName,
        controllerValue
      });

      if (cacheKey in this._optionsCache) {
        return this._optionsCache[cacheKey];
      }

      const field = this._fieldValues[fieldName];
      const picklistInfo = this._picklistMap[fieldName];
      let picklistValues = picklistInfo && picklistInfo.values;
      const hasController = field.controllerName !== undefined;

      if (hasController) {
        if (controllerValue !== undefined && controllerValue !== null) {
          picklistValues = getDependentPicklistOptions(picklistInfo, controllerValue);
        } else {
          picklistValues = [];
        }
      }

      this._optionsCache[cacheKey] = picklistValues;
      return picklistValues;
    }

    function getDependentPicklistOptions(picklistOptions, controllerValue) {
      const controllerIndex = picklistOptions.controllerValues[controllerValue];
      const allPicklistOptions = picklistOptions.values;
      const options = [];

      for (let i = 0, len = allPicklistOptions.length; i < len; i++) {
        const option = allPicklistOptions[i];

        if (option.validFor.includes(controllerIndex)) {
          options.push(option);
        }
      }

      return options;
    }

    function updateFieldOptions(fieldName, fieldElement, options) {
      fieldElement.updateFieldOptions(fieldName, options);
    }

    function getOptionsUniqueKey(options) {
      return Object.keys(options).reduce((prev, optionName) => {
        const option = options[optionName];
        return option !== undefined && option !== '' ? prev + (prev !== '' ? '-' : '') + option + '' : prev + '';
      }, '');
    }

    function clearMaps() {
      this._fieldValues = {};
      this._dependencyMap = {};
      this._picklistMap = {};
      this._optionsCache = {};
    }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(Object(source)); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    const MASTER_RECORD_TYPE_ID$1 = '012000000000000AAA';
    /**
     * Represents a record edit layout that displays one or more fields, provided by lightning-input-field.
     * @slot default Placeholder for form components like lightning-messages, lightning-button, lightning-input-field and lightning-output-field.
     * Use lightning-input-field to display an editable field.
     */

    class LightningRecordEditForm extends lwc.LightningElement {
      /**
       * Reserved for internal use. Names of the fields to include in the form.
       * @type {string[]}
       */

      /**
       * The ID of the record type, which is required if you created
       * multiple record types but don't have a default.
       * @type {string}
       */

      /**
       * A CSS class for the form element.
       * @type {string}
       */
      // no optional fields!
      // used to trigger picklist values wire

      /**
       * switch between edit and create mode,
       * triggering correct wires
       */
      checkMode() {
        if (this._recordId) {
          this._createMode = false; // trigger record ui wire

          this._wiredRecordId = [this._recordId];
          this._wiredApiName = null;
        } else if (!this._recordIdError && this.objectApiName) {
          this._createMode = true; // trigger record create defaults wire

          this._wiredApiName = this.objectApiName;
          this._wiredRecordId = null;
        }

        if (this._layout) {
          this._wiredLayoutTypes = [this._layout];
          this._layoutMode = true;
        } else {
          this._layoutMode = false;
          this._wiredLayoutTypes = ['Full']; // default to full layout
        }
      }

      constructor() {
        super();
        this.fieldNames = void 0;
        this.recordTypeId = void 0;
        this.formClass = void 0;
        this.optionalFields = [];
        this.fieldSet = void 0;
        this._recordId = void 0;
        this._layout = void 0;
        this._pendingAction = false;
        this._wiredApiName = null;
        this._wiredRecordId = null;
        this._wiredLayoutTypes = null;
        this._createMode = false;
        this._layoutMode = false;
        this._objectApiName = null;
        this._connected = false;
        this._recordIdError = false;
        this._rendered = false;
        this._pendingError = void 0;
        this._density = densityValues.AUTO;
        this._fieldLabelAlignment = labelAlignValues.HORIZONTAL;
        this._initialRender = true;
        this._wiredPicklistApiName = null;
        this._wiredRecordTypeId = null;
        this.recordUi = void 0;
        this.errors = void 0;
        this._fields = void 0;
        this._inputComponents = void 0;
        this._formLayoutInterface = this.formLayoutInterface();
      }

      connectedCallback() {
        this.fieldSet = getFieldSet$1(this.objectApiName); // special case for person accounts

        if (this.objectApiName === 'Account' || this.objectApiName === 'PersonAccount') {
          this.fieldSet.add('IsPersonAccount');
        }

        this.checkMode(); // make sure mode check happens only when needed
        // not all the time

        this._connected = true;
      }

      renderedCallback() {
        // populate the initial set of optionalfields
        this._rendered = true;

        if (this._pendingError) {
          this.handleErrors(this._pendingError);
        }

        if (this._initialRender) {
          setLabelAlignment(this._formLayoutInterface);
          resetResizeObserver(this, this._formLayoutInterface);
        }

        this._initialRender = false;
        this.handleRegister();
      }

      set layoutType(val) {
        this._layout = val;
        this.checkMode();
      }
      /**
       * The type of layout to use to display the form fields. Possible values: Compact, Full.
       * @type {string}
       */


      get layoutType() {
        return this._layout;
      }
      /**
       * Sets the arrangement style of fields and labels in the form.
       * Accepted values are compact, comfy, and auto (default).
       * Use compact to display fields and their labels on the same line.
       * Use comfy to display fields below their labels.
       * Use auto to let the component dynamically set
       * the density according to the user's Display Density setting
       * and the width of the form.
       * @type {string}
       */


      get density() {
        return this._density;
      }

      set density(val) {
        doNormalization(val, this._formLayoutInterface);

        if (!this._initialRender) {
          resetResizeObserver(this, this._formLayoutInterface);
        }
      }

      set recordId(id) {
        if (!id) {
          this._createMode = true;
          this._recordId = null; // normalize falsy to null
        }

        this._recordId = normalizeRecordId(id);

        if (!this._recordId && !this._createMode) {
          const error = {
            message: labelInvalidId
          };
          this.handleErrors(error);
          this._recordIdError = true;
          return;
        }

        this._recordIdError = false; // switch to edit mode

        this._wiredApiName = null;
        this._createMode = false;
        this._wiredRecordId = [this._recordId];

        if (this._connected) {
          this.checkMode();
        }
      }
      /**
       * The ID of the record to be displayed.
       * @type {string}
       */


      get recordId() {
        return this._recordId;
      }

      set objectApiName(val) {
        let apiName; // duck typing for string vs object

        if (val.objectApiName) {
          apiName = val.objectApiName;
        } else {
          apiName = val;
        }

        this._objectApiName = apiName;

        if (this.fieldSet) {
          this.fieldSet.objectApiName = apiName;
        }

        if (this._connected) {
          this.checkMode();
        }
      }
      /**
       * The API name of the object.
       * @type {string}
       * @required
       */


      get objectApiName() {
        return this._objectApiName;
      }

      wiredRecordUi(value) {
        this.handleData(value);
      }

      wiredRecordCreateDefaults(value) {
        this.handleData(value);
      }

      wiredPicklistValuesByRecordType(value) {
        this.handlePicklistValues(value);
      }

      handleData({
        error,
        data
      }) {
        if (error) {
          this.handleErrors(error);
          return;
        } else if (!data) {
          return;
        }

        this.wiredRecord = data;
        const record = data.records ? data.records[this._recordId] : data.record;

        if (record.apiName !== this.objectApiName) {
          const message = labelApiNameMismatch.replace('{0}', this.objectApiName).replace('{1}', record.apiName);
          this.handleErrors({
            message
          });
          return;
        }

        const viewData = {
          record,
          objectInfo: data.objectInfos[this.objectApiName],
          objectInfos: data.objectInfos,
          createMode: !this._recordId,
          labelAlignment: this._fieldLabelAlignment
        };
        this.recordUi = viewData;
        this.getInputAndOutputComponents().forEach(field => {
          field.wireRecordUi(viewData);
        });

        if (formHasPicklists(viewData.objectInfo, this.optionalFields)) {
          // trigger picklist values wire and then fire load event
          this.triggerPicklistWire();
        } else {
          // no picklists, fire load event
          this.dispatchLoadEvent();
        }
      }

      triggerPicklistWire() {
        const oldRecordTypeId = this._wiredRecordTypeId;
        const oldObjectApiName = this._wiredPicklistApiName;
        this._wiredPicklistApiName = this.objectApiName;
        this._wiredRecordTypeId = this.recordTypeId || MASTER_RECORD_TYPE_ID$1; // if apiName and recordTypeId haven't changed, use the same picklist values. Wire service will not fetch the values again.

        if (oldObjectApiName === this._wiredPicklistApiName && oldRecordTypeId === this._wiredRecordTypeId) {
          this.handlePicklistValues(this._picklistValues);
        }
      }

      handlePicklistValues(value) {
        this._picklistValues = value;
        const {
          error,
          data
        } = value;

        if (error) {
          this.handleErrors(error);
        }

        if (!data) {
          return;
        }

        const filteredPicklistValues = filterByPicklistsInForm(this.recordUi.objectInfo, data.picklistFieldValues || data, this.optionalFields);
        this._picklistValuesInForm = filteredPicklistValues;
        this.initDependencyManager({
          dependentFields: this.recordUi.objectInfo.dependentFields,
          picklistValues: filteredPicklistValues
        });
        this.getInputFieldComponents().forEach(field => {
          field.wirePicklistValues(filteredPicklistValues);
        }); // picklist values are loaded at the end, after record data are wired

        this.dispatchLoadEvent();
      }

      validateForm() {
        const cmps = this.getInputFieldComponents();
        return validateForm(cmps);
      }
      /**
       * Submits the form using an array of record fields or field IDs.
       * The field ID is provisioned from @salesforce/schema/.
       * Invoke this method only after the load event.
       * @param {string[]|FieldId[]} fields - Array of record field names or field IDs.
       */


      submit(fields) {
        this.doSubmit(fields).catch(err => {
          this.handleErrors(err);
        });
      }

      doSubmit(fields) {
        return new Promise((resolve, reject) => {
          this._pendingAction = true;
          const originalRecord = this._createMode ? null : this.recordUi.record;
          const newRecord = {
            fields: fields ? fields : this.getFormValues(),
            // api gets mad if you have an api name for edit, don't have one for create
            apiName: this._createMode ? this._objectApiName : null
          }; // add recordTypeId if it is provided

          if (this.recordTypeId) {
            newRecord.fields.RecordTypeId = this.recordTypeId;
          }

          createOrSaveRecord(newRecord, originalRecord, this.recordUi.objectInfo).then(savedRecord => {
            this._pendingAction = false;
            const lightningMessages = this.querySelector('lightning-messages');

            if (lightningMessages) {
              lightningMessages.setError(null);
            }

            this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
            new CustomEvent('success', {
              composed: true,
              bubbles: true,
              detail: savedRecord
            }));
            resolve();
          }, err => {
            this._pendingAction = false;
            reject(err);
          });
        });
      }

      getFormValues() {
        return getFormValues(this.getInputFieldComponents());
      }

      handleError(err) {
        err.stopPropagation();
        this.handleErrors(err.detail.error);
      }

      handleErrors(error) {
        const messages = this.querySelector('lightning-messages');
        const err = lwc.unwrap(error); // error arrived before render so we'll have to handle it later

        if (!this._rendered) {
          this._pendingError = err;
          return;
        }

        this._pendingError = null;
        const inputComponents = this.getInputFieldComponents();

        if (err.body && err.body.output && err.body.output.fieldErrors) {
          const fieldNames = inputComponents.map(field => {
            return field.fieldName;
          });
          Object.keys(err.body.output.fieldErrors).forEach(field => {
            if (fieldNames.indexOf(field) === -1) {
              // field error on missing field!
              err.body.detail = err.body.output.fieldErrors[field][0].message;
            }
          });
        }

        if (messages) {
          messages.setError(err);
        }

        inputComponents.forEach(field => {
          field.setErrors(err);
        });
        this.dispatchEvent(createErrorEvent$1(err));
      }

      dispatchLoadEvent() {
        this.dispatchEvent(new CustomEvent('load', {
          detail: _objectSpread$1({}, this.wiredRecord, {
            picklistValues: this._picklistValuesInForm
          })
        }));
      }

      handleRegister() {
        this.fieldSet.concat(this.getFields());
        this.optionalFields = this.fieldSet.getList();
      }

      registerDependentField(e) {
        e.stopPropagation();
        const {
          fieldName,
          fieldElement
        } = e.detail;

        this._depManager.registerField({
          fieldName,
          fieldElement
        });
      }

      updateDependentFields(e) {
        e.stopPropagation();

        if (this._depManager) {
          this._depManager.handleFieldValueChange(e.detail.fieldName, e.detail.value);
        }
      }

      handleSubmit(e) {
        // submit buttons can't work in slots,
        // so we listen for clicks on submit buttons
        // TODO discuss with A11Y team
        if (e.target.type !== 'submit') {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (!this.validateForm()) {
          // trigger native validation popups
          this.template.querySelector('form').reportValidity();
          return;
        } // cleanly clone and unwrap fields


        const fields = JSON.parse(JSON.stringify(this.getFormValues())); // eslint-disable-next-line lightning-global/no-custom-event-bubbling

        const evt = new CustomEvent('submit', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            fields
          }
        });
        this.dispatchEvent(evt); // I think this should work, because events always
        // execute in the same stack, so tailing this
        // handler with setTimeout will cause it to wait until
        // the event has propogated to check for prevent default
        // there are some hacks with stopImmediatePropogation,
        // but they rely on re-firing the event, which won't work in
        // this situation
        // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          if (this._pendingAction) {
            return;
          }

          if (evt.defaultPrevented) {
            return;
          }

          this._pendingAction = true;
          this.doSubmit().catch(err => {
            this.handleErrors(err);
          });
        }, 0);
      }

      getInputFieldComponents() {
        return [...this.querySelectorAll('lightning-input-field')];
      }

      getInputAndOutputComponents() {
        return [...this.querySelectorAll('lightning-input-field,lightning-output-field')];
      }

      getFields() {
        return this.getInputAndOutputComponents().map(field => {
          return field.fieldName;
        });
      }

      initDependencyManager(dependencyInfo) {
        if (!this._depManager) {
          this._depManager = new DependencyManager(dependencyInfo);
        } else {
          this._depManager.registerDependencyInfo(dependencyInfo);
        }
      }

      formLayoutInterface() {
        const that = this;
        return {
          getDensityPrivate() {
            return that._density;
          },

          setDensityPrivate(value) {
            that._density = value;
          },

          getDensity() {
            return that.density;
          },

          getLabelAlignmentPrivate() {
            return that._fieldLabelAlignment;
          },

          getContainerElement() {
            return that.template.querySelector('form');
          },

          getInputOutputFields() {
            return that.getInputAndOutputComponents();
          },

          setLabelAlignmentPrivate(value) {
            that._fieldLabelAlignment = value;
          },

          getRecordUi() {
            return that.recordUi;
          },

          getResizeObserverCallback(callback) {
            return () => {
              callback(that._formLayoutInterface);
            };
          }

        };
      }

    }

    lwc.registerDecorators(LightningRecordEditForm, {
      publicProps: {
        fieldNames: {
          config: 0
        },
        recordTypeId: {
          config: 0
        },
        formClass: {
          config: 0
        },
        layoutType: {
          config: 3
        },
        density: {
          config: 3
        },
        recordId: {
          config: 3
        },
        objectApiName: {
          config: 3
        }
      },
      publicMethods: ["submit"],
      wire: {
        wiredRecordUi: {
          adapter: lds.getRecordUi,
          params: {
            recordIds: "_wiredRecordId",
            layoutTypes: "_wiredLayoutTypes",
            optionalFields: "optionalFields"
          },
          static: {
            modes: ['View']
          },
          method: 1
        },
        wiredRecordCreateDefaults: {
          adapter: lds.getRecordCreateDefaults,
          params: {
            objectApiName: "_wiredApiName",
            recordTypeId: "recordTypeId",
            optionalFields: "optionalFields"
          },
          static: {},
          method: 1
        },
        wiredPicklistValuesByRecordType: {
          adapter: lds.getPicklistValuesByRecordType,
          params: {
            objectApiName: "_wiredPicklistApiName",
            recordTypeId: "_wiredRecordTypeId"
          },
          static: {},
          method: 1
        }
      },
      track: {
        recordUi: 1,
        errors: 1
      }
    });

    var _lightningRecordEditForm = lwc.registerComponent(LightningRecordEditForm, {
      tmpl: _tmpl$2
    });

    function tmpl$3($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [$cmp.hasError ? api_element("div", {
        classMap: {
          "slds-notify_container": true,
          "slds-is-relative": true
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "slds-notify": true,
          "slds-notify_toast": true,
          "slds-theme_error": true
        },
        attrs: {
          "role": "alert"
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-notify__content": true
        },
        key: 4
      }, [api_element("h2", {
        classMap: {
          "slds-text-heading_small": true
        },
        key: 5
      }, [api_dynamic($cmp.err.message)]), $cmp.err.detail ? api_element("p", {
        key: 6
      }, [api_dynamic($cmp.err.detail)]) : null])])]) : null];
    }

    var _tmpl$3 = lwc.registerTemplate(tmpl$3);
    tmpl$3.stylesheets = [];
    tmpl$3.stylesheetTokens = {
      hostAttribute: "lightning-messages_messages-host",
      shadowAttribute: "lightning-messages_messages"
    };

    class LightningMessages extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.err = {};
        this.hasError = false;
      }

      // err is one of several error formats
      // returned by ui api, parseError normalizes them
      setError(err) {
        const parsedError = parseError$1(err);
        this.hasError = !!err;
        this.err = parsedError;
      }

      get error() {
        return this.err;
      } // alias to setError method, the
      // other method kept for backward compat


      set error(val) {
        this.setError(val);
      }

    }

    lwc.registerDecorators(LightningMessages, {
      publicProps: {
        error: {
          config: 3
        }
      },
      publicMethods: ["setError"],
      track: {
        err: 1,
        hasError: 1
      }
    });

    var _lightningMessages = lwc.registerComponent(LightningMessages, {
      tmpl: _tmpl$3
    });

    function stylesheet$3(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$3 = [stylesheet$3];

    function stylesheet$4(hostSelector, shadowSelector, nativeShadow) {
      return "_:-ms-lang(x)" + shadowSelector + ", svg" + shadowSelector + " {pointer-events: none;}\n";
    }
    var _implicitStylesheets$4 = [stylesheet$4];

    function tmpl$4($api, $cmp, $slotset, $ctx) {
      const {
        fid: api_scoped_frag_id,
        h: api_element
      } = $api;
      return [api_element("svg", {
        className: $cmp.computedClass,
        attrs: {
          "focusable": "false",
          "data-key": $cmp.name,
          "aria-hidden": "true"
        },
        key: 2
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", api_scoped_frag_id($cmp.href))
        },
        key: 3
      }, [])])];
    }

    var _tmpl$4 = lwc.registerTemplate(tmpl$4);
    tmpl$4.stylesheets = [];

    if (_implicitStylesheets$4) {
      tmpl$4.stylesheets.push.apply(tmpl$4.stylesheets, _implicitStylesheets$4);
    }
    tmpl$4.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIcon_primitiveIcon-host",
      shadowAttribute: "lightning-primitiveIcon_primitiveIcon"
    };

    const proto = {
      add(className) {
        if (typeof className === 'string') {
          this[className] = true;
        } else {
          Object.assign(this, className);
        }

        return this;
      },

      invert() {
        Object.keys(this).forEach(key => {
          this[key] = !this[key];
        });
        return this;
      },

      toString() {
        return Object.keys(this).filter(key => this[key]).join(' ');
      }

    };
    function classSet(config) {
      if (typeof config === 'string') {
        const key = config;
        config = {};
        config[key] = true;
      }

      return Object.assign(Object.create(proto), config);
    }

    // NOTE: lightning-utils is a public library. adding new utils here means we

    var _tmpl$5 = void 0;

    // Taken from https://github.com/jonathantneal/svg4everybody/pull/139
    // Remove this iframe-in-edge check once the following is resolved https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8323875/
    const isEdgeUA = /\bEdge\/.(\d+)\b/.test(navigator.userAgent);
    const inIframe = window.top !== window.self;
    const isIframeInEdge = isEdgeUA && inIframe;
    var isIframeInEdge$1 = lwc.registerComponent(isIframeInEdge, {
      tmpl: _tmpl$5
    });

    // Taken from https://git.soma.salesforce.com/aura/lightning-global/blob/999dc35f948246181510df6e56f45ad4955032c2/src/main/components/lightning/SVGLibrary/stamper.js#L38-L60
    function fetchSvg(url) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              resolve(xhr.responseText);
            } else {
              reject(xhr);
            }
          }
        };
      });
    }

    // Which looks like it was inspired by https://github.com/jonathantneal/svg4everybody/blob/377d27208fcad3671ed466e9511556cb9c8b5bd8/lib/svg4everybody.js#L92-L107
    // Modify at your own risk!

    const newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
    const webkitUA = /\bAppleWebKit\/(\d+)\b/;
    const olderEdgeUA = /\bEdge\/12\.(\d+)\b/;
    const isIE = newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537;
    const supportsSvg = !isIE && !isIframeInEdge$1;
    var supportsSvg$1 = lwc.registerComponent(supportsSvg, {
      tmpl: _tmpl$5
    });

    /**
    This polyfill injects SVG sprites into the document for clients that don't
    fully support SVG. We do this globally at the document level for performance
    reasons. This causes us to lose namespacing of IDs across sprites. For example,
    if both #image from utility sprite and #image from doctype sprite need to be
    rendered on the page, both end up as #image from the doctype sprite (last one
    wins). SLDS cannot change their image IDs due to backwards-compatibility
    reasons so we take care of this issue at runtime by adding namespacing as we
    polyfill SVG elements.

    For example, given "/assets/icons/action-sprite/svg/symbols.svg#approval", we
    replace the "#approval" id with "#${namespace}-approval" and a similar
    operation is done on the corresponding symbol element.
    **/
    const svgTagName = /svg/i;

    const isSvgElement = el => el && svgTagName.test(el.nodeName);

    const requestCache = {};
    const symbolEls = {};
    const svgFragments = {};
    const spritesContainerId = 'slds-svg-sprites';
    let spritesEl;
    function polyfill(el) {
      if (!supportsSvg$1 && isSvgElement(el)) {
        if (!spritesEl) {
          spritesEl = document.createElement('svg');
          spritesEl.xmlns = 'http://www.w3.org/2000/svg';
          spritesEl['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
          spritesEl.style.display = 'none';
          spritesEl.id = spritesContainerId;
          document.body.insertBefore(spritesEl, document.body.childNodes[0]);
        }

        Array.from(el.getElementsByTagName('use')).forEach(use => {
          // We access the href differently in raptor and in aura, probably
          // due to difference in the way the svg is constructed.
          const src = use.getAttribute('xlink:href') || use.getAttribute('href');

          if (src) {
            // "/assets/icons/action-sprite/svg/symbols.svg#approval" =>
            // ["/assets/icons/action-sprite/svg/symbols.svg", "approval"]
            const parts = src.split('#');
            const url = parts[0];
            const id = parts[1];
            const namespace = url.replace(/[^\w]/g, '-');
            const href = `#${namespace}-${id}`;

            if (url.length) {
              // set the HREF value to no longer be an external reference
              if (use.getAttribute('xlink:href')) {
                use.setAttribute('xlink:href', href);
              } else {
                use.setAttribute('href', href);
              } // only insert SVG content if it hasn't already been retrieved


              if (!requestCache[url]) {
                requestCache[url] = fetchSvg(url);
              }

              requestCache[url].then(svgContent => {
                // create a document fragment from the svgContent returned (is parsed by HTML parser)
                if (!svgFragments[url]) {
                  const svgFragment = document.createRange().createContextualFragment(svgContent);
                  svgFragments[url] = svgFragment;
                }

                if (!symbolEls[href]) {
                  const svgFragment = svgFragments[url];
                  const symbolEl = svgFragment.querySelector(`#${id}`);
                  symbolEls[href] = true;
                  symbolEl.id = `${namespace}-${id}`;
                  spritesEl.appendChild(symbolEl);
                }
              });
            }
          }
        });
      }
    }

    const validNameRe = /^([a-zA-Z]+):([a-zA-Z]\w*)$/;
    const underscoreRe = /_/g;
    let pathPrefix;
    const tokenNameMap = Object.assign(Object.create(null), {
      action: 'lightning.actionSprite',
      custom: 'lightning.customSprite',
      doctype: 'lightning.doctypeSprite',
      standard: 'lightning.standardSprite',
      utility: 'lightning.utilitySprite'
    });
    const tokenNameMapRtl = Object.assign(Object.create(null), {
      action: 'lightning.actionSpriteRtl',
      custom: 'lightning.customSpriteRtl',
      doctype: 'lightning.doctypeSpriteRtl',
      standard: 'lightning.standardSpriteRtl',
      utility: 'lightning.utilitySpriteRtl'
    });
    const defaultTokenValueMap = Object.assign(Object.create(null), {
      'lightning.actionSprite': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.actionSpriteRtl': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.customSprite': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.customSpriteRtl': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.doctypeSprite': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.doctypeSpriteRtl': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.standardSprite': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.standardSpriteRtl': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.utilitySprite': '/assets/icons/utility-sprite/svg/symbols.svg',
      'lightning.utilitySpriteRtl': '/assets/icons/utility-sprite/svg/symbols.svg'
    });

    const getDefaultBaseIconPath = (category, nameMap) => defaultTokenValueMap[nameMap[category]];

    const getBaseIconPath = (category, direction) => {
      const nameMap = direction === 'rtl' ? tokenNameMapRtl : tokenNameMap;
      return configProvider$1.getToken(nameMap[category]) || getDefaultBaseIconPath(category, nameMap);
    };

    const getMatchAtIndex = index => iconName => {
      const result = validNameRe.exec(iconName);
      return result ? result[index] : '';
    };

    const getCategory = getMatchAtIndex(1);
    const getName = getMatchAtIndex(2);
    const isValidName = iconName => validNameRe.test(iconName);
    const getIconPath = (iconName, direction = 'ltr') => {
      pathPrefix = pathPrefix !== undefined ? pathPrefix : configProvider$1.getPathPrefix();

      if (isValidName(iconName)) {
        const baseIconPath = getBaseIconPath(getCategory(iconName), direction);

        if (baseIconPath) {
          // This check was introduced the following MS-Edge issue:
          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9655192/
          // If and when this get fixed, we can safely remove this block of code.
          if (isIframeInEdge$1) {
            // protocol => 'https:' or 'http:'
            // host => hostname + port
            const origin = `${window.location.protocol}//${window.location.host}`;
            return `${origin}${pathPrefix}${baseIconPath}#${getName(iconName)}`;
          }

          return `${pathPrefix}${baseIconPath}#${getName(iconName)}`;
        }
      }

      return '';
    };
    const computeSldsClass = iconName => {
      if (isValidName(iconName)) {
        const category = getCategory(iconName);
        const name = getName(iconName).replace(underscoreRe, '-');
        return `slds-icon-${category}-${name}`;
      }

      return '';
    };

    const isSafari = window.safari && window.safari.pushNotification && window.safari.pushNotification.toString() === '[object SafariRemoteNotification]'; // [W-3421985] https://bugs.webkit.org/show_bug.cgi?id=162866
    // https://git.soma.salesforce.com/aura/lightning-global/blob/82e8bfd02846fa7e6b3e7549a64be95b619c4b1f/src/main/components/lightning/primitiveIcon/primitiveIconHelper.js#L53-L56

    function safariA11yPatch(svgElement) {
      if (!svgElement || !isSafari) {
        return;
      } // In case we're dealing with a proxied element.


      svgElement = lwc.unwrap(svgElement);
      const use = svgElement.querySelector('use');

      if (!use) {
        return;
      }

      svgElement.insertBefore(document.createTextNode('\n'), use); // If use.nextSibling is null, the text node is added to the end of
      // the list of children of the SVG element.
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore

      svgElement.insertBefore(document.createTextNode('\n'), use.nextSibling);
    }

    class LightningPrimitiveIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconName = void 0;
        this.src = void 0;
        this.svgClass = void 0;
        this.size = 'medium';
        this.variant = void 0;
        this.privateIconSvgTemplates = configProvider$1.getIconSvgTemplates();
      }

      get inlineSvgProvided() {
        return !!this.privateIconSvgTemplates;
      }

      renderedCallback() {
        if (this.iconName !== this.prevIconName && !this.inlineSvgProvided) {
          this.prevIconName = this.iconName;
          const svgElement = this.template.querySelector('svg');
          polyfill(svgElement);
          safariA11yPatch(svgElement);
        }
      }

      get href() {
        return this.src || getIconPath(this.iconName, configProvider$1.getLocale && configProvider$1.getLocale().dir);
      }

      get name() {
        return getName(this.iconName);
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      get normalizedVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.variant, {
          fallbackValue: '',
          validValues: ['bare', 'error', 'inverse', 'warning', 'success']
        });
      }

      get computedClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const classes = classSet(this.svgClass);

        if (normalizedVariant !== 'bare') {
          classes.add('slds-icon');
        }

        switch (normalizedVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'success':
            classes.add('slds-icon-text-success');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            if (!this.src) {
              classes.add('slds-icon-text-default');
            }

        }

        if (normalizedSize !== 'medium') {
          classes.add(`slds-icon_${normalizedSize}`);
        }

        return classes.toString();
      }

      resolveTemplate() {
        const name = this.iconName;

        if (isValidName(name)) {
          const [spriteName, iconName] = name.split(':');
          const template = this.privateIconSvgTemplates[`${spriteName}_${iconName}`];

          if (template) {
            return template;
          }
        }

        return _tmpl$4;
      }

      render() {
        if (this.inlineSvgProvided) {
          return this.resolveTemplate();
        }

        return _tmpl$4;
      }

    }

    lwc.registerDecorators(LightningPrimitiveIcon, {
      publicProps: {
        iconName: {
          config: 0
        },
        src: {
          config: 0
        },
        svgClass: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      }
    });

    var _lightningPrimitiveIcon = lwc.registerComponent(LightningPrimitiveIcon, {
      tmpl: _tmpl$4
    });

    function tmpl$5($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        classMap: {
          "slds-form-element__icon": true
        },
        key: 2
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "type": "button"
        },
        key: 3
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "svgClass": $cmp.computedSvgClass,
          "iconName": $cmp.iconName,
          "variant": "bare"
        },
        key: 4
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 5
      }, [api_dynamic($cmp.i18n.buttonAlternativeText)])])])];
    }

    var _tmpl$6 = lwc.registerTemplate(tmpl$5);
    tmpl$5.stylesheets = [];
    tmpl$5.stylesheetTokens = {
      hostAttribute: "lightning-helptext_helptext-host",
      shadowAttribute: "lightning-helptext_helptext"
    };

    var labelButtonAlternativeText = 'Help';

    const POSITION_ATTR_NAME = 'data-position-id';

    class BrowserWindow {
      get window() {
        if (!this._window) {
          this._window = window; // JTEST/Ingtegration: getComputedStyle may be null

          if (!this.window.getComputedStyle) {
            this.window.getComputedStyle = node => {
              return node.style;
            };
          }
        }

        return this._window;
      }

      mockWindow(value) {
        // For test, allow mock window.
        this._window = value;
      }

      get documentElement() {
        assert(this.window.document, 'Missing window.document');
        return this.window.document.documentElement;
      }

      get MutationObserver() {
        return this.window.MutationObserver;
      }

      isWindow(element) {
        return element && element.toString() === '[object Window]';
      }

    }

    const WindowManager = new BrowserWindow(); // A global

    let passiveEventsSupported;

    function supportsPassiveEvents() {
      if (typeof passiveEventsSupported !== 'boolean') {
        passiveEventsSupported = false;

        try {
          const opts = Object.defineProperty({}, 'passive', {
            get: () => {
              passiveEventsSupported = true;
            }
          });
          window.addEventListener('testPassive', null, opts);
          window.removeEventListener('testPassive', null, opts); // eslint-disable-next-line no-empty
        } catch (e) {}
      }

      return passiveEventsSupported;
    }

    function attachPassiveEvent(element, eventName, callback) {
      const options = supportsPassiveEvents() ? {
        passive: true
      } : false;
      element.addEventListener(eventName, callback, options);
      return () => {
        element.removeEventListener(eventName, callback, options);
      };
    }

    function isShadowRoot(node) {
      return node && node.nodeType === 11;
    }

    function enumerateParent(elem, stopEl, checker) {
      // document.body is not necessarily a body tag, because of the (very rare)
      // case of a frameset.
      if (!elem || elem === stopEl || elem === document.body) {
        return null;
      } // if overflow is auto and overflow-y is also auto,
      // however in firefox the opposite is not true


      try {
        // getComputedStyle throws an exception
        // if elem is not an element
        // (can happen during unrender)
        const computedStyle = WindowManager.window.getComputedStyle(elem);

        if (!computedStyle) {
          return null;
        }

        if (checker(computedStyle)) {
          return elem;
        }

        return enumerateParent(isShadowRoot(elem.parentNode) ? elem.parentNode.host : elem.parentNode, stopEl, checker);
      } catch (e) {
        return null;
      }
    }

    function getScrollableParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        const overflow = computedStyle['overflow-y'];
        return overflow === 'auto' || overflow === 'scroll';
      });
    }

    function queryOverflowHiddenParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        return computedStyle['overflow-x'] === 'hidden' || computedStyle['overflow-y'] === 'hidden';
      });
    }

    function isInDom(el) {
      if (el === WindowManager.window) {
        return true;
      }

      if (!isShadowRoot(el.parentNode) && el.parentNode && el.parentNode.tagName && el.parentNode.tagName.toUpperCase() === 'BODY') {
        return true;
      }

      if (isShadowRoot(el.parentNode) && el.parentNode.host) {
        return isInDom(el.parentNode.host);
      }

      if (el.parentNode) {
        return isInDom(el.parentNode);
      }

      return false;
    }
    function isScrolling(elem) {
      return elem.scrollHeight > elem.clientHeight;
    }
    function isDomNode(obj) {
      return obj.nodeType && (obj.nodeType === 1 || obj.nodeType === 11);
    }
    function timeout(time) {
      return new Promise(resolve => {
        // eslint-disable-next-line lwc/no-set-timeout
        setTimeout(() => {
          resolve();
        }, time);
      });
    }
    function containsScrollingElement(list) {
      const len = list.length;

      if (!len) {
        return false;
      }

      for (let i = 0; i < len; i++) {
        if (isScrolling(list[i])) {
          return true;
        }
      }

      return false;
    }
    function queryScrollableChildren(element) {
      return element.querySelectorAll('[data-scoped-scroll="true"]');
    }
    function getPositionTarget(element) {
      return element.tagName === 'TEXTAREA' ? isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode : element;
    }
    let lastId = 1000000;
    function generateUniqueSelector() {
      return `lgcp-${lastId++}`;
    }
    function normalizeElement(element) {
      const selector = generateUniqueSelector();
      element.setAttribute(POSITION_ATTR_NAME, selector);
      element = document.querySelector(`[${POSITION_ATTR_NAME}="${selector}"]`) || element;
      return element;
    }

    function isInsideOverlay(element, modalOnly) {
      if (!element) {
        return false;
      }

      if (element.classList && (element.classList.contains('uiModal') || !modalOnly && element.classList.contains('uiPanel'))) {
        return true;
      }

      if (!element.parentNode) {
        return false;
      }

      return isInsideOverlay(isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode, modalOnly);
    }

    function isInsideModal(element) {
      return isInsideOverlay(element, true);
    }
    function normalizePosition(element, nextIndex, target, alignWidth) {
      // Set element position to fixed
      // 1. element is inside overlay
      // or 2. When element isn't align with target's width, and target's parent has overflow-x:hidden setting.
      const isFixed = isInsideOverlay(element) || !alignWidth && queryOverflowHiddenParent(target, WindowManager.window, true);
      element.style.position = isFixed ? 'fixed' : 'absolute';
      element.style.zIndex = nextIndex || 0;
      element.style.left = '-9999px'; // Avoid flicker

      element.style.top = '0px'; // Avoid flicker

      return element;
    }
    function requestAnimationFrameAsPromise() {
      return new Promise(resolve => {
        requestAnimationFrame(() => resolve());
      });
    }

    const Direction = {
      Center: 'center',
      Middle: 'middle',
      Right: 'right',
      Left: 'left',
      Bottom: 'bottom',
      Top: 'top',
      Default: 'default'
    };
    const VerticalMap = {
      top: Direction.Top,
      bottom: Direction.Bottom,
      center: Direction.Middle
    };
    const HorizontalMap = {
      left: Direction.Left,
      right: Direction.Right,
      center: Direction.Center
    };
    const FlipMap = {
      left: Direction.Right,
      right: Direction.Left,
      top: Direction.Bottom,
      bottom: Direction.Top,
      center: Direction.Center,
      default: Direction.Right
    };

    function getWindowSize() {
      return {
        width: WindowManager.window.innerWidth || document.body.clientWidth || 0,
        height: WindowManager.window.innerHeight || document.body.clientHeight || 0
      };
    }

    function normalizeDirection(direction, defaultValue) {
      return normalizeString(direction, {
        fallbackValue: defaultValue || Direction.Default,
        validValues: [Direction.Center, Direction.Right, Direction.Left, Direction.Bottom, Direction.Top, Direction.Middle, Direction.Default]
      });
    }
    function mapToHorizontal(value) {
      value = normalizeDirection(value, Direction.Left);
      return HorizontalMap[value];
    }
    function mapToVertical(value) {
      value = normalizeDirection(value, Direction.Left);
      return VerticalMap[value];
    }
    function flipDirection(value) {
      value = normalizeDirection(value, Direction.Left);
      return FlipMap[value];
    } // TODO: Remove, not currently in use.
    function checkFlipPossibility(element, target, leftAsBoundary) {
      const viewPort = getWindowSize();
      const elemRect = element.getBoundingClientRect();
      const referenceElemRect = target.getBoundingClientRect();
      const height = typeof elemRect.height !== 'undefined' ? elemRect.height : elemRect.bottom - elemRect.top;
      const width = typeof elemRect.width !== 'undefined' ? elemRect.width : elemRect.right - elemRect.left; // TODO: We'll need to revisit the leftAsBoundary config property. Either we'll need a better
      // name to cover the RTL language cases and maybe open up the possibility of bounding the
      // element to the target in both the horizontal and vertical directions.
      // The boundary shrinks the available area to the edge of the target rather than the viewport.

      let rightAsBoundary = false;

      if (document.dir === 'rtl') {
        rightAsBoundary = leftAsBoundary;
        leftAsBoundary = false;
      }

      const hasSpaceAbove = referenceElemRect.top >= height;
      const hasSpaceBelow = viewPort.height - referenceElemRect.bottom >= height; // Assuming left alignment is specified this tests if:
      // - there's room to accommodate the element with right alignment
      // - there's not enough room to accommodate the element with left alignment

      const shouldAlignToRight = referenceElemRect.right >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width); // Assuming right alignment is specified this tests if:
      // - there's room to accommodate the element with left alignment
      // - there's not enough room to accommodate the element with right alignment

      const shouldAlignToLeft = referenceElemRect.left + width <= viewPort.width && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0); // Assuming center alignment, does the viewport have space to fit half of the element around
      // the target?

      const centerOverflow = {
        left: referenceElemRect.left - width * 0.5 < 0,
        right: referenceElemRect.right + width * 0.5 > viewPort.width,
        top: referenceElemRect.top - height * 0.5 < 0,
        bottom: referenceElemRect.bottom + height * 0.5 > viewPort.height
      };
      return {
        shouldAlignToLeft,
        shouldAlignToRight,
        hasSpaceAbove,
        hasSpaceBelow,
        centerOverflow
      };
    }

    class Transformer {
      constructor(pad, boxDirections, transformX, transformY) {
        this.pad = pad || 0;
        this.boxDirections = boxDirections || {
          left: true,
          right: true
        };

        this.transformX = transformX || function () {};

        this.transformY = transformY || function () {};
      }

      transform() {// no-op
      }

    }

    class TopTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) + this.pad
        };
      }

    }

    class BottomTransFormer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) - elementBox.height - this.pad
        };
      }

    }

    class CenterTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - 0.5 * elementBox.width)
        };
      }

    }

    class MiddleTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(0.5 * (2 * targetBox.top + targetBox.height - elementBox.height))
        };
      }

    }

    class LeftTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) + this.pad
        };
      }

    }

    class RightTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) - elementBox.width - this.pad
        };
      }

    }

    class BelowTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const top = targetBox.top + targetBox.height + this.pad;
        return elementBox.top < top ? {
          top
        } : {};
      }

    }

    const MIN_HEIGHT = 36; // Minimum Line Height

    const MIN_WIDTH = 36;

    class ShrinkingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
          retBox.height = Math.max(elementBox.height - (retBox.top - elementBox.top), MIN_HEIGHT);
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
          retBox.width = Math.max(elementBox.width - (retBox.left - elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.right = targetBox.left + targetBox.width - this.pad;
          retBox.width = Math.max(retBox.right - (retBox.left || elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.bottom = targetBox.top + targetBox.height - this.pad;
          retBox.height = Math.max(retBox.bottom - (retBox.top || elementBox.top), MIN_HEIGHT);
        }

        return retBox;
      }

    }

    class BoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.left = targetBox.left + targetBox.width - elementBox.width - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.top = targetBox.top + targetBox.height - elementBox.height - this.pad;
        }

        return retBox;
      }

    }

    class InverseBoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.left && targetBox.left - this.pad < elementBox.left) {
          retBox.left = targetBox.left - this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width < targetBox.left + targetBox.width + this.pad) {
          retBox.left = targetBox.width + this.pad - elementBox.width + targetBox.left;
        }

        if (this.boxDirections.top && targetBox.top < elementBox.top + this.pad) {
          retBox.top = targetBox.top - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height < targetBox.top + targetBox.height + this.pad) {
          retBox.top = targetBox.height + this.pad - elementBox.height + targetBox.top;
        }

        return retBox;
      }

    }

    const TransformFunctions = {
      center(input, targetBox) {
        return Math.floor(input + 0.5 * targetBox.width);
      },

      right(input, targetBox) {
        return input + targetBox.width;
      },

      left(input) {
        return input;
      },

      bottom(input, targetBox) {
        return input + targetBox.height;
      }

    };
    const Transformers = {
      top: TopTransformer,
      bottom: BottomTransFormer,
      center: CenterTransformer,
      middle: MiddleTransformer,
      left: LeftTransformer,
      right: RightTransformer,
      below: BelowTransformer,
      'bounding box': BoundingBoxTransformer,
      'shrinking box': ShrinkingBoxTransformer,
      'inverse bounding box': InverseBoundingBoxTransformer,
      default: Transformer
    };
    function toTransformFunctions(value) {
      return TransformFunctions[value] || TransformFunctions.left;
    }

    class TransformBuilder {
      type(value) {
        this._type = value;
        return this;
      }

      align(horizontal, vertical) {
        this._transformX = toTransformFunctions(horizontal);
        this._transformY = toTransformFunctions(vertical);
        return this;
      }

      pad(value) {
        this._pad = parseInt(value, 10);
        return this;
      }

      boxDirections(value) {
        this._boxDirections = value;
        return this;
      }

      build() {
        const AConstructor = Transformers[this._type] ? Transformers[this._type] : Transformers[Direction.Default];
        return new AConstructor(this._pad || 0, this._boxDirections || {}, this._transformX || toTransformFunctions(Direction.left), this._transformY || toTransformFunctions(Direction.left));
      }

    }

    class Constraint {
      constructor(type, config) {
        const {
          target,
          element,
          pad,
          boxDirections
        } = config;
        const {
          horizontal,
          vertical
        } = config.targetAlign;
        this._element = element;
        this._targetElement = target;
        this.destroyed = false;
        this._transformer = new TransformBuilder().type(type).align(horizontal, vertical).pad(pad).boxDirections(boxDirections).build();
      }

      detach() {
        this._disabled = true;
      }

      attach() {
        this._disabled = false;
      }

      computeDisplacement() {
        if (!this._disabled) {
          this._targetElement.refresh();

          this._element.refresh();

          this._pendingBox = this._transformer.transform(this._targetElement, this._element);
        }

        return this;
      }

      computePosition() {
        const el = this._element;

        if (!this._disabled) {
          Object.keys(this._pendingBox).forEach(key => {
            el.setDirection(key, this._pendingBox[key]);
          });
        }

        return this;
      }

      destroy() {
        this._element.release();

        this._targetElement.release();

        this._disabled = true;
        this.destroyed = true;
      }

    }

    class ElementProxy {
      constructor(el, id) {
        this.id = id;
        this.width = 0;
        this.height = 0;
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this._dirty = false;
        this._node = null;
        this._releaseCb = null;

        if (!el) {
          throw new Error('Element missing');
        } // W-3262919
        // for some reason I cannot figure out sometimes the
        // window, which clearly a window object, is not the window object
        // this will correct that. It might be related to locker


        if (WindowManager.isWindow(el)) {
          el = WindowManager.window;
        }

        this._node = el;
        this.setupObserver();
        this.refresh();
      }

      setupObserver() {
        // this check is because phantomjs does not support
        // mutation observers. The consqeuence here
        // is that any browser without mutation observers will
        // fail to update dimensions if they changwe after the proxy
        // is created and the proxy is not not refreshed
        if (WindowManager.MutationObserver && !this._node.isObserved) {
          // Use mutation observers to invalidate cache. It's magic!
          this._observer = new WindowManager.MutationObserver(this.refresh.bind(this)); // do not observe the window

          if (!WindowManager.isWindow(this._node)) {
            this._observer.observe(this._node, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });

            this._node.isObserved = true;
          }
        }
      }

      setReleaseCallback(cb, scope) {
        const scopeObj = scope || this;
        this._releaseCb = cb.bind(scopeObj);
      }

      checkNodeIsInDom() {
        // if underlying DOM node is gone,
        // this proxy should be released
        if (!isInDom(this._node)) {
          return false;
        }

        return true;
      }

      refresh() {
        const w = WindowManager.window;

        if (!this.isDirty()) {
          if (!this.checkNodeIsInDom()) {
            return this.release();
          }

          let box, x, scrollTop, scrollLeft;

          if (typeof w.pageYOffset !== 'undefined') {
            scrollTop = w.pageYOffset;
            scrollLeft = w.pageXOffset;
          } else {
            scrollTop = w.scrollY;
            scrollLeft = w.scrollX;
          }

          if (!WindowManager.isWindow(this._node)) {
            // force paint
            // eslint-disable-next-line no-unused-vars
            const offsetHeight = this._node.offsetHeight;
            box = this._node.getBoundingClientRect(); // not using integers causes weird rounding errors
            // eslint-disable-next-line guard-for-in

            for (x in box) {
              this[x] = Math.floor(box[x]);
            }

            this.top = Math.floor(this.top + scrollTop);
            this.bottom = Math.floor(this.top + box.height);
            this.left = Math.floor(this.left + scrollLeft);
            this.right = Math.floor(this.left + box.width);
          } else {
            box = {};
            this.width = WindowManager.documentElement.clientWidth;
            this.height = WindowManager.documentElement.clientHeight;
            this.left = scrollLeft;
            this.top = scrollTop;
            this.right = WindowManager.documentElement.clientWidth + scrollLeft;
            this.bottom = WindowManager.documentElement.clientHeight;
          }

          this._dirty = false;
        }

        return this._dirty;
      }

      getNode() {
        return this._node;
      }

      isDirty() {
        return this._dirty;
      }

      bake() {
        const w = WindowManager.window;

        const absPos = this._node.getBoundingClientRect();

        const style = w.getComputedStyle(this._node) || this._node.style;

        const hasPageOffset = typeof w.pageYOffset !== 'undefined';
        const scrollTop = hasPageOffset ? w.pageYOffset : w.scrollY;
        const scrollLeft = hasPageOffset ? w.pageXOffset : w.scrollX;
        const originalLeft = style.left.match(/auto|fixed/) ? '0' : parseInt(style.left.replace('px', ''), 10);
        const originalTop = style.top.match(/auto|fixed/) ? '0' : parseInt(style.top.replace('px', ''), 10);
        const leftDif = Math.round(this.left - (absPos.left + scrollLeft));
        const topDif = this.top - (absPos.top + scrollTop);
        this._node.style.left = `${originalLeft + leftDif}px`;
        this._node.style.top = `${originalTop + topDif}px`;

        if (this._restoreSize) {
          // Only store the first height/width which is the original height/width.
          this.originalHeight = this.originalHeight || this._node.style.height;
          this.originalWidth = this.originalWidth || this._node.style.width;
          this._node.style.width = `${this.width}px`;
          this._node.style.height = `${this.height}px`;
        }

        this._dirty = false;
      }

      setDirection(direction, val) {
        this[direction] = val;
        this._dirty = true; // if size is changed, should restore the original size.

        if (direction === 'height' || direction === 'width') {
          this._restoreSize = true;
        }
      }

      release() {
        if (this._restoreSize) {
          this._node.style.width = this.originalWidth;
          this._node.style.height = this.originalHeight;

          if (this._removeMinHeight) {
            this._node.style.minHeight = '';
          }
        }

        if (this._releaseCb) {
          this._releaseCb(this);
        }
      }

      querySelectorAll(selector) {
        return this._node.querySelectorAll(selector);
      }

    }

    class ProxyCache {
      constructor() {
        this.proxyCache = {};
      }

      get count() {
        return Object.keys(this.proxyCache).length;
      }

      releaseOrphanProxies() {
        for (const proxy in this.proxyCache) {
          if (!this.proxyCache[proxy].el.checkNodeIsInDom()) {
            this.proxyCache[proxy].el.release();
          }
        }
      }

      bakeOff() {
        for (const proxy in this.proxyCache) {
          if (this.proxyCache[proxy].el.isDirty()) {
            this.proxyCache[proxy].el.bake();
          }
        }
      }

      getReferenceCount(proxy) {
        const id = proxy.id;

        if (!id || !this.proxyCache[id]) {
          return 0;
        }

        return this.proxyCache[id].refCount;
      }

      release(proxy) {
        const proxyInstance = this.proxyCache[proxy.id];

        if (proxyInstance) {
          --proxyInstance.refCount;
        }

        if (proxyInstance && proxyInstance.refCount <= 0) {
          delete this.proxyCache[proxy.id];
        }
      }

      reset() {
        this.proxyCache = {};
      }

      create(element) {
        let key = 'window';

        if (!WindowManager.isWindow(element)) {
          key = element ? element.getAttribute(POSITION_ATTR_NAME) : null; // 1 - Node.ELEMENT_NODE, 11 - Node.DOCUMENT_FRAGMENT_NODE

          assert(key && element.nodeType && (element.nodeType !== 1 || element.nodeType !== 11), `Element Proxy requires an element and has property ${POSITION_ATTR_NAME}`);
        }

        if (this.proxyCache[key]) {
          this.proxyCache[key].refCount++;
          return this.proxyCache[key].el;
        }

        const newProxy = new ElementProxy(element, key);
        newProxy.setReleaseCallback(release, newProxy);
        this.proxyCache[key] = {
          el: newProxy,
          refCount: 1
        }; // run GC

        timeout(0).then(() => {
          this.releaseOrphanProxies();
        });
        return this.proxyCache[key].el;
      }

    }

    const elementProxyCache = new ProxyCache();
    function bakeOff() {
      elementProxyCache.bakeOff();
    }
    function release(proxy) {
      return elementProxyCache.release(proxy);
    }
    function createProxy(element) {
      return elementProxyCache.create(element);
    }

    class RepositionQueue {
      constructor() {
        this.callbacks = [];
        this.repositionScheduled = false;
        this._constraints = [];
        this.timeoutId = 0;
        this.lastIndex = getZIndexBaseline();
        this.eventsBound = false;
      }

      get nextIndex() {
        return this.lastIndex++;
      }

      get constraints() {
        return this._constraints;
      }

      set constraints(value) {
        this._constraints = this._constraints.concat(value);
      }

      dispatchRepositionCallbacks() {
        while (this.callbacks.length > 0) {
          this.callbacks.shift()();
        }
      }

      add(callback) {
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
          return true;
        }

        return false;
      }

      scheduleReposition(callback) {
        if (this.timeoutId === 0) {
          // eslint-disable-next-line lwc/no-set-timeout
          this.timeoutId = setTimeout(() => {
            this.reposition(callback);
          }, 10);
        }
      }

      reposition(callback) {
        // all the callbacks will be called
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
        } // this is for throttling


        clearTimeout(this.timeoutId);
        this.timeoutId = 0; // this semaphore is to make sure
        // if reposition is called twice within one frame
        // we only run this once

        if (!this.repositionScheduled) {
          requestAnimationFrame(() => {
            this.repositionScheduled = false; // this must be executed in order or constraints
            // will behave oddly

            this._constraints = this._constraints.filter(constraint => {
              if (!constraint.destroyed) {
                constraint.computeDisplacement().computePosition();
                return true;
              }

              return false;
            });
            bakeOff();
            this.dispatchRepositionCallbacks();
          });
          this.repositionScheduled = true;
        }
      }

      get repositioning() {
        if (!this._reposition) {
          this._reposition = this.scheduleReposition.bind(this);
        }

        return this._reposition;
      }

      bindEvents() {
        if (!this.eventsBound) {
          window.addEventListener('resize', this.repositioning);
          window.addEventListener('scroll', this.repositioning);
          this.eventsBound = true;
        }
      }

      detachEvents() {
        window.removeEventListener('resize', this.repositioning);
        window.removeEventListener('scroll', this.repositioning);
        this.eventsBound = false;
      }

    }

    const positionQueue = new RepositionQueue();
    function scheduleReposition(callback) {
      positionQueue.scheduleReposition(callback);
    }
    function bindEvents() {
      positionQueue.bindEvents();
    }
    function addConstraints(list) {
      positionQueue.constraints = list;
    }
    function reposition(callback) {
      positionQueue.reposition(callback);
    }
    function nextIndex() {
      return positionQueue.nextIndex;
    }

    class Relationship {
      constructor(config, constraintList, scrollableParent) {
        this.config = config;
        this.constraintList = constraintList;
        this.scrollableParent = scrollableParent;
      }

      disable() {
        this.constraintList.forEach(constraintToDisable => {
          constraintToDisable.detach();
        });
      }

      enable() {
        this.constraintList.forEach(constraintToEnable => {
          constraintToEnable.attach();
        });
      }

      destroy() {
        if (this.config.removeListeners) {
          this.config.removeListeners();
          this.config.removeListeners = undefined;
        }

        while (this.constraintList.length > 0) {
          this.constraintList.pop().destroy();
        } // Clean up node appended to body of dom


        if (this.config.appendToBody && this.config.element) {
          const nodeToRemove = document.querySelector(`[${POSITION_ATTR_NAME}="${this.config.element.getAttribute(POSITION_ATTR_NAME)}"]`);

          if (nodeToRemove) {
            nodeToRemove.parentNode.removeChild(nodeToRemove);
          }
        }
      }

      reposition() {
        return new Promise(resolve => {
          reposition(() => {
            resolve();
          });
        });
      }

    }

    const DEFAULT_MIN_HEIGHT = '1.875rem';

    function setupObserver(config, scrollableParent) {
      let proxyWheelEvents = true;

      if (WindowManager.MutationObserver && !config.element.isObserved) {
        // phantomjs :(
        let scrollableChildren = queryScrollableChildren(config.element);
        const observer = new WindowManager.MutationObserver(() => {
          scrollableChildren = queryScrollableChildren(config.element);
          proxyWheelEvents = !containsScrollingElement(scrollableChildren);
        });

        if (containsScrollingElement(scrollableChildren)) {
          proxyWheelEvents = false;
        }

        observer.observe(config.element, {
          attributes: true,
          subtree: true,
          childList: true
        });
        config.element.isObserved = true;
      }

      if (scrollableParent) {
        const scrollRemovalFunction = attachPassiveEvent(scrollableParent, 'scroll', scheduleReposition); // if the target element is inside a
        // scrollable element, we need to make sure
        // scroll events move that element,
        // not the parent, also we need to reposition on scroll

        const wheelRemovalFunction = attachPassiveEvent(config.element, 'wheel', e => {
          if (proxyWheelEvents && scrollableParent && typeof scrollableParent.scrollTop !== 'undefined') {
            scrollableParent.scrollTop += e.deltaY;
          }
        });

        config.removeListeners = () => {
          scrollRemovalFunction();
          wheelRemovalFunction();
        };
      }
    }

    function validateConfig(config) {
      assert(config.element && isDomNode(config.element), 'Element is undefined or missing, or not a Dom Node');
      assert(config.target && (WindowManager.isWindow(config.target) || isDomNode(config.target)), 'Target is undefined or missing');
    }

    function createRelationship(config) {
      bindEvents();
      config.element = normalizePosition(config.element, nextIndex(), config.target, config.alignWidth);

      if (config.alignWidth && config.element.style.position === 'fixed') {
        config.element.style.width = config.target.getBoundingClientRect().width + 'px';
      }

      const constraintList = [];
      const scrollableParent = getScrollableParent(getPositionTarget(config.target), WindowManager.window); // This observer and the test for scrolling children
      // is so that if a panel contains a scroll we do not
      // proxy the events to the "parent"  (actually the target's parent)

      setupObserver(config, scrollableParent);

      if (config.appendToBody) {
        document.body.appendChild(config.element);
      }

      config.element = createProxy(config.element);
      config.target = createProxy(config.target); // Add horizontal constraint.

      const horizontalConfig = Object.assign({}, config);

      if (horizontalConfig.padLeft !== undefined) {
        horizontalConfig.pad = horizontalConfig.padLeft;
      } // Add vertical constraint.


      const verticalConfig = Object.assign({}, config);

      if (verticalConfig.padTop !== undefined) {
        verticalConfig.pad = verticalConfig.padTop;
      }

      constraintList.push(new Constraint(mapToHorizontal(config.align.horizontal), horizontalConfig));
      constraintList.push(new Constraint(mapToVertical(config.align.vertical), verticalConfig));
      const autoShrink = config.autoShrink.height || config.autoShrink.width;

      if (config.scrollableParentBound && scrollableParent) {
        const parent = normalizeElement(scrollableParent);
        const boxConfig = {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(parent),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        };

        if (autoShrink) {
          const style = boxConfig.element.getNode().style;

          if (!style.minHeight) {
            style.minHeight = config.minHeight;
            boxConfig.element._removeMinHeight = true;
          }

          boxConfig.boxDirections = {
            top: !!config.autoShrink.height,
            bottom: !!config.autoShrink.height,
            left: !!config.autoShrink.width,
            right: !!config.autoShrink.width
          };
          constraintList.push(new Constraint('shrinking box', boxConfig));
        } else {
          constraintList.push(new Constraint('bounding box', boxConfig));
        }
      }

      addConstraints(constraintList);
      reposition();
      return new Relationship(config, constraintList, scrollableParent);
    }

    function isAutoFlipHorizontal(config) {
      return config.autoFlip || config.autoFlipHorizontal;
    }

    function isAutoFlipVertical(config) {
      return config.autoFlip || config.autoFlipVertical;
    }

    function normalizeAlignments(config, flipConfig) {
      const align = {
        horizontal: config.align.horizontal,
        vertical: config.align.vertical
      };
      const targetAlign = {
        horizontal: config.targetAlign.horizontal,
        vertical: config.targetAlign.vertical
      }; // Horizontal alignments flip for RTL languages.

      if (document.dir === 'rtl') {
        align.horizontal = flipDirection(align.horizontal);
        targetAlign.horizontal = flipDirection(targetAlign.horizontal);
      } // When using the autoFlip flags with center alignment, we change the element alignment to fit
      // within the viewport when it's detected that it overflows the edge of the viewport.


      let vFlip = false;

      if (isAutoFlipVertical(config)) {
        if (align.vertical === Direction.Bottom) {
          vFlip = !flipConfig.hasSpaceAbove && flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Top) {
          vFlip = flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Center) {
          if (flipConfig.centerOverflow.top && !flipConfig.centerOverflow.bottom) {
            align.vertical = targetAlign.vertical = Direction.Top;
          } else if (flipConfig.centerOverflow.bottom && !flipConfig.centerOverflow.top) {
            align.vertical = targetAlign.vertical = Direction.Bottom;
          }
        }
      }

      let hFlip = false;

      if (isAutoFlipHorizontal(config)) {
        if (align.horizontal === Direction.Left) {
          hFlip = flipConfig.shouldAlignToRight;
        } else if (align.horizontal === Direction.Right) {
          hFlip = flipConfig.shouldAlignToLeft;
        } else if (align.horizontal === Direction.Center) {
          if (flipConfig.centerOverflow.left && !flipConfig.centerOverflow.right) {
            align.horizontal = targetAlign.horizontal = Direction.Left;
          } else if (flipConfig.centerOverflow.right && !flipConfig.centerOverflow.left) {
            align.horizontal = targetAlign.horizontal = Direction.Right;
          }
        }
      }

      return {
        align: {
          horizontal: hFlip ? flipDirection(align.horizontal) : normalizeDirection(align.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(align.vertical) : normalizeDirection(align.vertical, Direction.Top)
        },
        targetAlign: {
          horizontal: hFlip ? flipDirection(targetAlign.horizontal) : normalizeDirection(targetAlign.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(targetAlign.vertical) : normalizeDirection(targetAlign.vertical, Direction.Bottom)
        }
      };
    }

    function normalizeConfig(config) {
      config.align = config.align || {};
      config.targetAlign = config.targetAlign || {};
      const flipConfig = checkFlipPossibility(config.element, config.target, config.leftAsBoundary);
      const {
        align,
        targetAlign
      } = normalizeAlignments(config, flipConfig);
      config.isInsideModal = isInsideModal(config.element); // When inside modal, element may expand out of the viewport and be cut off.
      // So if inside modal, and don't have enough space above or below, will add bounding box rule.

      if (config.isInsideModal && !flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow) {
        config.scrollableParentBound = true;
      }

      return {
        target: config.target,
        element: config.element,
        align,
        targetAlign,
        alignWidth: config.alignWidth,
        scrollableParentBound: config.scrollableParentBound,
        pad: config.pad,
        padTop: config.padTop,
        padLeft: config.padLeft,
        autoShrink: {
          height: config.autoShrink || config.autoShrinkHeight,
          width: config.autoShrink || config.autoShrinkWidth
        },
        minHeight: config.minHeight || DEFAULT_MIN_HEIGHT
      };
    }

    function toElement(root, target) {
      if (target && typeof target === 'string') {
        return root.querySelector(target);
      } else if (target && typeof target === 'function') {
        return lwc.unwrap(target());
      }

      return target;
    }

    function startPositioning(root, config) {
      assert(root, 'Root is undefined or missing');
      assert(config, 'Config is undefined or missing');
      const node = normalizeElement(root);
      const target = toElement(node, config.target);
      const element = toElement(node, config.element); // when target/element is selector, there is chance, dom isn't present anymore.

      if (!target || !element) {
        return null;
      }

      config.target = normalizeElement(target);
      config.element = normalizeElement(element);
      validateConfig(config);
      return createRelationship(normalizeConfig(config));
    }
    function stopPositioning(relationship) {
      if (relationship) {
        relationship.destroy();
      }
    }
    class AutoPosition {
      constructor(root) {
        this._autoPositionUpdater = null;
        this._root = root;
      }

      start(config) {
        return requestAnimationFrameAsPromise().then(() => {
          let promise = Promise.resolve();

          if (!this._autoPositionUpdater) {
            this._autoPositionUpdater = startPositioning(this._root, config);
          } else {
            promise = promise.then(() => {
              return this._autoPositionUpdater.reposition();
            });
          }

          return promise.then(() => {
            return this._autoPositionUpdater;
          });
        });
      }

      stop() {
        if (this._autoPositionUpdater) {
          stopPositioning(this._autoPositionUpdater);
          this._autoPositionUpdater = null;
        }

        return Promise.resolve();
      }

    }

    function tmpl$6($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element
      } = $api;
      return [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 2
      }, [])];
    }

    var _tmpl$7 = lwc.registerTemplate(tmpl$6);
    tmpl$6.stylesheets = [];
    tmpl$6.stylesheetTokens = {
      hostAttribute: "lightning-primitiveBubble_primitiveBubble-host",
      shadowAttribute: "lightning-primitiveBubble_primitiveBubble"
    };

    const DEFAULT_ALIGN = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    class LightningPrimitiveBubble extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          visible: false,
          contentId: ''
        };
        this.divElement = void 0;
      }

      get contentId() {
        return this.state.contentId;
      }

      set contentId(value) {
        this.state.contentId = value;

        if (this.state.inDOM) {
          this.divEl.setAttribute('id', this.state.contentId);
        }
      }

      connectedCallback() {
        this.updateClassList();
        this.state.inDOM = true;
      }

      disconnectedCallback() {
        this.state.inDOM = false;
      }

      renderedCallback() {
        // set content manually once rendered
        // - this is required to avoid the content update being in the wrong 'tick'
        this.setContentManually();
        this.setIdManually();
      }

      set content(value) {
        this.state.content = value;

        if (this.state.inDOM) {
          this.setContentManually();
        }
      }

      get content() {
        return this.state.content || '';
      }

      get align() {
        return this.state.align || DEFAULT_ALIGN;
      }

      set align(value) {
        this.state.align = value;
        this.updateClassList();
      }

      get visible() {
        return this.state.visible;
      }

      set visible(value) {
        this.state.visible = value;
        this.updateClassList();
      }

      setIdManually() {
        this.divElement = this.divElement ? this.divElement : this.template.querySelector('div');
        this.divElement.setAttribute('id', this.state.contentId);
      } // manually set the content value


      setContentManually() {
        /* manipulate DOM directly */
        this.template.querySelector('.slds-popover__body').textContent = this.state.content;
      } // compute class value for this bubble


      updateClassList() {
        const classes = classSet('slds-popover').add('slds-popover_tooltip'); // show or hide bubble

        classes.add({
          'slds-rise-from-ground': this.visible,
          'slds-fall-into-ground': !this.visible
        }); // apply the proper nubbin CSS class

        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom',
          'slds-nubbin_bottom': horizontal === 'center' && vertical === 'bottom',
          'slds-nubbin_top': horizontal === 'center' && vertical === 'top',
          'slds-nubbin_left': horizontal === 'left' && vertical === 'center',
          'slds-nubbin_right': horizontal === 'right' && vertical === 'center'
        });
        classListMutation(this.classList, classes);
      }

    }

    lwc.registerDecorators(LightningPrimitiveBubble, {
      publicProps: {
        contentId: {
          config: 3
        },
        content: {
          config: 3
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var LightningPrimitiveBubble$1 = lwc.registerComponent(LightningPrimitiveBubble, {
      tmpl: _tmpl$7
    });

    const BUBBLE_ID = `salesforce-lightning-tooltip-bubble_${guid()}`;
    /**
     * Shared instance of a primitive bubble used as a tooltip by most components. This was originally
     * defined in the helptext component which is where the minWidth style came from.
     * TODO: We may want to revisit the minWidth style with the PO and/or UX.
     */

    let CACHED_BUBBLE_ELEMENT;

    function getCachedBubbleElement() {
      if (!CACHED_BUBBLE_ELEMENT) {
        CACHED_BUBBLE_ELEMENT = lwc.createElement('lightning-primitive-bubble', {
          is: LightningPrimitiveBubble$1
        });
        CACHED_BUBBLE_ELEMENT.contentId = BUBBLE_ID;
        CACHED_BUBBLE_ELEMENT.style.position = 'absolute';
        CACHED_BUBBLE_ELEMENT.style.minWidth = '75px';
      }

      return CACHED_BUBBLE_ELEMENT;
    }

    const ARIA_DESCRIBEDBY = 'aria-describedby';
    /**
     * Used as a position offset to compensate for the nubbin. The dimensions of the nubbin are not
     * included in the position library bounding box calculations. This is the size in pixels of the
     * nubbin.
     * TODO: We may want to measure this instead in cases it changes.
     */

    const NUBBIN_SIZE = 16;
    /**
     * Used in the calculation that moves the tooltip to a location that places the nubbin at the
     * center of the target element. This is the nubbin offset from the edge of the bubble in pixels
     * when using slds-nubbin_bottom-left or slds-nubbin_bottom-right.
     * TODO: We may want to measure this instead in case it changes.
     */

    const NUBBIN_OFFSET = 24;
    /**
     * Known tooltip types:
     * - info: used in cases where target already has click handlers such as button-icon
     * - toggle: used in cases where target only shows a tooltip such as helptext
     */

    const TooltipType = {
      Info: 'info',
      Toggle: 'toggle'
    };
    /**
     * Allows us to attach a tooltip to components. Typical usage is as follows:
     * - Create an instance of Tooltip
     * - Call Tooltip.initialize() to add the appropriate listeners to the element that needs a tooltip
     * See buttonIcon and buttonMenu for example usage.
     */

    class Tooltip {
      /**
       * A shared instance of primitiveBubble is used when an element is not specified in the config
       * object.
       * @param {string} value the content of the tooltip
       * @param {object} config specifies the root component, target element of the tooltip
       */
      constructor(value, config) {
        this._autoPosition = null;
        this._disabled = true;
        this._initialized = false;
        this._visible = false;
        assert(config.target, 'target for tooltip is undefined or missing');
        this.value = value;
        this._root = config.root;
        this._target = config.target;
        this._type = normalizeString(config.type, {
          fallbackValue: TooltipType.Info,
          validValues: Object.values(TooltipType)
        }); // If a tooltip element is not given, fall back on the globally shared instance.

        this._element = config.element;

        if (!this._element) {
          this._element = getCachedBubbleElement;
          const bubbleElement = getCachedBubbleElement();

          if (bubbleElement.parentNode === null) {
            document.body.appendChild(bubbleElement);
          }
        }

        this.handleDocumentTouch = this.handleDocumentTouch.bind(this);
      }
      /**
       * Disables the tooltip.
       */


      detach() {
        this._disabled = true;
      }
      /**
       * Enables the tooltip.
       */


      attach() {
        this._disabled = false;
      }
      /**
       * Adds the appropriate event listeners to the target element to make the tooltip appear. Also
       * links the tooltip and target element via the aria-describedby attribute for screen readers.
       */


      initialize() {
        const target = this._target();

        if (!this._initialized && target) {
          switch (this._type) {
            case TooltipType.Toggle:
              this.addToggleListeners();
              break;

            case TooltipType.Info:
            default:
              this.addInfoListeners();
              break;
          }

          const ariaDescribedBy = normalizeAriaAttribute([target.getAttribute(ARIA_DESCRIBEDBY), this._element().contentId]);
          target.setAttribute(ARIA_DESCRIBEDBY, ariaDescribedBy);
          this._initialized = true;
        }
      }

      addInfoListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          ['mouseenter', 'focus'].forEach(event => target.addEventListener(event, () => this.show())); // Unlike the tooltip in Aura, we want clicks and keys to dismiss the tooltip.

          ['mouseleave', 'blur', 'click', 'keydown'].forEach(event => target.addEventListener(event, () => this.hide()));
        }
      }

      handleDocumentTouch() {
        if (this._visible) {
          this.hide();
        }
      }

      addToggleListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          if (Tooltip.isMobile()) {
            target.addEventListener('touchstart', e => {
              e.stopPropagation();
              this.toggle();
            });
          } else {
            ['mouseenter', 'focus'].forEach(event => target.addEventListener(event, () => this.show()));
            ['mouseleave', 'blur'].forEach(event => target.addEventListener(event, () => this.hide()));
          }
        }
      }

      show() {
        if (this._disabled) {
          return;
        }

        this._visible = true;

        const tooltip = this._element();

        tooltip.content = this._value;
        this.startPositioning();

        if (Tooltip.isMobile()) {
          document.addEventListener('touchstart', this.handleDocumentTouch);
        }
      }

      hide() {
        this._visible = false;

        const tooltip = this._element();

        tooltip.visible = this._visible;
        this.stopPositioning();

        if (Tooltip.isMobile()) {
          document.removeEventListener('touchstart', this.handleDocumentTouch);
        }
      }

      toggle() {
        if (this._visible) {
          this.hide();
        } else {
          this.show();
        }
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._disabled = !value;
      }

      get initialized() {
        return this._initialized;
      }

      get visible() {
        return this._visible;
      }

      startPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this._root);
        } // The lightning-helptext component was originally left aligned.


        const align = {
          horizontal: Direction.Left,
          vertical: Direction.Bottom
        };
        const targetAlign = {
          horizontal: Direction.Left,
          vertical: Direction.Top
        }; // Pads the tooltip so its nubbin is at the center of the target element.

        const targetBox = this._target().getBoundingClientRect();

        const padLeft = targetBox.width * 0.5 - NUBBIN_OFFSET;

        this._autoPosition.start({
          target: this._target,
          element: this._element,
          align,
          targetAlign,
          autoFlip: true,
          padTop: NUBBIN_SIZE,
          padLeft
        }).then(autoPositionUpdater => {
          // The calculation above may have flipped the alignment of the tooltip. When the
          // tooltip changes alignment we need to update the nubbin class to have it draw in
          // the appropriate place.
          const tooltip = this._element();

          tooltip.align = autoPositionUpdater.config.align;
          tooltip.visible = this._visible;
        });
      }

      stopPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      static isMobile() {
        return configProvider$1.getFormFactor() === 'PHONE';
      }

    }

    const i18n = {
      buttonAlternativeText: labelButtonAlternativeText
    };
    const DEFAULT_ICON_NAME = 'utility:info';
    const DEFAULT_ICON_VARIANT = 'bare';
    /**
     * An icon with a text popover used for tooltips.
     */

    class LightningHelptext extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          iconName: DEFAULT_ICON_NAME,
          iconVariant: DEFAULT_ICON_VARIANT
        };
        this._tooltip = null;
      }

      /**
       * Text to be shown in the popover.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set content(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button'),
            type: TooltipType.Toggle
          });

          this._tooltip.initialize();
        }
      }

      get content() {
        return this._tooltip ? this._tooltip.value : undefined;
      }
      /**
       * The Lightning Design System name of the icon used as the visible element.
       * Names are written in the format 'utility:info' where 'utility' is the category,
       * and 'info' is the specific icon to be displayed.
       * The default is 'utility:info'.
       * @type {string}
       * @param {string} value the icon name to use
       * @default utility:info
       */


      set iconName(value) {
        this.state.iconName = value;
      }

      get iconName() {
        if (isValidName(this.state.iconName)) {
          return this.state.iconName;
        }

        return DEFAULT_ICON_NAME;
      }
      /**
       * Changes the appearance of the icon.
       * Accepted variants include inverse, warning, error.
       * @type {string}
       * @param {string} value the icon variant to use
       * @default bare
       */


      set iconVariant(value) {
        this.state.iconVariant = value;
      }

      get iconVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.state.iconVariant, {
          fallbackValue: DEFAULT_ICON_VARIANT,
          validValues: ['bare', 'error', 'inverse', 'warning']
        });
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      get i18n() {
        return i18n;
      } // compute SVG CSS classes to apply to the icon


      get computedSvgClass() {
        const classes = classSet('slds-button__icon');

        switch (this.iconVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            classes.add('slds-icon-text-default');
        }

        return classes.toString();
      }

    }

    lwc.registerDecorators(LightningHelptext, {
      publicProps: {
        content: {
          config: 3
        },
        iconName: {
          config: 3
        },
        iconVariant: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningHelptext = lwc.registerComponent(LightningHelptext, {
      tmpl: _tmpl$6
    });

    function stylesheet$5(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n[dir=\"rtl\"] input[type=\"tel\"]" + shadowSelector + " {direction: ltr;text-align: right;unicode-bidi: embed;}\n";
    }
    var _implicitStylesheets$5 = [stylesheet$5];

    function stylesheet$6(hostSelector, shadowSelector, nativeShadow) {
      return "slot" + shadowSelector + " {display: inline-block;}\n";
    }
    var _implicitStylesheets$6 = [stylesheet$6];

    function tmpl$7($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot
      } = $api;
      return [api_slot("", {
        key: 2
      }, [], $slotset)];
    }

    var _tmpl$8 = lwc.registerTemplate(tmpl$7);
    tmpl$7.slots = [""];
    tmpl$7.stylesheets = [];

    if (_implicitStylesheets$6) {
      tmpl$7.stylesheets.push.apply(tmpl$7.stylesheets, _implicitStylesheets$6);
    }
    tmpl$7.stylesheetTokens = {
      hostAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone-host",
      shadowAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone"
    };

    class LightningPrimitiveFileDroppableZone extends lwc.LightningElement {
      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      constructor() {
        super();
        this._disabled = void 0;
        this._multiple = void 0;
        this.template.addEventListener('dragover', this.allowDrop.bind(this));
        this.template.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.template.addEventListener('drop', this.handleOnDrop.bind(this));
      }

      connectedCallback() {
        this.classList.add('slds-file-selector__dropzone');
      }

      setDragOver(dragOver) {
        this.classList.toggle('slds-has-drag-over', dragOver);
      }

      handleDragLeave() {
        this.setDragOver(false);
      }

      handleOnDrop(event) {
        event.preventDefault();
        this.setDragOver(false);

        if (this.disabled) {
          event.stopPropagation();
          return;
        }

        if (!this.meetsMultipleCriteria(event)) {
          event.stopPropagation();
        }
      }

      allowDrop(event) {
        event.preventDefault();

        if (!this.disabled) {
          this.setDragOver(true);
        }
      }

      meetsMultipleCriteria(dragEvent) {
        const files = dragEvent.dataTransfer.files;
        return !(files.length > 1 && !this.multiple);
      }

    }

    lwc.registerDecorators(LightningPrimitiveFileDroppableZone, {
      publicProps: {
        disabled: {
          config: 3
        },
        multiple: {
          config: 3
        }
      },
      track: {
        _disabled: 1,
        _multiple: 1
      }
    });

    var _lightningPrimitiveFileDroppableZone = lwc.registerComponent(LightningPrimitiveFileDroppableZone, {
      tmpl: _tmpl$8
    });

    function tmpl$8($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-color-picker__custom": true
        },
        key: 2
      }, [api_element("p", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("color-picker-instructions")
        },
        key: 3
      }, [api_dynamic($cmp.i18n.colorPickerInstructions)]), api_element("div", {
        classMap: {
          "slds-m-bottom_small": true
        },
        style: $cmp.gradientStyle,
        attrs: {
          "data-id": "color-gradient"
        },
        key: 4,
        on: {
          "mousedown": _m3 || ($ctx._m3 = api_bind($cmp.handleMouseDown))
        }
      }, [api_element("canvas", {
        attrs: {
          "width": $cmp.canvasRect.x,
          "height": $cmp.canvasRect.y
        },
        key: 5
      }, []), api_element("a", {
        classMap: {
          "slds-color-picker__range-indicator": true
        },
        styleMap: {
          "position": "absolute",
          "display": "inline"
        },
        attrs: {
          "data-id": "color-anchor",
          "href": "javascript:void(0)",
          "aria-live": "assertive",
          "aria-atomic": "true",
          "aria-describedby": `${api_scoped_id("color-picker-instructions")}`
        },
        key: 6,
        on: {
          "mousedrag": _m0 || ($ctx._m0 = api_bind($cmp.handlePreventDefault)),
          "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.handlePreventDefault)),
          "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 7
      }, [api_dynamic($cmp.computedSaturationAndBrightness)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__hue-and-preview": true
        },
        key: 8
      }, [api_element("label", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "for": `${api_scoped_id("rainbow")}`
        },
        key: 9
      }, [api_dynamic($cmp.i18n.hueInput)]), api_element("input", {
        classMap: {
          "slds-color-picker__hue-slider": true
        },
        attrs: {
          "data-id": "hue-slider",
          "type": "range",
          "min": "0",
          "max": "360",
          "id": api_scoped_id("rainbow")
        },
        props: {
          "value": $cmp._hueValue
        },
        key: 10,
        on: {
          "mousedown": _m4 || ($ctx._m4 = api_bind($cmp.handleDrag)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.onChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.thumbnailStyle,
        attrs: {
          "data-id": "color-preview"
        },
        key: 11
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 12
      }, [api_dynamic($cmp._hex)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__custom-inputs": true
        },
        key: 13
      }, [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__input-custom-hex": true
        },
        key: 14
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 15
      }, [api_dynamic($cmp.i18n.hexLabel)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 16
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "data-primary-input": true,
          "type": "text",
          "id": api_scoped_id("input"),
          "minlength": "4",
          "maxlength": "7",
          "pattern": "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
          "placeholder": "#FFFFFF"
        },
        props: {
          "value": $cmp._hex
        },
        key: 17,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleHexChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 18
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("red")}`
        },
        key: 19
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.redAbbr
        },
        key: 20
      }, [api_dynamic($cmp.i18n.rInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 21
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("red"),
          "data-color-name": "red",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.red
        },
        key: 22,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("green")}`
        },
        key: 24
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.greenAbbr
        },
        key: 25
      }, [api_dynamic($cmp.i18n.gInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 26
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("green"),
          "data-color-name": "green",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.green
        },
        key: 27,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 28
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("blue")}`
        },
        key: 29
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.blueAbbr
        },
        key: 30
      }, [api_dynamic($cmp.i18n.bInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 31
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("blue"),
          "data-color-name": "blue",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.blue
        },
        key: 32,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleRgbChange))
        }
      }, [])])])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "aria-live": "assertive"
        },
        key: 34
      }, [api_dynamic($cmp._errorMessage)]) : null])];
    }

    var _tmpl$9 = lwc.registerTemplate(tmpl$8);
    tmpl$8.stylesheets = [];
    tmpl$8.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerCustom_colorPickerCustom-host",
      shadowAttribute: "lightning-colorPickerCustom_colorPickerCustom"
    };

    var labelBInput = 'B';

    var labelBlueAbbr = 'Blue';

    var labelColorPickerInstructions = 'Use arrow keys to select a saturation and brightness, on an x and y axis.';

    var labelErrorMessage = 'Enter a valid hexadecimal value.';

    var labelGInput = 'G';

    var labelGreenAbbr = 'Green';

    var labelHexLabel = 'Hex';

    var labelHueInput = 'Select Hue';

    var labelRInput = 'R';

    var labelRedAbbr = 'Red';

    let idCounter = 0;
    function generateUniqueId(prefix = 'input') {
      idCounter++;
      return `${prefix}-${idCounter}`;
    }

    /**
     Represents an object which keeps track of a user's interacting state.
     @constructor InteractingState
     @param {Object} options - The options object.
     @param {Object} [options.duration=2000] - The number of milliseconds of idle time to wait before exiting the interacting state.
     @param {Object} [options.debounceInteraction=false] - Whether to debounce interaction to ignore consecutive leave-enter interactions.
     **/

    class InteractingState {
      constructor(options) {
        const duration = options && options.duration >= 0 ? options.duration : 2000;
        this.eventemitter = new EventEmitter();
        this._interacting = false;
        this._debouncedLeave = debounce(this.leave.bind(this), duration);
        this._debounceInteraction = options && options.debounceInteraction;
        this._interactedRecently = false;

        if (this._debounceInteraction) {
          // debounce leave until a short time later
          this._debouncedEmitLeave = debounce(() => {
            if (!this._interacting) {
              this._interactedRecently = false;
              this.eventemitter.emit('leave');
            }
          }, 200); // debounce enter until left

          this._debouncedEmitEnter = () => {
            if (!this._interactedRecently) {
              this._interactedRecently = true;
              this.eventemitter.emit('enter');
            }
          };
        }
      }
      /**
       Checks whether or not we are in the interacting state.
       @method InteractingState#isInteracting
       @return {Boolean} - Whether or not we are interacting.
       **/


      isInteracting() {
        return this._interacting;
      }
      /**
       Enters the interacting state.
       @method InteractingState#enter
       @returns {void}
       **/


      enter() {
        if (!this._interacting) {
          this._interacting = true;

          if (this._debounceInteraction) {
            this._debouncedEmitEnter();
          } else {
            this.eventemitter.emit('enter');
          }
        }
      }
      /**
       Registers a handler to execute when we enter the interacting state.
       @method InteractingState#onenter
       @param {Function} handler - The callback function.
       **/


      onenter(handler) {
        this.eventemitter.on('enter', handler);
      }
      /**
       Leaves the interacting state.
       @method InteractingState#leave
       @returns {void}
       **/


      leave() {
        if (this._interacting) {
          this._interacting = false;

          if (this._debounceInteraction) {
            this._debouncedEmitLeave();
          } else {
            this.eventemitter.emit('leave');
          }
        }
      }
      /**
       Registers a handler to execute when we leave the interacting state.
       @method InteractingState#onleave
       @param {Function} handler - The callback function.
       **/


      onleave(handler) {
        this.eventemitter.on('leave', handler);
      }
      /**
       Signals the start of the transition into the interacting state and
       schedules a transition out of the interacting state after an idle
       duration. Calling this method multiple times will reset the timer.
       @method InteractingState#interacting
       @returns {void}
       **/


      interacting() {
        this.enter();

        this._debouncedLeave();
      }

    }
    /**
     Creates a debounced function that delays invoking `func` until after
     `delay` milliseconds have elapsed since the last time the debounced
     function was invoked.
     @function debounce
     @param {Function} func - The function to debounce
     @param {Number} delay - The number of milliseconds to delay
     @param {Object} options - The options object
     @param {Boolean} options.leading - Specify invoking on the leading edge of the timeout
     @return {Function} - debounced function
     **/

    function debounce(func, delay, options) {
      const _options = options || {};

      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);

        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }

        clearTimeout(timer); // eslint-disable-next-line lwc/no-set-timeout

        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    var labelBadInput = 'Enter a valid value.';

    var labelPatternMismatch = 'Your entry does not match the allowed pattern.';

    var labelRangeOverflow = 'The number is too high.';

    var labelRangeUnderflow = 'The number is too low.';

    var labelStepMismatch = 'Your entry isn\'t a valid increment.';

    var labelTooLong = 'Your entry is too long.';

    var labelTooShort = 'Your entry is too short.';

    var labelTypeMismatch = 'You have entered an invalid format.';

    var labelValueMissing = 'Complete this field.';

    const constraintsSortedByPriority = ['customError', 'badInput', 'patternMismatch', 'rangeOverflow', 'rangeUnderflow', 'stepMismatch', 'tooLong', 'tooShort', 'typeMismatch', 'valueMissing'];
    const defaultLabels = {
      badInput: labelBadInput,
      customError: labelBadInput,
      patternMismatch: labelPatternMismatch,
      rangeOverflow: labelRangeOverflow,
      rangeUnderflow: labelRangeUnderflow,
      stepMismatch: labelStepMismatch,
      tooLong: labelTooLong,
      tooShort: labelTooShort,
      typeMismatch: labelTypeMismatch,
      valueMissing: labelValueMissing
    };

    function resolveBestMatch(validity) {
      let validityState;

      if (validity && validity.valid === false) {
        validityState = 'badInput';
        constraintsSortedByPriority.some(stateName => {
          if (validity[stateName] === true) {
            validityState = stateName;
            return true;
          }

          return false;
        });
      }

      return validityState;
    }

    function computeConstraint(valueProvider, constraint) {
      const provider = valueProvider[constraint];

      if (typeof provider === 'function') {
        return provider();
      }

      if (typeof provider === 'boolean') {
        return provider;
      }

      return false;
    } // We're doing the below to avoid exposing the constraintsProvider in the ValidityState


    function newValidityState(constraintsProvider) {
      class ValidityState {
        get valueMissing() {
          return computeConstraint(constraintsProvider, 'valueMissing');
        }

        get typeMismatch() {
          return computeConstraint(constraintsProvider, 'typeMismatch');
        }

        get patternMismatch() {
          return computeConstraint(constraintsProvider, 'patternMismatch');
        }

        get tooLong() {
          return computeConstraint(constraintsProvider, 'tooLong');
        }

        get tooShort() {
          return computeConstraint(constraintsProvider, 'tooShort');
        }

        get rangeUnderflow() {
          return computeConstraint(constraintsProvider, 'rangeUnderflow');
        }

        get rangeOverflow() {
          return computeConstraint(constraintsProvider, 'rangeOverflow');
        }

        get stepMismatch() {
          return computeConstraint(constraintsProvider, 'stepMismatch');
        }

        get customError() {
          return computeConstraint(constraintsProvider, 'customError');
        }

        get badInput() {
          return computeConstraint(constraintsProvider, 'badInput');
        }

        get valid() {
          return !(this.valueMissing || this.typeMismatch || this.patternMismatch || this.tooLong || this.tooShort || this.rangeUnderflow || this.rangeOverflow || this.stepMismatch || this.customError || this.badInput);
        }

      }

      return new ValidityState();
    }

    function buildSyntheticValidity(constraintProvider) {
      return Object.freeze(newValidityState(constraintProvider));
    }
    function getErrorMessage(validity, labelMap) {
      const key = resolveBestMatch(validity);

      if (key) {
        return labelMap[key] ? labelMap[key] : defaultLabels[key];
      }

      return '';
    }
    class FieldConstraintApi {
      constructor(inputComponentProvider, constraintProviders) {
        assert(typeof inputComponentProvider === 'function');
        this._inputComponentProvider = inputComponentProvider;
        this._constraintsProvider = Object.assign({}, constraintProviders);

        if (!this._constraintsProvider.customError) {
          this._constraintsProvider.customError = () => typeof this._customValidityMessage === 'string' && this._customValidityMessage !== '';
        }
      }

      get validity() {
        if (!this._constraint) {
          this._constraint = buildSyntheticValidity(this._constraintsProvider);
        }

        return this._constraint;
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          if (this.inputComponent) {
            this.inputComponent.dispatchEvent(new CustomEvent('invalid', {
              cancellable: true
            }));
          }
        }

        return isValid;
      }

      reportValidity(callback) {
        const valid = this.checkValidity();
        this.inputComponent.classList.toggle('slds-has-error', !valid);

        if (callback) {
          callback(this.validationMessage);
        }

        return valid;
      }

      setCustomValidity(message) {
        this._customValidityMessage = message;
      }

      get validationMessage() {
        return getErrorMessage(this.validity, {
          customError: this._customValidityMessage,
          badInput: this.inputComponent.messageWhenBadInput,
          patternMismatch: this.inputComponent.messageWhenPatternMismatch,
          rangeOverflow: this.inputComponent.messageWhenRangeOverflow,
          rangeUnderflow: this.inputComponent.messageWhenRangeUnderflow,
          stepMismatch: this.inputComponent.messageWhenStepMismatch,
          tooShort: this.inputComponent.messageWhenTooShort,
          tooLong: this.inputComponent.messageWhenTooLong,
          typeMismatch: this.inputComponent.messageWhenTypeMismatch,
          valueMissing: this.inputComponent.messageWhenValueMissing
        });
      }

      get inputComponent() {
        if (!this._inputComponentElement) {
          this._inputComponentElement = this._inputComponentProvider();
        }

        return this._inputComponentElement;
      }

    }
    class FieldConstraintApiWithProxyInput {
      constructor(inputComponent, overrides = {}, inputElementName = 'input') {
        this._inputComponent = inputComponent;
        this._overrides = overrides;
        this._proxyInput = document.createElement(inputElementName);
      }

      setInputAttributes(attributes) {
        this._attributes = attributes;

        this._attributeUpdater = attributeNames => {
          if (!attributes) {
            return;
          }

          if (typeof attributeNames === 'string') {
            this._setAttribute(attributeNames, attributes[attributeNames]());
          } else {
            attributeNames.forEach(attributeName => {
              this._setAttribute(attributeName, attributes[attributeName]());
            });
          }
        };

        return this._attributeUpdater;
      }

      get validity() {
        return this._constraintApi.validity;
      }

      checkValidity() {
        return this._constraintApi.checkValidity();
      }

      reportValidity(callback) {
        return this._constraintApi.reportValidity(callback);
      }

      setCustomValidity(message) {
        this._constraintApi.setCustomValidity(message);

        this._proxyInput.setCustomValidity(message);
      }

      get validationMessage() {
        return this._constraintApi.validationMessage;
      }

      _setAttribute(attributeName, value) {
        if (value !== null && value !== undefined && value !== false) {
          if (attributeName === 'value') {
            if (this._proxyInput.type === 'file') {
              // Can't set value on file
              return;
            }

            this._proxyInput.value = value;
          } else {
            this._proxyInput.setAttribute(attributeName, value);
          }
        } else {
          this._removeAttribute(attributeName);
        }
      }

      _removeAttribute(attributeName) {
        this._proxyInput.removeAttribute(attributeName);
      }

      get _constraintApi() {
        if (!this._privateConstraintApi) {
          this._updateAllAttributes();

          const computeConstraintWithProxyInput = constraintName => {
            const constraintOverride = this._overrides[constraintName];

            if (typeof constraintOverride === 'function') {
              const result = constraintOverride();

              if (typeof result === 'boolean') {
                return !this._proxyInput.hasAttribute('disabled') && !this._proxyInput.hasAttribute('readonly') && result;
              }
            }

            return this._proxyInput.validity[constraintName];
          };

          const constraintsProvider = constraintsSortedByPriority.reduce((provider, constraint) => {
            provider[constraint] = computeConstraintWithProxyInput.bind(this, constraint);
            return provider;
          }, {});
          this._privateConstraintApi = new FieldConstraintApi(this._inputComponent, constraintsProvider);
        }

        return this._privateConstraintApi;
      }

      _updateAllAttributes() {
        if (this._attributes) {
          Object.entries(this._attributes).forEach(([key, valueFunction]) => {
            this._setAttribute(key, valueFunction());
          });
        }
      }

    }

    const VARIANT = {
      STANDARD: 'standard',
      LABEL_HIDDEN: 'label-hidden',
      LABEL_STACKED: 'label-stacked',
      LABEL_INLINE: 'label-inline'
    };
    /**
    A variant normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeVariant(value) {
      return normalizeString(value, {
        fallbackValue: VARIANT.STANDARD,
        validValues: [VARIANT.STANDARD, VARIANT.LABEL_HIDDEN, VARIANT.LABEL_STACKED, VARIANT.LABEL_INLINE]
      });
    }

    function isEmptyString(s) {
      return s === undefined || s === null || typeof s === 'string' && s.trim() === '';
    }

    function fullHexValue(hex) {
      if (hex && hex.length <= 6 && hex.charAt(0) !== '#') {
        hex = '#' + hex;
      }

      const isInputValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);

      if (!isInputValid) {
        hex = '#000000';
      } // Converting 3 digit hex color to 6 digit hex color


      if (hex.length === 4) {
        hex = '#' + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2) + hex.charAt(3) + hex.charAt(3);
      }

      return hex;
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHexValue(hex));

      if (!result) {
        return null;
      }

      return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16)
      };
    }
    function rgbToHex(rgb) {
      const r = rgb.red;
      const g = rgb.green;
      const b = rgb.blue;
      const bin = r << 16 | g << 8 | b;
      return function (hex) {
        return new Array(7 - hex.length).join('0') + hex;
      }(bin.toString(16).toUpperCase());
    }
    function rgbToHsl(rgb) {
      const r1 = rgb.red / 255;
      const g1 = rgb.green / 255;
      const b1 = rgb.blue / 255;
      const maxColor = Math.max(r1, g1, b1);
      const minColor = Math.min(r1, g1, b1); // Calculate L:

      let L = (maxColor + minColor) / 2;
      let S = 0;
      let H = 0;

      if (maxColor !== minColor) {
        // Calculate S:
        if (L < 0.5) {
          S = (maxColor - minColor) / (maxColor + minColor);
        } else {
          S = (maxColor - minColor) / (2.0 - maxColor - minColor);
        } // Calculate H:


        if (r1 === maxColor) {
          const x = g1 - b1,
                y = maxColor - minColor;
          H = x / y;
        } else if (g1 === maxColor) {
          const x = b1 - r1,
                y = maxColor - minColor,
                z = x / y;
          H = 2.0 + z;
        } else {
          const x = r1 - g1,
                y = maxColor - minColor,
                z = x / y;
          H = 4.0 + z;
        }
      }

      L *= 100;
      S *= 100;
      H *= 60;

      if (H < 0) {
        H += 360;
      }

      const result = {
        hue: H,
        saturation: S,
        lightness: L
      };
      return result;
    }
    function rgbToPosition(rgb, canvas) {
      const hsv = rgbToHsv(rgb);
      const saturation = hsv.saturation / 100,
            brightness = hsv.brightness / 100;
      const x = canvas.x * saturation;
      const y = canvas.y * (1 - brightness);
      return {
        x,
        y
      };
    }
    function rgbToHsv(rgb) {
      const r = rgb.red / 255;
      const g = rgb.green / 255;
      const b = rgb.blue / 255;
      const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
      const d = max - min,
            s = max === 0 ? 0 : d / max,
            v = max;
      let h, x, y;

      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            x = g - b;
            y = x / d;
            h = y + (g < b ? 6 : 0);
            break;

          case g:
            x = b - r;
            y = x / d;
            h = y + 2;
            break;

          case b:
            x = r - g;
            y = x / d;
            h = y + 4;
            break;

          default:
            break;
        }

        h /= 6;
      }

      const result = {
        hue: h * 360,
        saturation: s * 100,
        brightness: v * 100
      };
      return result;
    }

    const i18n$1 = {
      bInput: labelBInput,
      blueAbbr: labelBlueAbbr,
      colorPickerInstructions: labelColorPickerInstructions,
      errorMessage: labelErrorMessage,
      gInput: labelGInput,
      greenAbbr: labelGreenAbbr,
      hexLabel: labelHexLabel,
      hueInput: labelHueInput,
      rInput: labelRInput,
      redAbbr: labelRedAbbr
    };
    const CANVAS = {
      x: 198,
      y: 80
    };

    class LightningColorPickerCustom extends lwc.LightningElement {
      constructor() {
        super();
        this._hueValue = null;
        this._rgb = {
          red: '86',
          green: '121',
          blue: '192'
        };
        this._hex = '#5679C0';
        this._errorMessage = null;
        this._currentColor = null;
        this._initialized = false;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        if (!this._initialized) {
          this.focus();
          this.gradient();
          this.handleUpdateAnchor();
          this._initialized = true;
        }
      }

      get currentColor() {
        return this._currentColor;
      }

      set currentColor(value) {
        const fullHex = fullHexValue(value);
        this._currentColor = value;
        this._hex = fullHex;
        this._rgb = hexToRgb(fullHex);
      }

      focus() {
        this.anchorElement.focus();
      }

      get i18n() {
        return i18n$1;
      }

      get thumbnailStyle() {
        return `background: ${this._hex || 'hsl(220, 46%, 55%)'};`;
      }

      get gradientStyle() {
        return `background: ${this._hex || 'rgb(0, 85, 255)'}; position: relative;`;
      }

      get canvasRect() {
        return CANVAS;
      }

      get anchorElement() {
        return this.template.querySelector('*[data-id="color-anchor"]');
      }

      get thumbnailElement() {
        return this.template.querySelector('*[data-id="color-preview"]');
      }

      get gradientElement() {
        return this.template.querySelector('*[data-id="color-gradient"]');
      }

      get computedSaturationAndBrightness() {
        const rgb = this._rgb;
        const saturation = rgbToHsv(rgb).saturation || 0;
        const brightness = rgbToHsv(rgb).brightness || 0;
        return `Saturation: ${saturation.toFixed()}%. Brightness: ${brightness.toFixed()}%.`;
      }

      handlePreventDefault(event) {
        event.preventDefault();
      }

      selectColor(event) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: event.target.innerText
          }
        }));
      }

      handleMouseDown(event) {
        event.preventDefault();
        this.onMouseDrag(event, true);
      }

      handleDrag(event) {
        this.onMouseDrag(event, false);
      }

      onChange() {
        this.rainbowCursor();
      }

      parseAndLimit(value) {
        let out = value;

        if (!value || parseInt(value, 10) < 0 || isNaN(value)) {
          out = 0;
        } else if (parseInt(value, 10) > 255) {
          out = 255;
        }

        return out;
      }

      handleRgbChange(event) {
        const target = event.currentTarget;
        const value = this.parseAndLimit(target.value); // Fix for no rerender on second bad value attempt

        target.value = value;
        const color = target.getAttribute('data-color-name');

        if (color === 'red') {
          this._rgb.red = value;
        } else if (color === 'green') {
          this._rgb.green = value;
        } else if (color === 'blue') {
          this._rgb.blue = value;
        }

        const rgb = this._rgb;
        const hue = rgbToHsl(rgb).hue;
        const position = this.rgbToPosition(rgb);
        const selectedColor = `#${rgbToHex(rgb)}`;
        this.updateRainbow(hue);
        this.setCanvasColor(hue);
        this.setCanvasCursor(position.x, position.y);
        this.updateSelectedColor(selectedColor);
      }

      handleHexChange(event) {
        const isInputValid = event.srcElement.validity.valid;

        if (isInputValid) {
          const selectedColor = fullHexValue(event.target.value);
          this.classList.remove('slds-has-error');
          this._errorMessage = null;
          const rgb = hexToRgb(selectedColor);
          this._rgb = rgb;
          const hue = rgbToHsl(rgb).hue;
          const position = this.rgbToPosition(rgb);
          this.updateRainbow(hue);
          this.setCanvasColor(hue);
          this.setCanvasCursor(position.x, position.y);
          this.updateSelectedColor(selectedColor);
        } else {
          event.srcElement.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(event.srcElement.validity, {
            patternMismatch: this.i18n.errorMessage
          });
        }
      }

      updateSelectedColor(selectedColor) {
        this.template.querySelector(`[data-primary-input]`).classList.remove('slds-has-error');
        this._errorMessage = null;
        this._hex = selectedColor;
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updateselectedcolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: selectedColor
          }
        }));
      }

      onMouseDrag(event, isGradientCursor) {
        const that = this;
        let drag = false;

        if (isGradientCursor) {
          this.getColorFromGradient(event);
        } else {
          this.rainbowCursor();
        }

        if (this._mousedown && this._mousemove && this._mouseup) {
          return;
        }

        that._mousedown = function () {
          drag = true;
          this._cursorActive = true;
        };

        that._mouseup = function () {
          drag = false;
          this._cursorActive = false;
          window.removeEventListener('mousedown', that._mousedown);
          window.removeEventListener('mouseup', that._mouseup);
          window.removeEventListener('mousemove', that._mousemove);
          that._mousedown = null;
          that._mouseup = null;
          that._mousemove = null;
        };

        that._mousemove = function (evt) {
          if (drag && isGradientCursor) {
            that.getColorFromGradient(evt);
          } else if (drag) {
            that.rainbowCursor();
          }
        };

        window.addEventListener('mousedown', that._mousedown);
        window.addEventListener('mouseup', that._mouseup);
        window.addEventListener('mousemove', that._mousemove);
      }

      gradient() {
        const hue = rgbToHsl(this._rgb).hue;
        this.canvasContext();
        this.setCanvasColor(hue);
        this.updateRainbow(hue);
      }

      getColorFromGradient(event) {
        let cursorPosition;

        if (event.type === 'keydown' && event.key !== 'Tab') {
          cursorPosition = this.gradientCursorPositionFromKeydown(event);
        } else if (event.type === 'mousedown' || event.type === 'mousemove') {
          cursorPosition = this.gradientCursorPosition(event);
        } else {
          return;
        }

        const x = cursorPosition.x;
        const y = cursorPosition.y; // Get the current HUE value and update the canvas & cursor

        this.setCanvasColor(this._hueValue); // set color from gradient

        this.setRGBValues(x, y);
      }

      rainbowCursor() {
        const rainbow = this.template.querySelector('*[data-id="hue-slider"]');
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        this.setCanvasColor(rainbow.value);
        this.setRGBValues(position.x, position.y);
        this.updateRainbow(rainbow.value);
      }

      updateRainbow(hue) {
        this._hueValue = hue;
      }

      handleUpdateAnchor() {
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        const x = position.x - offset + 5;
        const y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      gradientCursorPosition(event) {
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        let x = event.clientX - gradientCanvas.left;
        let y = event.clientY - gradientCanvas.top;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      gradientCursorPositionFromKeydown(event) {
        event.preventDefault();
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        const keyCode = event.keyCode;
        let x, y;

        if (!this._cachePosition) {
          this._cachePosition = this.rgbToPosition(this._rgb);
        }

        const positionMap = {};
        positionMap[keyCodes.left] = {
          x: -1,
          y: 0
        };
        positionMap[keyCodes.up] = {
          x: 0,
          y: -1
        };
        positionMap[keyCodes.right] = {
          x: +1,
          y: 0
        };
        positionMap[keyCodes.down] = {
          x: 0,
          y: +1
        };
        const transform = positionMap[keyCode] ? positionMap[keyCode] : {
          x: 0,
          y: 0
        };
        x = this._cachePosition.x + transform.x;
        y = this._cachePosition.y + transform.y;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      setRGBValues(x, y) {
        const ctx = this._canvasCtx;
        const imageData = ctx.getImageData(x, y, 1, 1).data;
        const rgb = {
          red: imageData[0],
          green: imageData[1],
          blue: imageData[2]
        };
        const color = `#${rgbToHex(rgb)}`;
        this._rgb = rgb;
        this.updateSelectedColor(color);
        this.handleUpdateAnchor();
      }

      setCanvasColor(hue) {
        const ctx = this._canvasCtx; // don't map the gradient onto extreme left and right to make extremes have their max values

        const white = ctx.createLinearGradient(1, 0, this.canvasRect.x - 1, 0);
        white.addColorStop(0, 'rgb(255,255,255)');
        white.addColorStop(1, 'hsl(' + hue + ', 100%, 50%)');
        ctx.fillStyle = white;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y); // starting y is the first line to avoid blending the black into the hue, thus
        // making extreme values unselectable

        const black = ctx.createLinearGradient(0, 1, 0, this.canvasRect.y);
        black.addColorStop(0, 'rgba(0,0,0,0)');
        black.addColorStop(1, 'rgb(0,0,0)');
        ctx.fillStyle = black;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y);
      }

      setCanvasCursor(x, y) {
        const position = {
          x,
          y
        };
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        x = position.x - offset + 5;
        y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      canvasContext() {
        this._canvas = this.template.querySelector('canvas');
        this._canvasCtx = this._canvas.getContext('2d');
        this._cursorActive = false;
      }

      handleKeydown(event) {
        this.getColorFromGradient(event);
      }

      rgbToPosition(rgb) {
        return rgbToPosition(rgb, this.canvasRect);
      }

    }

    lwc.registerDecorators(LightningColorPickerCustom, {
      publicProps: {
        currentColor: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _hueValue: 1,
        _rgb: 1,
        _hex: 1,
        _errorMessage: 1,
        _currentColor: 1
      }
    });

    var _lightningColorPickerCustom = lwc.registerComponent(LightningColorPickerCustom, {
      tmpl: _tmpl$9
    });

    function tmpl$9($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        h: api_element,
        d: api_dynamic,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("section", {
        classMap: {
          "slds-popover": true,
          "slds-color-picker__selector": true,
          "slds-show": true,
          "slds-is-absolute": true
        },
        attrs: {
          "role": "dialog",
          "aria-label": "Choose a color",
          "aria-describedby": `${api_scoped_id("dialog-body-id")}`
        },
        key: 2,
        on: {
          "updateselectedcolor": _m2 || ($ctx._m2 = api_bind($cmp.handleUpdateSelectedColor)),
          "keydown": _m3 || ($ctx._m3 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        attrs: {
          "id": api_scoped_id("dialog-body-id")
        },
        key: 3
      }, [api_custom_element("lightning-color-picker-custom", _lightningColorPickerCustom, {
        props: {
          "currentColor": $cmp.currentColor
        },
        key: 4
      }, [])]), api_element("footer", {
        classMap: {
          "slds-popover__footer": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-color-picker__selector-footer": true
        },
        key: 6
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_neutral": true
        },
        attrs: {
          "name": "cancel"
        },
        key: 7,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCancelClick))
        }
      }, [api_dynamic($cmp.i18n.cancelButton)]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true
        },
        attrs: {
          "name": "done"
        },
        key: 8,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleDoneClick))
        }
      }, [api_dynamic($cmp.i18n.doneButton)])])])])];
    }

    var _tmpl$a = lwc.registerTemplate(tmpl$9);
    tmpl$9.stylesheets = [];
    tmpl$9.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerPanel_colorPickerPanel-host",
      shadowAttribute: "lightning-colorPickerPanel_colorPickerPanel"
    };

    var labelCancelButton = 'Cancel';

    var labelCustomTab = 'Custom';

    var labelDefaultTab = 'Default';

    var labelDoneButton = 'Done';

    const i18n$2 = {
      cancelButton: labelCancelButton,
      customTab: labelCustomTab,
      defaultTab: labelDefaultTab,
      doneButton: labelDoneButton
    };
    const DEFAULT_COLOR = '#000000';

    class LightningColorPickerPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.currentColor = void 0;
        this._isCustomTabActive = false;
        this._selectedColor = null;
      }

      connectedCallback() {
        this._selectedColor = this.currentColor || DEFAULT_COLOR;
      }

      get i18n() {
        return i18n$2;
      }

      get computedClassDefault() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': !this._isCustomTabActive
        }).toString();
      }

      get computedClassCustom() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': this._isCustomTabActive
        }).toString();
      }

      get ariaSelectedDefault() {
        return !this._isCustomTabActive.toString();
      }

      get ariaSelectedCustom() {
        return this._isCustomTabActive.toString();
      }

      handleTabChange(event) {
        event.preventDefault();
        const tabElement = event.currentTarget;

        if (tabElement.classList.contains('slds-is-active')) {
          return;
        }

        this._isCustomTabActive = tabElement.title !== i18n$2.defaultTab;
      }

      handleUpdateSelectedColor(event) {
        this._selectedColor = event.detail.color;
      }

      dispatchUpdateColorEventWithColor(color) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          composed: true,
          bubbles: true,
          detail: {
            color
          }
        }));
      }

      handleDoneClick() {
        this.dispatchUpdateColorEventWithColor(this._selectedColor);
      }

      handleCancelClick() {
        this.dispatchUpdateColorEventWithColor(this.currentColor);
      }

      handleKeydown(event) {
        if (event.keyCode === keyCodes.escape) {
          event.preventDefault();
          this.dispatchUpdateColorEventWithColor(this.currentColor);
        } else if (event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.dataset.id === 'color-anchor') {
          event.preventDefault();
          this.template.querySelector('button[name="done"]').focus();
        } else if (!event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.name === 'done') {
          event.preventDefault();
          this.template.querySelector('lightning-color-picker-custom').focus();
        }
      }

    }

    lwc.registerDecorators(LightningColorPickerPanel, {
      publicProps: {
        currentColor: {
          config: 0
        }
      },
      track: {
        _isCustomTabActive: 1,
        _selectedColor: 1
      }
    });

    var _lightningColorPickerPanel = lwc.registerComponent(LightningColorPickerPanel, {
      tmpl: _tmpl$a
    });

    function tmpl$a($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-color-picker__summary-button": true,
          "slds-button_icon": true,
          "slds-button_icon-more": true
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleColorPickerToggleClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.colorInputStyle,
        attrs: {
          "data-id": "thumbnail"
        },
        key: 3
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 4
      }, [api_dynamic($cmp.i18n.a11yTriggerText)])]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:down",
          "svgClass": "slds-button__icon slds-button__icon_small",
          "variant": "bare"
        },
        key: 5
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true,
          "a11y-color-value": true
        },
        key: 6
      }, [api_dynamic($cmp.value)])]), $cmp._isColorPickerPanelOpen ? api_custom_element("lightning-color-picker-panel", _lightningColorPickerPanel, {
        classMap: {
          "color-picker-panel": true
        },
        props: {
          "currentColor": $cmp.value
        },
        key: 8,
        on: {
          "updatecolor": _m1 || ($ctx._m1 = api_bind($cmp.handleUpdateColorEvent))
        }
      }, []) : null];
    }

    var _tmpl$b = lwc.registerTemplate(tmpl$a);
    tmpl$a.stylesheets = [];
    tmpl$a.stylesheetTokens = {
      hostAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton-host",
      shadowAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton"
    };

    var labelA11yTriggerText = 'Choose a color. Current color: ';

    const i18n$3 = {
      a11yTriggerText: labelA11yTriggerText
    };

    class PrimitiveColorpickerButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._isColorPickerPanelOpen = false;
        this._value = '';
        this._disabled = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      focus() {
        const button = this.template.querySelector('button');
        return button && button.focus();
      }

      blur() {
        const button = this.template.querySelector('button');
        return button && button.blur();
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault();
        this._isColorPickerPanelOpen = !this._isColorPickerPanelOpen;

        if (this._isColorPickerPanelOpen) {
          this.startColorPickerPositioning();
        } else {
          this.stopColorPickerPositioning();
        }
      }

      startColorPickerPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('button.slds-color-picker__summary-button'),
          element: () => this.template.querySelector('lightning-color-picker-panel').shadowRoot.querySelector('section'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true
        });
      }

      stopColorPickerPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      handleUpdateColorEvent(event) {
        event.stopPropagation();
        const detail = event.detail;
        this._isColorPickerPanelOpen = false;
        this.stopColorPickerPositioning();
        this.dispatchEvent(new CustomEvent('change', {
          detail
        }));
      }

      get i18n() {
        return i18n$3;
      }

    }

    PrimitiveColorpickerButton.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveColorpickerButton, {
      publicProps: {
        value: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur"],
      track: {
        _isColorPickerPanelOpen: 1,
        _value: 1,
        _disabled: 1
      }
    });

    var _lightningPrimitiveColorpickerButton = lwc.registerComponent(PrimitiveColorpickerButton, {
      tmpl: _tmpl$b
    });

    function tmpl$b($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        gid: api_scoped_id,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "title": $cmp.computedTitle,
          "accesskey": $cmp.computedAccessKey,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-describedby": api_scoped_id($cmp.computedAriaDescribedBy),
          "aria-label": $cmp.computedAriaLabel,
          "aria-controls": api_scoped_id($cmp.computedAriaControls),
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 3
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 5
      }, [api_dynamic($cmp.alternativeText)]) : null])];
    }

    var _tmpl$c = lwc.registerTemplate(tmpl$b);
    tmpl$b.stylesheets = [];
    tmpl$b.stylesheetTokens = {
      hostAttribute: "lightning-buttonIcon_buttonIcon-host",
      shadowAttribute: "lightning-buttonIcon_buttonIcon"
    };

    function tmpl$c($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$d = lwc.registerTemplate(tmpl$c);
    tmpl$c.stylesheets = [];
    tmpl$c.stylesheetTokens = {
      hostAttribute: "lightning-primitiveButton_primitiveButton-host",
      shadowAttribute: "lightning-primitiveButton_primitiveButton"
    };

    class LightningPrimitiveButton extends lwc.LightningElement {
      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        this.state.disabled = normalizeBoolean(value);
      }

      set accessKey(value) {
        this.state.accesskey = value;
      }

      get accessKey() {
        return this.state.accesskey;
      }

      get computedAccessKey() {
        return this.state.accesskey;
      }

      get title() {
        return this.state.title;
      }

      set title(value) {
        this.state.title = value;
      }

      get ariaLabel() {
        return this.state.ariaLabel;
      }

      set ariaLabel(value) {
        this.state.ariaLabel = value;
      }

      get computedAriaLabel() {
        return this.state.ariaLabel;
      }

      get ariaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      set ariaDescribedBy(value) {
        this.state.ariaDescribedBy = value;
      }

      get computedAriaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      get ariaControls() {
        return this.state.ariaControls;
      }

      set ariaControls(value) {
        this.state.ariaControls = value;
      }

      get computedAriaControls() {
        return this.state.ariaControls;
      }

      get ariaExpanded() {
        return this.state.ariaExpanded;
      }

      set ariaExpanded(value) {
        this.state.ariaExpanded = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaExpanded() {
        return this.state.ariaExpanded || null;
      }

      set ariaLive(value) {
        this.state.ariaLive = value;
      }

      get ariaLive() {
        return this.state.ariaLive;
      }

      get computedAriaLive() {
        return this.state.ariaLive;
      }

      get ariaAtomic() {
        return this.state.ariaAtomic || null;
      }

      set ariaAtomic(value) {
        this.state.ariaAtomic = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaAtomic() {
        return this.state.ariaAtomic || null;
      }

      focus() {}

      constructor() {
        super(); // Workaround for an IE11 bug where click handlers on button ancestors
        // receive the click event even if the button element has the `disabled`
        // attribute set.

        this.state = {
          accesskey: null,
          ariaAtomic: null,
          ariaControls: null,
          ariaDescribedBy: null,
          ariaExpanded: null,
          ariaLabel: null,
          ariaLive: null,
          disabled: false
        };

        if (isIE11) {
          this.template.addEventListener('click', event => {
            if (this.disabled) {
              event.stopImmediatePropagation();
            }
          });
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveButton, {
      publicProps: {
        disabled: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        title: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaExpanded: {
          config: 3
        },
        ariaLive: {
          config: 3
        },
        ariaAtomic: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var LightningPrimitiveButton$1 = lwc.registerComponent(LightningPrimitiveButton, {
      tmpl: _tmpl$d
    });

    const DEFAULT_SIZE = 'medium';
    const DEFAULT_VARIANT = 'border';
    const DEFAULT_TYPE = 'button';
    /**
     * An icon-only HTML button.
     */

    class LightningButtonIcon extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.variant = DEFAULT_VARIANT;
        this.iconName = void 0;
        this.iconClass = void 0;
        this.size = DEFAULT_SIZE;
        this.type = DEFAULT_TYPE;
        this.alternativeText = void 0;
        this._order = null;
        this._tooltip = null;
      }

      /**
       * Text to display when the user mouses over or focuses on the button.
       * The tooltip is auto-positioned relative to the button and screen space.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set tooltip(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button')
          });

          this._tooltip.initialize();
        }
      }

      get tooltip() {
        return this._tooltip ? this._tooltip.value : undefined;
      }

      // this is there because raptor currently doesnt support inheritance
      render() {
        return _tmpl$c;
      }

      get computedTitle() {
        return this.state.title || this.alternativeText || '';
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: DEFAULT_VARIANT,
          validValues: ['bare', 'brand', 'container', 'border', 'border-filled', 'bare-inverse', 'border-inverse']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: DEFAULT_TYPE,
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: DEFAULT_SIZE,
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      getVariantBase() {
        return this.normalizedVariant.split('-')[0];
      }

      getVariantModifier() {
        return this.normalizedVariant.split('-')[1] || '';
      }

      get computedButtonClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedSize) === 'bare';
        const classes = classSet('slds-button');

        if (!isBare) {
          // If the variant is not bare, then size the button instead of the icon
          switch (normalizedSize) {
            case 'small':
              classes.add('slds-button_icon-small');
              break;

            case 'x-small':
              classes.add('slds-button_icon-x-small');
              break;

            case 'xx-small':
              classes.add('slds-button_icon-xx-small');
              break;

            case 'large':
              // There is no `large` modifier for buttons so we should drop down one size to `medium`
              // eslint-disable-next-line no-console
              console.warn(`<lightning-button-icon> The non-bare variants of buttonIcon do not support a size value of "large". Supported values include "xx-small", "x-small", "small", and "medium". Falling back to size value "medium".`);

            /* falls through */

            case 'medium': // Medium is the default size, and the default size doesn't require a size modifier

            default:
          }
        }

        return classes.add({
          'slds-button_icon-bare': isBare,
          'slds-button_icon-container': normalizedVariant === 'container',
          'slds-button_icon-border': normalizedVariant === 'border',
          'slds-button_icon-border-filled': normalizedVariant === 'border-filled',
          'slds-button_icon-border-inverse': normalizedVariant === 'border-inverse',
          'slds-button_icon-inverse': normalizedVariant === 'bare-inverse',
          'slds-button_icon-brand': normalizedVariant === 'brand',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedIconClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedVariant) === 'bare';
        const iconClass = this.iconClass || '';
        const classes = classSet('slds-button__icon');
        classes.add(iconClass);

        if (isBare) {
          // If the variant is bare, then size the icon instead of the button
          switch (normalizedSize) {
            case 'large':
              classes.add('slds-button__icon_large');
              break;

            case 'small':
              classes.add('slds-button__icon_small');
              break;

            case 'xx-small':
              // There is no `xx-small` modifier for bare so we should drop down one size to `x-small`
              // eslint-disable-next-line no-console
              console.warn(`<lightning-button-icon> The bare variant of buttonIcon does not support a size value of "xx-small". Supported values include "x-small", "small", "medium", and "large". The default is "medium".`);

            /* falls through */

            case 'x-small':
              classes.add('slds-button__icon_x-small');
              break;

            case 'medium': // Medium is the default size, and the default size doesn't require a size modifier

            default:
          }
        }

        if (this.getVariantModifier(normalizedVariant) === 'inverse') {
          classes.add('slds-button_icon-inverse');
        }

        return classes.toString();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        this.template.querySelector('button').focus();
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      disconnectedCallback() {
        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButtonIcon.delegatesFocus = true;

    lwc.registerDecorators(LightningButtonIcon, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconClass: {
          config: 0
        },
        size: {
          config: 0
        },
        type: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        tooltip: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _order: 1
      }
    });

    var _lightningButtonIcon = lwc.registerComponent(LightningButtonIcon, {
      tmpl: _tmpl$c
    });

    function stylesheet$7(hostSelector, shadowSelector, nativeShadow) {
      return "[dir=\"rtl\"] .slds-dropdown_left" + shadowSelector + " {left: 0;right: auto;}\n";
    }
    var _implicitStylesheets$7 = [stylesheet$7];

    function tmpl$d($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("select")}`
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-select_container": true
        },
        key: 7
      }, [api_element("select", {
        classMap: {
          "slds-select": true
        },
        attrs: {
          "id": api_scoped_id("select"),
          "name": $cmp.name,
          "size": $cmp.size,
          "accesskey": $cmp.accessKey,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        props: {
          "disabled": $cmp.disabled,
          "multiple": $cmp.multiple
        },
        key: 8,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, api_iterator($cmp.options, function (option) {
        return api_element("option", {
          attrs: {
            "value": option.value
          },
          key: api_key(10, option.value)
        }, [api_dynamic(option.label)]);
      }))])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 12
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$e = lwc.registerTemplate(tmpl$d);
    tmpl$d.stylesheets = [];
    tmpl$d.stylesheetTokens = {
      hostAttribute: "lightning-primitiveSelect_primitiveSelect-host",
      shadowAttribute: "lightning-primitiveSelect_primitiveSelect"
    };

    var labelRequired = 'required';

    const i18n$4 = {
      required: labelRequired
    };
    const {
      reduce: ArrayReduce
    } = Array.prototype;

    class LightningPrimitiveSelect extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._errorMessage = '';
        this._options = [];
        this._selectedValue = void 0;
        this._variant = void 0;
        this._required = false;
        this._disabled = false;
        this._multiple = false;
        this._fieldLevelHelp = void 0;
        this._size = void 0;
        this._ariaDescribedBy = void 0;
        this._tabIndex = void 0;
        this.label = void 0;
        this.name = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple;
      }

      set size(newValue) {
        this._size = newValue;
      }

      get size() {
        if (!this.multiple) {
          return null;
        }

        if (this._size === undefined) {
          return '4';
        }

        return this._size;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      set value(newValue) {
        this._selectedValue = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(newValue);
        }
      }

      get value() {
        return this._selectedValue;
      }

      set options(newValue) {
        this._options = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      get options() {
        return this._options;
      }

      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(newValue) {
        this._tabIndex = newValue;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
        this.connected = true;
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        if (this.options && this._selectedValue !== undefined) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        if (this.connected) {
          this.getElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.getElement.blur();
        }
      }

      get validity() {
        const missing = !this.disabled && this.required && (this._selectedValue == null || this._selectedValue === '' || this._selectedValue.length === 0);
        return buildSyntheticValidity({
          valueMissing: missing,
          customError: this.customErrorMessage != null && this.customErrorMessage !== ''
        });
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          this.dispatchEvent(new CustomEvent('invalid', {
            cancellable: true
          }));
        }

        return isValid;
      }

      reportValidity() {
        this.showHelpMessageIfInvalid();
        return this.checkValidity();
      }

      setCustomValidity(message) {
        this.customErrorMessage = message;
      }

      showHelpMessageIfInvalid() {
        const validity = this.validity;

        if (validity.valid) {
          this._errorMessage = '';
          this.classList.remove('slds-has-error');
          this.removeAriaDescribedBy();
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(validity, {
            valueMissing: this.messageWhenValueMissing,
            customError: this.customErrorMessage
          });
          this.setAriaDescribedBy(this.computedUniqueErrorMessageElementId);
        }
      }

      get i18n() {
        return i18n$4;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get getElement() {
        return this.template.querySelector('select');
      }

      get computedUniqueErrorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        return this._ariaDescribedBy;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._selectedValue = this.getSelectedOptionValues();
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._selectedValue
          }
        }));
      }

      selectOptionsByValue(optionValue) {
        if (this.multiple) {
          if (Array.isArray(optionValue)) {
            const options = this.template.querySelectorAll('option');
            options.forEach(option => {
              option.selected = optionValue.includes(option.value);
            });
          }
        } else {
          this.getElement.value = optionValue;
        }
      }

      getSelectedOptionValues() {
        if (this.multiple) {
          const options = this.template.querySelectorAll('option');
          return ArrayReduce.call(options, (selectedValues, option) => {
            if (option.selected) {
              selectedValues.push(option.value);
            }

            return selectedValues;
          }, []);
        }

        return this.getElement.value;
      }

      setAriaDescribedBy(val) {
        this.getElement.setAttribute('aria-describedby', val);
      }

      removeAriaDescribedBy() {
        this.getElement.removeAttribute('aria-describedby');
      }

    }

    lwc.registerDecorators(LightningPrimitiveSelect, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        multiple: {
          config: 3
        },
        size: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        tabIndex: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _errorMessage: 1,
        _options: 1,
        _selectedValue: 1,
        _variant: 1,
        _required: 1,
        _disabled: 1,
        _multiple: 1,
        _fieldLevelHelp: 1,
        _size: 1,
        _ariaDescribedBy: 1,
        _tabIndex: 1
      }
    });

    var _lightningPrimitiveSelect = lwc.registerComponent(LightningPrimitiveSelect, {
      tmpl: _tmpl$e
    });

    function tmpl$e($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-datepicker": true,
          "slds-dropdown": true,
          "slds-dropdown_left": true
        },
        attrs: {
          "aria-hidden": "false",
          "aria-label": $cmp.computedAriaLabel,
          "role": "dialog"
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter": true,
          "slds-grid": true
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter_month": true,
          "slds-grid": true,
          "slds-grid_align-spread": true,
          "slds-grow": true
        },
        key: 4
      }, [api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 5
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "alternativeText": $cmp.i18n.previousMonth
        },
        key: 6,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.goToPreviousMonth)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handlePrevNavKeyDown))
        }
      }, [])]), api_element("h2", {
        classMap: {
          "slds-align-middle": true
        },
        attrs: {
          "aria-atomic": "true",
          "aria-live": "assertive",
          "id": api_scoped_id("month-title")
        },
        key: 7
      }, [api_dynamic($cmp.computedMonthTitle)]), api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 8
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "alternativeText": $cmp.i18n.nextMonth
        },
        key: 9,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.goToNextMonth))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-shrink-none": true
        },
        key: 10
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.calendarYear,
          "label": $cmp.i18n.yearSelector,
          "variant": "label-hidden",
          "options": $cmp.computedYearList
        },
        key: 11,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleYearChange)),
          "click": _m4 || ($ctx._m4 = api_bind($cmp.handleYearSelectClick))
        }
      }, [])])]), api_element("table", {
        classMap: {
          "slds-datepicker__month": true
        },
        attrs: {
          "aria-labelledby": `${api_scoped_id("month-title")}`,
          "role": "grid"
        },
        key: 12
      }, [api_element("thead", {
        key: 13
      }, [api_element("tr", {
        attrs: {
          "id": api_scoped_id("weekdays-element")
        },
        key: 14
      }, api_iterator($cmp.computedWeekdayLabels, function (weekday) {
        return api_element("th", {
          attrs: {
            "id": api_scoped_id(weekday.fullName),
            "scope": "col"
          },
          key: api_key(16, weekday.fullName)
        }, [api_element("abbr", {
          attrs: {
            "title": weekday.fullName
          },
          key: 17
        }, [api_dynamic(weekday.shortName)])]);
      }))]), api_element("tbody", {
        key: 18,
        on: {
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.handleCalendarKeyDown))
        }
      }, api_iterator($cmp.computedMonth, function (week, index) {
        return api_element("tr", {
          key: api_key(20, week.id)
        }, api_iterator(week.days, function (day) {
          return api_element("td", {
            className: day.className,
            attrs: {
              "role": "gridcell",
              "aria-selected": day.isSelected,
              "aria-disabled": day.isDisabled,
              "aria-current": day.ariaCurrent,
              "tabindex": api_tab_index(day.tabIndex),
              "data-value": day.dateValue
            },
            key: api_key(22, day.dateValue)
          }, [api_element("span", {
            classMap: {
              "slds-day": true
            },
            key: 23,
            on: {
              "click": _m5 || ($ctx._m5 = api_bind($cmp.handleDateClick))
            }
          }, [api_dynamic(day.date)])]);
        }));
      }))]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-align_absolute-center": true,
          "slds-text-link": true
        },
        attrs: {
          "name": "today",
          "type": "button"
        },
        key: 24,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.handleTodayClick)),
          "keydown": _m8 || ($ctx._m8 = api_bind($cmp.handleTodayKeyDown))
        }
      }, [api_dynamic($cmp.i18n.today)])])];
    }

    var _tmpl$f = lwc.registerTemplate(tmpl$e);
    tmpl$e.stylesheets = [];

    if (_implicitStylesheets$7) {
      tmpl$e.stylesheets.push.apply(tmpl$e.stylesheets, _implicitStylesheets$7);
    }
    tmpl$e.stylesheetTokens = {
      hostAttribute: "lightning-calendar_calendar-host",
      shadowAttribute: "lightning-calendar_calendar"
    };

    var labelAriaLabelMonth = 'Date picker: ';

    var labelNextMonth = 'Next Month';

    var labelPreviousMonth = 'Previous Month';

    var labelToday = 'Today';

    var labelYearSelector = 'Pick a Year';

    function handleKeyDownOnCalendar(event, date, calendarInterface) {
      const tdElement = event.target;

      switch (event.keyCode) {
        case keyCodes.up:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 7);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.down:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 7);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.right:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 1);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.left:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 1);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.enter:
        case keyCodes.space:
          preventDefaultAndStopPropagation(event);
          calendarInterface.selectDate(tdElement);
          break;

        case keyCodes.pageup:
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() - 1);
          } else {
            date.setMonth(date.getMonth() - 1);
          }

          calendarInterface.focusDate(date);
          break;

        case keyCodes.pagedown:
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() + 1);
          } else {
            date.setMonth(date.getMonth() + 1);
          }

          calendarInterface.focusDate(date);
          break;

        case keyCodes.home:
          // eslint-disable-line no-case-declarations
          preventDefaultAndStopPropagation(event);
          const startOfWeek = calendarInterface.getStartOfWeek(date);
          calendarInterface.focusDate(startOfWeek);
          break;

        case keyCodes.end:
          // eslint-disable-line no-case-declarations
          preventDefaultAndStopPropagation(event);
          const endOfWeek = calendarInterface.getStartOfWeek(date);
          endOfWeek.setDate(endOfWeek.getDate() + 6);
          calendarInterface.focusDate(endOfWeek);
          break;

        default:
      }
    }
    function handleKeyDownOnToday(event, calendarInterface) {
      switch (event.keyCode) {
        case keyCodes.tab:
          if (!event.shiftKey) {
            preventDefaultAndStopPropagation(event);
            calendarInterface.focusFirstFocusableElement();
          }

          break;

        default:
      }
    }
    function handleKeyDownOnPreviousMonthNav(event, calendarInterface) {
      switch (event.keyCode) {
        case keyCodes.tab:
          if (event.shiftKey) {
            preventDefaultAndStopPropagation(event);
            calendarInterface.focusLastFocusableElement();
          }

          break;

        default:
      }
    }

    function preventDefaultAndStopPropagation(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/address.js
    // For new versions, copy AddressFormat.js from node_modules/address.js/dist/AddressFormat.js
    // And add "export { address };" at the end.

    /* eslint-disable */
    var data = {
      AE: {
        fmt: '%A%n%S%n%K',
        require: 'AS',
        input: 'ASK'
      },
      AL: {
        fmt: '%A%n%Z%n%C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      EC: {
        _ref: 'AL'
      },
      MU: {
        _ref: 'AL'
      },
      OM: {
        _ref: 'AL'
      },
      AM: {
        fmt: '%A%n%Z%n%C%n%S%n%K',
        require: 'AZCS',
        input: 'AZK'
      },
      AR: {
        fmt: '%A%n%Z %C%n%S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      CL: {
        _ref: 'AR'
      },
      CV: {
        _ref: 'AR'
      },
      MY: {
        _ref: 'AR'
      },
      UZ: {
        _ref: 'AR'
      },
      AT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      BA: {
        _ref: 'AT'
      },
      BG: {
        _ref: 'AT'
      },
      CH: {
        _ref: 'AT'
      },
      DE: {
        _ref: 'AT'
      },
      DK: {
        _ref: 'AT'
      },
      DO: {
        _ref: 'AT'
      },
      DZ: {
        _ref: 'AT'
      },
      EE: {
        _ref: 'AT'
      },
      ET: {
        _ref: 'AT'
      },
      FR: {
        _ref: 'AT'
      },
      GE: {
        _ref: 'AT'
      },
      GR: {
        _ref: 'AT'
      },
      IL: {
        _ref: 'AT'
      },
      KW: {
        _ref: 'AT'
      },
      LA: {
        _ref: 'AT'
      },
      LR: {
        _ref: 'AT'
      },
      IS: {
        _ref: 'AT'
      },
      MA: {
        _ref: 'AT'
      },
      MG: {
        _ref: 'AT'
      },
      MK: {
        _ref: 'AT'
      },
      MZ: {
        _ref: 'AT'
      },
      NL: {
        _ref: 'AT'
      },
      NO: {
        _ref: 'AT'
      },
      PL: {
        _ref: 'AT'
      },
      PT: {
        _ref: 'AT'
      },
      PY: {
        _ref: 'AT'
      },
      RO: {
        _ref: 'AT'
      },
      RS: {
        _ref: 'AT'
      },
      SK: {
        _ref: 'AT'
      },
      TJ: {
        _ref: 'AT'
      },
      TN: {
        _ref: 'AT'
      },
      TZ: {
        _ref: 'AT'
      },
      WF: {
        _ref: 'AT'
      },
      AU: {
        fmt: '%A%n%C %S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CA: {
        _ref: 'AU'
      },
      AZ: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      AF: {
        fmt: '%A%n%C%n%Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      FK: {
        _ref: 'AF'
      },
      GB: {
        fmt: '%A%n%C%n%Z%n%S%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      KE: {
        _ref: 'AF'
      },
      LK: {
        _ref: 'AF'
      },
      ZA: {
        _ref: 'AF'
      },
      SH: {
        _ref: 'AF'
      },
      SZ: {
        _ref: 'AF'
      },
      US: {
        fmt: '%A%n%C, %S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      BB: {
        _ref: 'US'
      },
      BS: {
        _ref: 'US'
      },
      SO: {
        _ref: 'US'
      },
      ES: {
        fmt: '%A%n%Z %C %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      IT: {
        _ref: 'ES'
      },
      UY: {
        _ref: 'ES'
      },
      ID: {
        fmt: '%A%n%C%n%S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      IE: {
        _ref: 'ID'
      },
      TH: {
        _ref: 'ID'
      },
      VN: {
        _ref: 'ID'
      },
      HU: {
        fmt: '%C%n%A%n%Z%n%K',
        require: 'CAZ',
        input: 'CAZK'
      },
      BH: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      BM: {
        _ref: 'BH'
      },
      BN: {
        _ref: 'BH'
      },
      BT: {
        _ref: 'BH'
      },
      KH: {
        _ref: 'BH'
      },
      LB: {
        _ref: 'BH'
      },
      JO: {
        _ref: 'BH'
      },
      MT: {
        _ref: 'BH'
      },
      NP: {
        _ref: 'BH'
      },
      NZ: {
        _ref: 'BH'
      },
      SA: {
        _ref: 'BH'
      },
      BD: {
        fmt: '%A%n%C - %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      BR: {
        fmt: '%A%n%C-%S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CN: {
        fmt: '%K%n%S %C%n%A%n%Z',
        require: 'CAZ',
        input: 'KSCAZ'
      },
      HK: {
        fmt: '%K%C%n%A%n',
        require: 'CA',
        input: 'KCA'
      },
      CO: {
        fmt: '%A%n%C, %S, %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CR: {
        fmt: '%A%n%S, %C%n%Z%n%K',
        require: 'ACSZ',
        input: 'ASCZK'
      },
      EG: {
        fmt: '%A%n%C%n%S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      RU: {
        _ref: 'EG'
      },
      UA: {
        _ref: 'EG'
      },
      FI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      GT: {
        fmt: '%A%n%Z-%C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      HN: {
        fmt: '%A%n%C, %S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      IQ: {
        _ref: 'HN'
      },
      HR: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      HT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      IN: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      NG: {
        _ref: 'IN'
      },
      PE: {
        _ref: 'IN'
      },
      IR: {
        fmt: '%S%n%C%n%A%n%Z%n%K',
        require: 'SCAZ',
        input: 'SCAZK'
      },
      JM: {
        fmt: '%A%n%C%n%S%n%K',
        require: 'ACS',
        input: 'ACSK'
      },
      PA: {
        _ref: 'JM'
      },
      SC: {
        _ref: 'JM'
      },
      SR: {
        _ref: 'JM'
      },
      JP: {
        fmt: '%K%n' + String.fromCharCode(12306) + '%Z%n%S %C%n%A',
        require: 'ZCA',
        input: 'KZSCA'
      },
      EN_JP: {
        fmt: '%A%n%C %S%n%Z %K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      KG: {
        fmt: '%Z %C%n%A%n%S%n%K',
        require: 'ZCA',
        input: 'ZCAK'
      },
      KR: {
        fmt: '%S %C%n%A%n%Z%n%K',
        require: 'SCAZ',
        input: 'SCAZK'
      },
      KY: {
        fmt: '%A%n%S %Z%n%K',
        require: 'ASZ',
        input: 'ASZK'
      },
      KZ: {
        fmt: '%Z%n%S%n%C%n%A%n%K',
        require: 'ZSCA',
        input: 'ZSCAK'
      },
      LT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      LV: {
        fmt: '%A%n%C, %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      MM: {
        _ref: 'LV'
      },
      MC: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      MD: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      MW: {
        fmt: '%A%n%C%n%K',
        require: 'AC',
        input: 'ACK'
      },
      MX: {
        fmt: '%A%n%Z %C, %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      NI: {
        fmt: '%A%n%Z%n%C, %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      PG: {
        fmt: '%A%n%C %Z %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      PH: {
        fmt: '%A, %C%n%Z %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      PK: {
        fmt: '%A%n%C-%Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      PR: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      SE: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      SG: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'AZ',
        input: 'AZK'
      },
      SI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      SV: {
        fmt: '%A%n%Z-%C%n%S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      TR: {
        fmt: '%A%n%Z %C/%S%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      TW: {
        fmt: '%K%n%Z%n%S %C%n%A',
        require: 'ZSCA',
        input: 'KZSCA'
      },
      VE: {
        fmt: '%A%n%C %Z, %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      }
    };
    var languageCodeToCountry = {
      languageCode: {
        ar: 'AE',
        bg: 'BG',
        bn: 'BN',
        bs: 'BA',
        ca: 'ES',
        cs: 'CZ',
        cy: 'GB',
        da: 'DK',
        de: 'DE',
        el: 'GR',
        es: 'ES',
        et: 'ET',
        eu: 'ES',
        fi: 'FI',
        fr: 'FR',
        ga: 'IE',
        hi: 'HI',
        hr: 'HR',
        hu: 'HU',
        hy: 'HY',
        in: 'ID',
        is: 'IS',
        it: 'IT',
        iw: 'IL',
        ja: 'JP',
        ka: 'GE',
        ko: 'KR',
        lb: 'LU',
        lt: 'IT',
        lv: 'LV',
        mk: 'MK',
        ms: 'MY',
        mt: 'MT',
        nl: 'NL',
        no: 'NO',
        pl: 'PL',
        pt: 'PT',
        rm: 'DE',
        ro: 'RO',
        ru: 'RU',
        sh: 'BA',
        sk: 'SK',
        sl: 'SL',
        sq: 'SQ',
        sr: 'RS',
        sv: 'SE',
        ta: 'TA',
        th: 'TH',
        tl: 'PH',
        tr: 'TR',
        uk: 'UK',
        ur: 'UR',
        vi: 'VN',
        zh: 'CN'
      }
    };
    /**
     * Define address format patterns.
     */

    var AddressFormatPattern = Object.freeze({
      /**
       *
       * N: Name (The formatting of names for this field is outside of the scope of the address elements.)
       * O: Organization
       * A: Address Lines (2 or 3 lines address)
       * D: District (Sub-locality): smaller than a city, and could be a neighborhood, suburb or dependent locality.
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * X: Sorting code, for example, CEDEX as used in France
       * n: newline
       */
      A: Symbol('Address Lines'),
      C: Symbol('City'),
      S: Symbol('State'),
      K: Symbol('Country'),
      Z: Symbol('Zip Code'),
      n: Symbol('New Line'),
      fromPlaceHolder: function fromPlaceHolder(placeHolder) {
        switch (placeHolder) {
          case 'A':
            return AddressFormatPattern.A;

          case 'C':
            return AddressFormatPattern.C;

          case 'S':
            return AddressFormatPattern.S;

          case 'K':
            return AddressFormatPattern.K;

          case 'Z':
            return AddressFormatPattern.Z;

          case 'n':
            return AddressFormatPattern.n;
        }

        return null;
      },
      getPlaceHolder: function getPlaceHolder(pattern) {
        switch (pattern) {
          case AddressFormatPattern.A:
            return 'A';

          case AddressFormatPattern.C:
            return 'C';

          case AddressFormatPattern.S:
            return 'S';

          case AddressFormatPattern.K:
            return 'K';

          case AddressFormatPattern.Z:
            return 'Z';

          case AddressFormatPattern.n:
            return 'n';
        }

        return null;
      },
      getData: function getData(pattern, data) {
        if (data) {
          switch (pattern) {
            case AddressFormatPattern.A:
              return data.address;

            case AddressFormatPattern.C:
              return data.city;

            case AddressFormatPattern.S:
              return data.state;

            case AddressFormatPattern.K:
              return data.country;

            case AddressFormatPattern.Z:
              return data.zipCode;

            case AddressFormatPattern.n:
              return data.newLine;
          }
        }

        return null;
      }
    });

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    /**
     * Address token types enum
     *
     * @private
     */


    var AddressTokenTypes = Object.freeze({
      DATA: Symbol('data'),
      STRING: Symbol('string'),
      NEWLINE: Symbol('newline'),
      GROUP: Symbol('group')
    });
    /**
     * AddressToken class
     *
     * @private
     */

    var AddressToken = function () {
      /**
       *
       * @param {AddressTokenTypes} type
       * @param {string} string
       * @param {*} pattern
       */
      function AddressToken(type, string, pattern) {
        classCallCheck(this, AddressToken);
        this.type = type;
        this.string = string;
        this.pattern = pattern;
      }
      /**
       * Construct a string type token
       *
       * @param {string} string String
       * @return {AddressToken} Address Token
       */


      createClass(AddressToken, null, [{
        key: 'string',
        value: function string(_string) {
          return new AddressToken(AddressTokenTypes.STRING, _string);
        }
        /**
         * Construct a data type token
         *
         * @param {pattern} pattern Address Format Pattern
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'data',
        value: function data(pattern) {
          return new AddressToken(AddressTokenTypes.DATA, undefined, pattern);
        }
        /**
         * Construct a new line type token
         *
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'newLine',
        value: function newLine() {
          return new AddressToken(AddressTokenTypes.NEWLINE);
        }
      }]);
      return AddressToken;
    }();
    /**
     * TokenizerState class
     *
     * @private
     */


    var TokenizerState =
    /**
     * Constructor
     *
     * @param {string} pattern
     * @param {int} start
     */
    function TokenizerState(pattern, start) {
      classCallCheck(this, TokenizerState);
      this.pattern = pattern;
      this.start = start;
    };
    /**
     * Tokenize string pattern to AddressToken array
     *
     * @param {TokenizerState} state
     * @param {AddressToken[]} tokens
     * @return {TokenizerState} Tokenizer state
     *
     * @private
     */


    function tokenize(state, tokens) {
      var nextIndex = state.start;

      if (state.pattern) {
        var len = state.pattern.length;

        while (state.start < len) {
          nextIndex = state.pattern.indexOf('%', nextIndex);

          if (nextIndex >= 0 && nextIndex + 1 < len) {
            var placeHolder = state.pattern.substring(nextIndex + 1, nextIndex + 2);

            switch (placeHolder) {
              case 'n':
                {
                  if (nextIndex - state.start > 0) {
                    tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                  }

                  tokens.push(AddressToken.newLine());
                  state.start = nextIndex + 2;
                  nextIndex = state.start;
                  break;
                }

              default:
                {
                  var p = AddressFormatPattern.fromPlaceHolder(placeHolder);

                  if (p) {
                    if (nextIndex - state.start > 0) {
                      tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                    }

                    tokens.push(AddressToken.data(p));
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  } else {
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  }

                  break;
                }
            }
          } else {
            if (state.start < len) {
              tokens.push(AddressToken.string(state.pattern.substring(state.start)));
            }

            state.start = len;
          }
        }
      }

      return state;
    }
    /**
     * Format line from tokens
     *
     * @param {*} tokens
     * @param {*} data
     * @param {*} ignoreEmptyLines
     * @param {*} firstIndex
     * @param {*} lastIndex
     * @return {string} Formatted line
     *
     * @private
     */


    function formatLineTokens(tokens, data, ignoreEmptyLines, firstIndex, lastIndex) {
      var parts = [];

      for (var index = firstIndex; index <= lastIndex; index++) {
        var token = tokens[index];

        if (!token) {
          continue;
        } else if (token.type == AddressTokenTypes.DATA) {
          // Consume all subsequent data if available
          var dataBuffer = '';
          var lastDataIndex = index;

          for (var dataIndex = index; dataIndex <= lastIndex; dataIndex++) {
            var dataToken = tokens[dataIndex];

            if (!dataToken || dataToken.type != AddressTokenTypes.DATA) {
              break;
            }

            var fieldData = AddressFormatPattern.getData(dataToken.pattern, data);

            if (fieldData) {
              dataBuffer += fieldData;
              lastDataIndex = dataIndex;
            }
          }

          var hasData = dataBuffer && dataBuffer.length > 0; // Output previous string only if there is data before it,
          // or if it is the first on the line

          var hasPreviousData = false;

          if (index - 1 >= firstIndex) {
            var stringToken = tokens[index - 1];

            if (stringToken && stringToken.type == AddressTokenTypes.STRING && stringToken.string) {
              for (var prevIndex = index - 2; prevIndex >= firstIndex; prevIndex--) {
                var prevToken = tokens[prevIndex];

                if (prevToken && prevToken.type == AddressTokenTypes.DATA) {
                  var _fieldData = AddressFormatPattern.getData(prevToken.pattern, data);

                  if (_fieldData) {
                    hasPreviousData = true;
                    break;
                  }
                } else if (prevToken && prevToken.type == AddressTokenTypes.STRING) {
                  // ie. for "%C, %S %Z" without S -> "City, 95100"
                  // Comment this if we want "City 95100" instead
                  // (use the separator between S Z instead of C S)
                  stringToken = prevToken;
                }
              }

              if (!ignoreEmptyLines || hasPreviousData && hasData || index - 1 == firstIndex && hasData) {
                parts.push(stringToken.string);
              }
            }
          }

          if (hasData) {
            parts.push(dataBuffer);
          }

          index = lastDataIndex; // Output next string only if it is the last
          // and there is previous data before it

          if (index + 1 == lastIndex) {
            var _stringToken = tokens[index + 1];

            if (_stringToken && _stringToken.type == AddressTokenTypes.STRING && _stringToken.string) {
              if (!ignoreEmptyLines || hasData || hasPreviousData) {
                parts.push(_stringToken.string);
              }
            } // Consume the last string token


            index = index + 1;
          }
        }
      }

      return parts.join('').trim();
    }
    /**
     * Tokenize address format pattern.
     *
     * @param {AddressToken[]} tokens
     * @param {*} data
     * @param {string} lineBreak
     * @param {boolean} ignoreEmptyLines
     * @return {string} Formatted Address
     *
     * @private
     */


    function formatTokens(tokens, data, lineBreak, ignoreEmptyLines) {
      var lines = [];
      var lineIndex = -1;

      for (var index = 0; index < tokens.length; index++) {
        var doFormat = false;
        var endWithNewLine = false;
        var token = tokens[index];

        switch (token.type) {
          case AddressTokenTypes.NEWLINE:
            {
              if (lineIndex >= 0) {
                doFormat = true;
                endWithNewLine = true;
              } else if (!ignoreEmptyLines) {
                lines.push(''); // Empty line
                // If the pattern ends with a newline

                if (index + 1 == tokens.length) {
                  lines.push(''); // Empty line
                }
              }

              break;
            }

          default:
            {
              lineIndex = lineIndex < 0 ? index : lineIndex;
              doFormat = index + 1 == tokens.length ? true : doFormat;
              break;
            }
        }

        if (doFormat) {
          var line = formatLineTokens(tokens, data, ignoreEmptyLines, lineIndex, endWithNewLine ? index - 1 : index);

          if (!ignoreEmptyLines || line) {
            lines.push(line);
          } // If line ends with a newline, and it is the last line on pattern


          if (!ignoreEmptyLines && endWithNewLine && index + 1 == tokens.length) {
            lines.push('');
          }

          lineIndex = -1;
        }
      }

      return lines.join(lineBreak);
    }
    /**
     * Format address data.
     *
     * @param {*} data Address data being processed.
     * @param {string} pattern Address format pattern.
     * @param {string} lineBreak Line break string to use
     * @param {boolean} ignoreEmptyLines Ignore lines that has no or empty data to replace.
     * @return {string} Formatted address.
     */


    function format(data, pattern, lineBreak, ignoreEmptyLines) {
      // TODO: support escapeHtml to match Java class feature parity
      ignoreEmptyLines = ignoreEmptyLines === false ? false : true; // Defaults to false

      lineBreak = lineBreak || '\n'; // Defaults to <br/> or lf

      var tokens = [];
      tokenize(new TokenizerState(pattern, 0), tokens);
      return formatTokens(tokens, data, lineBreak, ignoreEmptyLines);
    }

    var addressFormatter = {
      format: format
    };
    var CJK_COUNTRIES = ['CN', 'HK', 'TW', 'JP', 'KR', 'KP'];
    var CJK_LANGUAGES = ['zh', 'ja', 'ko'];
    var address = {
      /**
       * Gets the globalization for the specified country code.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {{fmt: string, input: string, require: string}} Format Data
       */
      getAddressInfoForCountry: function getAddressInfoForCountry(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          var cloneAddressRep = Object.freeze(Object.assign({}, data[code]));
          return Object.freeze({
            address: cloneAddressRep
          });
        }

        return {};
      },

      /**
       * Get the format pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Address Format Pattern
       */
      getAddressFormat: function getAddressFormat(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].fmt;
        }

        return '';
      },

      /**
       * Get the input order pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrder: function getAddressInputOrder(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].input;
        }

        return '';
      },

      /**
       * Get the input order pattern for all fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrderAllField: function getAddressInputOrderAllField(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          var input = data[code].input; // Add missing patterns.

          if (input.indexOf('S') === -1) {
            input = input.replace('K', 'SK');
          }

          if (input.indexOf('C') === -1) {
            input = input.replace('S', 'CS');
          }

          if (input.indexOf('Z') === -1) {
            input = input.replace('C', 'ZC');
          }

          return input;
        }

        return '';
      },

      /**
       * Get required fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Required Fields
       */
      getAddressRequireFields: function getAddressRequireFields(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].require;
        }

        return '';
      },

      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddressAllFields: function formatAddressAllFields(langCode, countryCode, values, lineBreak) {
        var code = this.getCountryFromLocale(langCode, countryCode, values);

        if (data[code]) {
          // Double check.
          var pattern = data[code].fmt; // Some countries don't have City, State or ZIP code. We don't want to
          // lose those data from formatted string.

          if (values.zipCode && pattern.indexOf('%Z') === -1) {
            pattern = pattern.replace('%K', '%Z %K');
          }

          if (values.city && pattern.indexOf('%C') === -1) {
            pattern = pattern.replace('%K', '%C %K');
          }

          if (values.state && pattern.indexOf('%S') === -1) {
            pattern = pattern.replace('%K', '%S %K');
          }

          return this.buildAddressLines(pattern, values, lineBreak, true);
        }

        return '';
      },

      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddress: function formatAddress(langCode, countryCode, values, lineBreak) {
        var code = this.getCountryFromLocale(langCode, countryCode, values);

        if (data[code]) {
          // Double check.
          return this.buildAddressLines(data[code].fmt, values, lineBreak, true);
        }

        return '';
      },

      /**
       * Creates an array of address lines given the format and the values to use.
       *
       * @param {string} pattern
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values
       * @param {string} lineBreak
       * @param {string} ignoreEmptyLines
       * @return {string} the text for use in the address
       */
      buildAddressLines: function buildAddressLines(pattern, values, lineBreak, ignoreEmptyLines) {
        return addressFormatter.format(values, pattern, lineBreak, ignoreEmptyLines);
      },

      /**
       * Resolve the reference by tracing down the _ref value.
       * @param {*} data Address Format Data
       * @param {string} countryCode Country Code
       * @return {*} Referenced Address Format Data
       */
      followReferences: function followReferences(data$$1, countryCode) {
        if (data$$1[countryCode] && data$$1[countryCode]._ref) {
          return this.followReferences(data$$1, data$$1[countryCode]._ref);
        }

        return countryCode;
      },

      /**
       * Check strings for Han characters
       *
       * @param {...string} values String values to check against
       * @return {boolean} true if any of string values contain Han script character
       */
      containsHanScript: function containsHanScript() {
        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        if (!values || !Array.isArray(values)) return false;
        return values.some(function (value) {
          if (!value) return false; // Javascript regex do not work with surrogate pairs so String#match is unusable with supplemental ranges.
          // Iterating a string returns a char that contains one codepoint.
          // Surrogate pairs will be returned as a pair.
          // Unicode block ranges: @see http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var singleChar = _step.value;
              var codePoint = singleChar.codePointAt(0); // Thank you ES2015

              if (0x2e80 <= codePoint && codePoint <= 0x2eff || // CJK Radicals Supplement
              0x3300 <= codePoint && codePoint <= 0x33ff || // CJK Compatibility
              0xfe30 <= codePoint && codePoint <= 0xfe4f || // CJK Compatibility Forms
              0xf900 <= codePoint && codePoint <= 0xfaff || // CJK Compatibility Ideographs
              0x2f800 <= codePoint && codePoint <= 0x2fa1f || // CJK Compatibility Ideographs Supplement
              0x3000 <= codePoint && codePoint <= 0x303f || // CJK Symbols and Punctuation
              0x4e00 <= codePoint && codePoint <= 0x9fff || // CJK Unified Ideographs
              0x3400 <= codePoint && codePoint <= 0x4dbf || // CJK Unified Ideographs Extension A
              0x20000 <= codePoint && codePoint <= 0x2a6df || // CJK Unified Ideographs Extension B
              0x2a700 <= codePoint && codePoint <= 0x2b73f || // CJK Unified Ideographs Extension C
              0x2b740 <= codePoint && codePoint <= 0x2b81f || // CJK Unified Ideographs Extension D
              0x2b820 <= codePoint && codePoint <= 0x2ceaf || // CJK Unified Ideographs Extension E // Not on core
              0x2ceb0 <= codePoint && codePoint <= 0x2ebef || // CJK Unified Ideographs Extension F // Not on core
              0x3200 <= codePoint && codePoint <= 0x32ff || // Enclosed CJK Letters and Months
              0x31c0 <= codePoint && codePoint <= 0x31ef || // CJK Strokes
              // Chinese
              0x3100 <= codePoint && codePoint <= 0x312f || // Bopomofo
              0x31a0 <= codePoint && codePoint <= 0x31bf || // Bopomofo Extended
              0x2f00 <= codePoint && codePoint <= 0x2fdf || // Kangxi Radicals
              0x2ff0 <= codePoint && codePoint <= 0x2fff || // Ideographic Description Characters
              // Japanese
              0xff00 <= codePoint && codePoint <= 0xffef || // Halfwidth and Fullwidth Forms
              0x3040 <= codePoint && codePoint <= 0x309f || // Hiragana
              0x30a0 <= codePoint && codePoint <= 0x30ff || // Katakana
              0x31f0 <= codePoint && codePoint <= 0x31ff || // Katakana Phonetic Extensions
              0x1b000 <= codePoint && codePoint <= 0x1b0ff || // Kana Supplement
              0x1b100 <= codePoint && codePoint <= 0x1b12f || // Kana Extended-A // Not on core
              // Korean
              0x1100 <= codePoint && codePoint <= 0x11ff || // Hangul Jamo
              0xac00 <= codePoint && codePoint <= 0xd7af || // Hangul Syllables
              0x3130 <= codePoint && codePoint <= 0x318f || // Hangul Compatibility Jamo
              0xa960 <= codePoint && codePoint <= 0xa97f || // Hangul Jamo Extended-A
              0xd7b0 <= codePoint && codePoint <= 0xd7ff // Hangul Jamo Extended-B
              ) {
                  return true;
                }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return false;
        });
      },

      /**
       * Returns the address code (country code) for given locale and data.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} values Address Data
       * @return {string} Address Code
       */
      getCountryFromLocale: function getCountryFromLocale(langCode, countryCode, values) {
        if (values) {
          var isCJK = !countryCode && CJK_LANGUAGES.indexOf(langCode.toLowerCase()) >= 0 || countryCode && CJK_COUNTRIES.indexOf(countryCode.toUpperCase()) >= 0;
          var isJA = !countryCode && 'ja' == langCode.toLowerCase() || countryCode && 'JP' == countryCode.toUpperCase(); // English format (ja_en_JP) is only used when all fields do not contain CJK characters

          if (!(isJA && this.containsHanScript(values.address, values.city, values.state, values.country)) && isCJK && !this.containsHanScript(values.address)) {
            return this.getCountryFromLocale(langCode, 'EN_' + countryCode);
          }
        }

        var country = countryCode; // Address format should be always associated to a COUNTRY.
        // If country part is empty, we need to map language to a
        // certain country. For example, "de" -> "DE".

        if (!countryCode && languageCodeToCountry.languageCode[langCode]) {
          country = languageCodeToCountry.languageCode[langCode];
        } // Trace the real data from country reference.


        country = this.followReferences(data, country);

        if (!country || !data[country]) {
          return 'US'; // Always fall back to US format.
        }

        return country;
      },

      /**
       * Get fall back country code.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} address Address Data
       * @return {string} Address Code
       *
       * @deprecated Use getCountryFromLocale instead
       */
      getFallback: function getFallback(langCode, countryCode, address) {
        return this.getCountryFromLocale(langCode, countryCode);
      }
    };

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/name.js
    // This will be added/updated through a build process in the future

    /* eslint-disable */
    var data$1 = {
      DEFAULT: {
        short_f: '%F %L',
        medium_f: '%F %M %L',
        long_f: '%S %F %M %L %X %I',
        input: 'SFMLXI'
      },
      vi: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLFMXI'
      },
      vi_VN: {
        _ref: 'vi'
      },
      hu: {
        short_f: '%L %F',
        medium_f: '%L %F',
        long_f: '%L %F %M %X %I',
        input: 'SLFMXI'
      },
      hu_HU: {
        _ref: 'hu'
      },
      ja: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLMFXI'
      },
      ja_JP: {
        _ref: 'ja'
      },
      ko: {
        _ref: 'ja'
      },
      ko_KR: {
        _ref: 'ja'
      },
      zh: {
        _ref: 'ja'
      },
      zh_CN: {
        _ref: 'ja'
      },
      zh_CN_PINYIN: {
        _ref: 'ja'
      },
      zh_CN_STROKE: {
        _ref: 'ja'
      },
      zh_HK: {
        _ref: 'ja'
      },
      zh_HK_STROKE: {
        _ref: 'ja'
      },
      zh_MO: {
        _ref: 'ja'
      },
      zh_SG: {
        _ref: 'ja'
      },
      zh_TW: {
        _ref: 'ja'
      },
      zh_TW_STROKE: {
        _ref: 'ja'
      }
    }; // Define all available fields.

    /**
     S: Salutation
     F: First Name(givenName)
     M: Middle Name
     L: Last Name(familyName)
     X: Suffix
     I: Informal Name
     */

    var fieldConstants = {
      SALUTATION: Symbol('Salutation'),
      FIRST: Symbol('First Name'),
      MIDDLE: Symbol('Middle Name'),
      LAST: Symbol('Last Name'),
      SUFFIX: Symbol('Suffix'),
      INFORMAL: Symbol('Informal Name')
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var Format = function Format(parts) {
      _classCallCheck(this, Format);

      this.parts = Object.freeze(parts);
      Object.freeze(this);
    };
    /**
     * Represents a field within the format
     */


    var FieldFormatPart = function FieldFormatPart(field) {
      _classCallCheck(this, FieldFormatPart);

      this.field = field;
      this.type = 'field';
      Object.freeze(this);
    };
    /**
     * Represents text to be output directly
     */


    var TextFormatPart = function TextFormatPart(text) {
      _classCallCheck(this, TextFormatPart);

      this.type = 'text';
      this.text = text;
      Object.freeze(this);
    };

    var fieldFormatParts = Object.freeze({
      SALUTATION: new FieldFormatPart(fieldConstants.SALUTATION),
      FIRST: new FieldFormatPart(fieldConstants.FIRST),
      MIDDLE: new FieldFormatPart(fieldConstants.MIDDLE),
      LAST: new FieldFormatPart(fieldConstants.LAST),
      SUFFIX: new FieldFormatPart(fieldConstants.SUFFIX),
      INFORMAL: new FieldFormatPart(fieldConstants.INFORMAL)
    });

    var FormatParser = function () {
      function FormatParser() {
        _classCallCheck(this, FormatParser);
      }

      _createClass(FormatParser, [{
        key: 'parse',

        /**
         * Parses the format
         * @param {string} fmt the format to be parsed
         * @returns {Format}
         */
        value: function parse(fmt) {
          var nodes = [];
          var textBuffer = ''; // parse the format string

          for (var i = 0; i < fmt.length; i = i + 1) {
            if (fmt[i] === '%') {
              i = i + 1; // move to the next character after %
              // end the last text buffer

              if (textBuffer.length > 0) {
                nodes.push(Object.freeze(new TextFormatPart(textBuffer)));
                textBuffer = '';
              }

              if (i >= fmt.length) {
                throw new Error('Unexpected end of format. Symbol at ' + (i - 1) + ' should be followed by a valid field code');
              }

              var code = fmt[i];

              switch (code) {
                case 'S':
                  nodes.push(fieldFormatParts.SALUTATION);
                  break;

                case 'F':
                  nodes.push(fieldFormatParts.FIRST);
                  break;

                case 'M':
                  nodes.push(fieldFormatParts.MIDDLE);
                  break;

                case 'L':
                  nodes.push(fieldFormatParts.LAST);
                  break;

                case 'X':
                  nodes.push(fieldFormatParts.SUFFIX);
                  break;

                case 'I':
                  nodes.push(fieldFormatParts.INFORMAL);
                  break;

                default:
                  // TODO log the bad symbol and continue
                  break;
              }
            } else {
              // if it wasn't a symbol, then just output the value directly
              textBuffer += fmt[i];
            }
          }

          if (textBuffer.length > 0) {
            nodes.push(new TextFormatPart(textBuffer));
          }

          return new Format(nodes);
        }
      }]);

      return FormatParser;
    }();

    var formatParser = new FormatParser();
    var name = {
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {{short: string, medium: string, long: string, input: string}} format data
       */
      getNameInfoForLocale: function getNameInfoForLocale(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          var cloneNameInfo = Object.freeze(Object.assign({}, data$1[key]));
          return Object.freeze({
            name: cloneNameInfo
          });
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternMedium: function getNameFormatPatternMedium(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].medium_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternShort: function getNameFormatPatternShort(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].short_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternLong: function getNameFormatPatternLong(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].long_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} input order
       */
      getNameInputOrder: function getNameInputOrder(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].input;
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameShort: function formatNameShort(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].short_f, values);
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameMedium: function formatNameMedium(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].medium_f, values);
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameLong: function formatNameLong(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].long_f, values);
        }
      },

      /**
       * Creates an array of address lines given the format and the values to use.
       * @param {string} pattern
       * @param @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the text for use in the address
       */
      buildName: function buildName(pattern, values) {
        var format = formatParser.parse(pattern);
        var sb = [];

        for (var i = 0; i < format.parts.length; i++) {
          var part = format.parts[i];

          if (part.type === 'text') {
            sb.push(part.text);
          } else if (part.type === 'field') {
            if (part.field === fieldConstants.SALUTATION) {
              sb.push(values.salutation || '');
            } else if (part.field === fieldConstants.FIRST) {
              sb.push(values.first || '');
            } else if (part.field === fieldConstants.MIDDLE) {
              sb.push(values.middle || '');
            } else if (part.field === fieldConstants.LAST) {
              sb.push(values.last || '');
            } else if (part.field === fieldConstants.SUFFIX) {
              sb.push(values.suffix || '');
            } else if (part.field === fieldConstants.INFORMAL) {
              sb.push(values.informal || '');
            }
          }
        }

        return sb.join('').trim().replace(/  /g, ' ');
      },
      // Resolve the reference by tracing down the _ref value.
      followReferences: function followReferences(key) {
        if (data$1[key] && data$1[key]._ref) {
          return this.followReferences(data$1[key]._ref);
        }

        return key;
      },
      // Get fall back key.
      getFallback: function getFallback(localeStr) {
        // Resolve the reference.
        var key = this.followReferences(localeStr);

        if (!data$1[key]) {
          return 'DEFAULT'; // Always fall back to 'US'.
        }

        return key;
      }
    };

    // This returns the locale tag similar to the lwc @salesforce/i18n/locale and should be replaced once we switch to lwc GVPs
    // The aura locale GVPs are confusing, see the following doc for more details and their lwc equivalent:
    // See https://salesforce.quip.com/M9sPA9xFnRgv

    function getLocaleTag() {
      const localeLanguage = configProvider$1.getLocale().userLocaleLang; // e.g. 'en'

      const localeCountry = configProvider$1.getLocale().userLocaleCountry; // e.g. 'CA'

      if (!localeLanguage) {
        return configProvider$1.getLocale().langLocale.replace(/_/g, '-'); // e.g. 'en_US' -> 'en-US'
      } // should return a valid BCP47 tag


      return localeLanguage + (localeCountry ? '-' + localeCountry : '');
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat#Parameters

    const POSSIBLE_OPTS = {
      style: true,
      currency: true,
      currencyDisplay: true,
      useGrouping: true,
      minimumIntegerDigits: true,
      minimumFractionDigits: true,
      maximumFractionDigits: true,
      minimumSignificantDigits: true,
      maximumSignificantDigits: true
    };
    const STYLE = {
      DECIMAL: 'decimal',
      CURRENCY: 'currency',
      PERCENT: 'percent'
    };
    const CURRENCY_DISPLAY = {
      CODE: 'code',
      // USD
      SYMBOL: 'symbol',
      // $
      NAME: 'name' // US Dollars

    };
    const SAFE_NUM_LENGTH = 15;
    const numberFormatInstancesCache = {};

    function getStringOfChar(char, amount) {
      return new Array(amount + 1).join(char);
    }

    function getGroupingCount(skeleton) {
      const match = skeleton.match(/,[#0]*\./);
      return match ? match[0].length - 2 : 0;
    }

    function getOptionsUniqueKey$1(options) {
      return Object.keys(options).sort().reduce((prev, optionName) => {
        if (POSSIBLE_OPTS[optionName]) {
          return prev + optionName + options[optionName] + '';
        }

        return prev;
      }, '');
    }

    function toNumber(value, defaultValue) {
      const number = parseInt(value, 10);

      if (isNaN(number)) {
        return defaultValue;
      }

      return number;
    }

    function getFractionPart(options) {
      const minimumDigits = toNumber(options.minimumFractionDigits, 0);
      const maximumDigits = Math.max(toNumber(options.maximumFractionDigits, 0), minimumDigits);
      return '.' + new Array(minimumDigits + 1).join('0') + new Array(maximumDigits - minimumDigits + 1).join('#');
    }

    function updateFractionPart(skeleton, options) {
      const fractionPart = getFractionPart(options);
      return fractionPart ? skeleton.replace(/\.(0|#)*/, fractionPart) : skeleton;
    }

    function updateCurrencySymbol(skeleton, currencyCode, options) {
      const symbol = String.fromCharCode(164);

      if (options.currencyDisplay === CURRENCY_DISPLAY.NAME) {
        // append the currency code at the end.
        return skeleton.replace(symbol, '') + currencyCode;
      }

      return skeleton.replace(symbol, currencyCode);
    }

    function updateIntegerPart(skeleton, options) {
      const minimumIntegerDigits = options.minimumIntegerDigits;
      const groupingCount = getGroupingCount(skeleton);

      if (!minimumIntegerDigits) {
        return skeleton;
      }

      if (minimumIntegerDigits <= groupingCount) {
        return skeleton.replace(/,[#0]*\./, ',' + getStringOfChar('#', groupingCount - minimumIntegerDigits) + getStringOfChar('0', minimumIntegerDigits) + '.');
      }

      return skeleton.replace(/[#0]*\./, getStringOfChar('0', minimumIntegerDigits - groupingCount) + ',' + getStringOfChar('0', groupingCount) + '.');
    }

    function getBestMatchCurrencySymbol(code, currencyDisplay) {
      if (!('Intl' in window)) {
        return code; // fail gracefully.
      }

      const opts = {
        style: 'currency',
        currency: code,
        minimumFractionDigits: 0
      };

      if (currencyDisplay) {
        opts.currencyDisplay = currencyDisplay;
      }

      const nf = getFromCache(opts);
      return nf.format(2).replace(/2/g, '');
    }

    function getCurrency(options) {
      const currencyDisplay = options.currencyDisplay || CURRENCY_DISPLAY.SYMBOL;

      if (currencyDisplay === CURRENCY_DISPLAY.SYMBOL || currencyDisplay === CURRENCY_DISPLAY.NAME) {
        return getBestMatchCurrencySymbol(options.currency, currencyDisplay);
      }

      return options.currency;
    }

    function getFromCache(options) {
      const optionsUniqueKey = getOptionsUniqueKey$1(options);
      let numberFormatInstance = numberFormatInstancesCache[optionsUniqueKey];

      if (numberFormatInstance) {
        return numberFormatInstance;
      }

      numberFormatInstance = new Intl.NumberFormat(getLocaleTag(), options);
      numberFormatInstancesCache[optionsUniqueKey] = numberFormatInstance;
      return numberFormatInstance;
    }

    function exceedsSafeLength(value, maxFractionDigits) {
      const str = value.toString();
      const intPart = str.split('.')[0];
      return intPart.length + toNumber(maxFractionDigits, 0) >= SAFE_NUM_LENGTH;
    }

    function normalizedMinimumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0]/g, '');
      return fractionDigits.length;
    }

    function normalizedMaximumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0#]/g, '');
      return Math.max(options.minimumFractionDigits, fractionDigits.length);
    }

    function getFallbackFractionSkeleton(style) {
      const locale = configProvider$1.getLocale();
      let styleFormat = 'numberFormat';

      if (style === STYLE.CURRENCY) {
        styleFormat = 'currencyFormat';
      } else if (style === STYLE.PERCENT) {
        styleFormat = 'percentFormat';
      }

      const format = locale[styleFormat].split(';')[0];
      return format.split('.')[1] || '';
    }

    function normalizeOptions(options) {
      const locale = configProvider$1.getLocale();
      const normalizedOpts = Object.assign({}, options);
      normalizedOpts.currency = normalizedOpts.currency || locale.currencyCode;

      if (normalizedOpts.minimumFractionDigits === undefined) {
        normalizedOpts.minimumFractionDigits = normalizedMinimumFractionDigits(normalizedOpts);
      }

      if (normalizedOpts.maximumFractionDigits === undefined || normalizedOpts.maximumFractionDigits < normalizedOpts.minimumFractionDigits) {
        normalizedOpts.maximumFractionDigits = normalizedMaximumFractionDigits(normalizedOpts);
      }

      return normalizedOpts;
    }

    function NumberOptions(options) {
      this.locale = configProvider$1.getLocale();
      this.options = options || {};
    }

    NumberOptions.prototype.isCurrency = function () {
      return this.options.style === 'currency';
    };

    NumberOptions.prototype.isPercent = function () {
      return this.options.style === 'percent';
    };

    NumberOptions.prototype.isDefaultCurrency = function () {
      return !this.options.currency || this.locale.currencyCode === this.options.currency;
    };

    NumberOptions.prototype.getDefaultSkeleton = function () {
      return this.isCurrency() ? this.locale.currencyFormat : this.isPercent() ? this.locale.percentFormat : this.locale.numberFormat;
    };

    NumberOptions.prototype.getSkeleton = function () {
      const options = this.options;
      const defaultSkeleton = this.getDefaultSkeleton();
      let skeleton = updateFractionPart(defaultSkeleton, options);
      skeleton = updateIntegerPart(skeleton, options);

      if (!this.isDefaultCurrency()) {
        skeleton = updateCurrencySymbol(skeleton, getCurrency(options), options);
      }

      return skeleton;
    };

    /*
     * Regex to test a string for an ISO8601 Date. The following formats are matched.
     * Note that if a time element is present (e.g. 'T'), the string should have a time zone designator (Z or +hh:mm or -hh:mm).
     *
     *  YYYY
     *  YYYY-MM
     *  YYYY-MM-DD
     *  YYYY-MM-DDThh:mmTZD
     *  YYYY-MM-DDThh:mm:ssTZD
     *  YYYY-MM-DDThh:mm:ss.STZD
     *
     *
     * @see: https://www.w3.org/TR/NOTE-datetime
     */
    const ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z){1})?)?)?$/i;
    /* Regex to test a string for an ISO8601 partial time or full time:
     * hh:mm
     * hh:mm:ss
     * hh:mm:ss.S
     * full time = partial time + TZD
     */

    const ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
    const STANDARD_TIME_FORMAT = 'HH:mm:ss.SSS';
    const STANDARD_DATE_FORMAT = 'YYYY-MM-DD';
    const TIME_SEPARATOR = 'T';
    const TIMEZONE_INDICATOR = /(Z|([+-])(\d{2}):(\d{2}))$/;
    function isValidISODateTimeString(dateTimeString) {
      return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
    }
    function isValidISOTimeString(timeString) {
      if (!isValidISO8601TimeString(timeString)) {
        return false;
      }

      const timeOnly = removeTimeZoneSuffix(timeString);
      return isValidDate(`2018-09-09T${timeOnly}Z`);
    }
    function removeTimeZoneSuffix(dateTimeString) {
      if (typeof dateTimeString === 'string') {
        return dateTimeString.split(TIMEZONE_INDICATOR)[0];
      }

      return dateTimeString;
    }

    function isValidISO8601String(dateTimeString) {
      if (typeof dateTimeString !== 'string') {
        return false;
      }

      return ISO8601_STRICT_PATTERN.test(dateTimeString);
    }

    function isValidISO8601TimeString(timeString) {
      if (typeof timeString !== 'string') {
        return false;
      }

      return ISO8601_TIME_PATTERN.test(timeString);
    }

    function isValidDate(value) {
      // Date.parse returns NaN if the argument doesn't represent a valid date
      const timeStamp = Date.parse(value);
      return isFinite(timeStamp);
    }

    // This is a library for all calls to the aura localizationService.
    function isBefore(date1, date2, unit) {
      return configProvider$1.getLocalizationService().isBefore(date1, date2, unit);
    }
    function isAfter(date1, date2, unit) {
      return configProvider$1.getLocalizationService().isAfter(date1, date2, unit);
    }
    function formatDateTimeUTC(date) {
      return configProvider$1.getLocalizationService().formatDateTimeUTC(date);
    }
    function formatDate(dateString, format, locale) {
      return configProvider$1.getLocalizationService().formatDate(dateString, format, locale);
    }
    function formatTime(timeString, format) {
      return configProvider$1.getLocalizationService().formatTime(timeString, format);
    }
    function parseDateTimeUTC(dateTimeString) {
      return configProvider$1.getLocalizationService().parseDateTimeUTC(dateTimeString);
    }
    function parseDateTimeISO8601(dateTimeString) {
      return configProvider$1.getLocalizationService().parseDateTimeISO8601(dateTimeString);
    }
    function parseDateTime(dateTimeString, format, strictMode) {
      return configProvider$1.getLocalizationService().parseDateTime(dateTimeString, format, strictMode);
    }
    function syncUTCToWallTime(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider$1.getLocalizationService().UTCToWallTime(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function syncWallTimeToUTC(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider$1.getLocalizationService().WallTimeToUTC(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function toOtherCalendar(date) {
      return configProvider$1.getLocalizationService().translateToOtherCalendar(date);
    }
    function fromOtherCalendar(date) {
      return configProvider$1.getLocalizationService().translateFromOtherCalendar(date);
    } // This belongs to localization service; i.e. getLocalizationService().parseTime()
    // Should be removed after it's been added to the localization service

    function parseTime(timeString, format, strictParsing) {
      if (!timeString) {
        return null;
      }

      if (!format) {
        if (!isValidISOTimeString(timeString)) {
          return null;
        }

        return parseDateTimeISO8601(timeString);
      }

      const parseString = timeString.replace(/(\d)([AaPp][Mm])/g, '$1 $2'); // Modifying the time string so that strict parsing doesn't break on minor deviations

      const parseFormat = format.replace(/(\b|[^h])h{2}(?!h)/g, '$1h').replace(/(\b|[^H])H{2}(?!H)/g, '$1H').replace(/(\b|[^m])m{2}(?!m)/g, '$1m').replace(/\s*A/g, ' A').trim();
      const acceptableFormats = [parseFormat]; // We want to be lenient and accept input values with seconds or milliseconds precision.
      // So even though we may display the time as 10:23 AM, we would accept input values like 10:23:30.555 AM.

      acceptableFormats.push(parseFormat.replace('m', 'm:s'), parseFormat.replace('m', 'm:s.S'), parseFormat.replace('m', 'm:s.SS'), parseFormat.replace('m', 'm:s.SSS')); // Start parsing from the most strict format (i.e. time with milliseconds).
      // The strict mode parsing of time strings using parseDateTime seems to be lenient for certain formats

      acceptableFormats.reverse();

      for (let i = 0; i < acceptableFormats.length; i++) {
        const time = parseDateTime(parseString, acceptableFormats[i], strictParsing);

        if (time) {
          return time;
        }
      }

      return null;
    } // This is called from the numberFormat library when the value exceeds the safe length.

    function getNumberFormat(format) {
      return configProvider$1.getLocalizationService().getNumberFormat(format);
    }

    function numberFormatFallback(options) {
      const skeleton = new NumberOptions(options).getSkeleton();
      return {
        format: value => {
          return getNumberFormat(skeleton).format(value);
        }
      };
    }

    function numberFormat(options) {
      const normalizedOpts = Object.assign({}, normalizeOptions(options));

      if (!('Intl' in window)) {
        return numberFormatFallback(normalizedOpts);
      }

      return {
        format: value => {
          if (value && exceedsSafeLength(value, normalizedOpts.maximumFractionDigits)) {
            return numberFormatFallback(normalizedOpts).format(value);
          }

          const numberFormatInstance = getFromCache(normalizedOpts);
          return numberFormatInstance.format(value);
        }
      };
    }

    const FALLBACK_LOCALE = 'en-us';
    const symbolsCache = {}; // Copied over from auraLocalizationService: override for locales which are not identified by browsers

    const localeOverrides = {
      no: 'nb',
      no_NO: 'nb',
      // eslint-disable-line camelcase
      tl_PH: 'fil',
      // eslint-disable-line camelcase
      sh_BA: 'hr',
      // eslint-disable-line camelcase
      sh_ME: 'hr',
      // eslint-disable-line camelcase
      sh_CS: 'hr' // eslint-disable-line camelcase

    };
    function getNameOfWeekdays() {
      const locale = getNormalizedLocale();
      const localeCache = symbolsCache[locale];

      if (localeCache && localeCache.weekdays) {
        return localeCache.weekdays;
      }

      const locales = [locale, FALLBACK_LOCALE];
      const fullNameFormatter = new Intl.DateTimeFormat(locales, {
        weekday: 'long',
        timeZone: 'UTC'
      });
      const shortNameFormatter = new Intl.DateTimeFormat(locales, {
        weekday: 'short',
        timeZone: 'UTC'
      });
      const weekdays = [];

      for (let i = 0; i <= 6; i++) {
        // (1970, 0, 4) corresponds to a sunday.
        const date = new Date(Date.UTC(1970, 0, 4 + i));
        weekdays.push({
          fullName: format$1(fullNameFormatter, date),
          shortName: format$1(shortNameFormatter, date)
        });
      }

      if (!symbolsCache[locale]) {
        symbolsCache[locale] = {};
      }

      symbolsCache[locale].weekdays = weekdays;
      return weekdays;
    }
    function getMonthNames() {
      const locale = getNormalizedLocale();
      const localeCache = symbolsCache[locale];

      if (localeCache && localeCache.months) {
        return localeCache.months;
      }

      const locales = [locale, FALLBACK_LOCALE];
      const monthNameFormatter = new Intl.DateTimeFormat(locales, {
        month: 'long'
      });
      const months = [];

      for (let i = 0; i <= 11; i++) {
        const date = new Date(1970, i, 4);
        months.push({
          // we currently only need the fullName
          fullName: format$1(monthNameFormatter, date)
        });
      }

      if (!symbolsCache[locale]) {
        symbolsCache[locale] = {};
      }

      symbolsCache[locale].months = months;
      return months;
    }

    function format$1(dateTimeFormat, date) {
      const formattedDate = dateTimeFormat.format(date);
      return removeIE11Markers(formattedDate);
    }

    function removeIE11Markers(formattedString) {
      // IE11 adds LTR / RTL mark in the formatted date time string
      return formattedString.replace(/[\u200E\u200F]/g, '');
    }

    function getNormalizedLocale() {
      const locale = configProvider$1.getLocale().langLocale;

      if (locale) {
        return localeOverrides[locale] || locale.toLowerCase().replace('_', '-');
      }

      return FALLBACK_LOCALE;
    }

    function normalizeISODate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // if value is an ISO string, only fetch the date part


      const dateOnlyString = typeof dateValue === 'string' && dateValue.split(TIME_SEPARATOR)[0] || dateValue;
      assert(isValidISODateTimeString(dateOnlyString), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTime(dateOnlyString, STANDARD_DATE_FORMAT);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // convert from Gregorian to Buddhist Calendar if necessary


      const civilDate = toOtherCalendar(parsedDate);
      return {
        isoValue: dateOnlyString,
        displayValue: formatDate(civilDate, format)
      };
    }
    function normalizeISOTime(value, format) {
      // We are not converting the time to the user's timezone. All values are displayed and saved as UTC time values
      const normalizedValue = removeTimeZoneSuffix(value);
      const timeValue = typeof normalizedValue === 'string' ? normalizedValue.trim() : normalizedValue;

      if (!timeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISOTimeString(timeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string. ` + `but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedTime = parseTime(timeValue);

      if (!parsedTime) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      return {
        isoValue: formatTime(parsedTime, STANDARD_TIME_FORMAT),
        displayValue: formatTime(parsedTime, format)
      };
    }
    function normalizeISODateTime(value, timezone, format) {
      const dateTimeValue = typeof value === 'string' ? value.trim() : value;

      if (!dateTimeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISODateTimeString(dateTimeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTimeISO8601(dateTimeValue);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      const convertedDate = syncUTCToWallTime(parsedDate, timezone);
      return {
        // We are passing the ISO value without a timezone designator.
        // the native input type='datetime-local' who calls this does not accept timezone offset
        isoValue: removeTimeZoneSuffix(convertedDate.toISOString()),
        displayValue: formatDateTimeUTC(convertedDate, format)
      };
    }
    function normalizeFormattedDate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return null;
      }

      const parsedDate = parseDateTime(dateValue, format || configProvider$1.getLocale().dateFormat, true);

      if (!parsedDate) {
        return null;
      }

      const gregorianDate = fromOtherCalendar(parsedDate);
      return formatDate(gregorianDate, STANDARD_DATE_FORMAT);
    }
    function normalizeFormattedTime(value, format) {
      const timeValue = typeof value === 'string' ? value.trim() : value;

      if (!timeValue) {
        return null;
      }

      const parsedDate = parseTime(timeValue, format || configProvider$1.getLocale().timeFormat, true);

      if (!parsedDate) {
        return null;
      }

      return formatTime(parsedDate, STANDARD_TIME_FORMAT);
    } // The value here isn't really formatted, it's always an ISO string in the form isoDate + T + isoTime (without Z).

    function normalizeFormattedDateTime(value, timezone, format) {
      const datetimeValue = typeof value === 'string' ? value.trim() : value;

      if (!datetimeValue) {
        return null;
      } // given that value is an ISO string without Z, the method below is equivalent to parseDateTimeISO8601(value + 'Z')
      // However, parseDateTimeUTC is more concise and doesn't need any manipulation of the input (adding Z).


      const parsedDate = parseDateTimeUTC(datetimeValue, format);

      if (!parsedDate) {
        return null;
      }

      const convertedDate = syncWallTimeToUTC(parsedDate, timezone);
      return convertedDate.toISOString();
    }
    function getToday() {
      const today = getTodayBasedOnTimezone();
      return today.getFullYear() + '-' + pad(today.getMonth() + 1) + '-' + pad(today.getDate());
    }
    function getCurrentTime(timezone) {
      const today = getTodayBasedOnTimezone(timezone);
      return pad(today.getHours()) + ':' + pad(today.getMinutes());
    }

    function getTodayBasedOnTimezone(timezone) {
      const today = new Date();
      today.setTime(today.getTime() + today.getTimezoneOffset() * 60 * 1000); // time in UTC
      // localization service will use $Locale.timezone when no timezone provided

      return syncUTCToWallTime(today, timezone);
    }

    function pad(n) {
      return n < 10 ? '0' + n : n;
    }

    const i18n$5 = {
      ariaLabelMonth: labelAriaLabelMonth,
      nextMonth: labelNextMonth,
      previousMonth: labelPreviousMonth,
      today: labelToday,
      yearSelector: labelYearSelector
    };
    const WEEKS_PER_MONTH = 6;
    const DAYS_PER_WEEK = 7;
    const calendarCache = {}; // cache of calendar cells for a given year/month

    class LightningCalendar extends lwc.LightningElement {
      get value() {
        return this.selectedDate;
      }

      set value(newValue) {
        // if value is an ISO string, only fetch the time part
        const dateOnlyString = typeof newValue === 'string' ? newValue.split(TIME_SEPARATOR)[0] : newValue;

        if (dateOnlyString !== this.selectedDate) {
          this.selectedDate = dateOnlyString;

          if (!this._connected) {
            return;
          }

          const newDate = this.parseDate(dateOnlyString); // if the date is invalid, render today's date

          if (!newDate) {
            this.selectedDate = null;
            this.renderToday();
          } else {
            this.selectDate(newDate);
          }
        }
      }

      constructor() {
        super();
        this.calendarYear = null;
        this.calendarMonth = null;
        this.min = void 0;
        this.max = void 0;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready'));
      }

      connectedCallback() {
        this._connected = true;
        this.todayDate = getToday();
        const renderDate = this.getSelectedDate() || this.getTodaysDate();
        this.renderCalendar(renderDate);
        this.keyboardInterface = this.calendarKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the focusable date cell in the calendar.
       */


      focus() {
        requestAnimationFrame(() => {
          const dateElement = this.getFocusableDateCell();

          if (dateElement) {
            dateElement.focus();
          }
        });
      }

      get i18n() {
        return i18n$5;
      }

      get computedAriaLabel() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return i18n$5.ariaLabelMonth + getMonthNames()[renderedMonth].fullName;
      }

      get computedMonthTitle() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return getMonthNames()[renderedMonth].fullName;
      }

      get computedWeekdayLabels() {
        const nameOfWeekdays = getNameOfWeekdays();
        const firstDayOfWeek = this.getFirstDayOfWeek();
        const computedWeekdayLabels = []; // We need to adjust the weekday labels to start from the locale's first day of week

        for (let i = firstDayOfWeek; i < nameOfWeekdays.length; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        for (let i = 0; i < firstDayOfWeek; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        return computedWeekdayLabels;
      }

      get computedSelectElementId() {
        return this.uniqueId + '-select';
      }

      get computedWeekdaysElementId() {
        return this.uniqueId + '-weekdays';
      }

      get computedMonthTitleId() {
        return this.uniqueId + '-month';
      }

      get computedYearList() {
        const sampleDate = new Date();
        const currentYear = sampleDate.getFullYear();
        const minDate = this.parseDate(this.min);
        const maxDate = this.parseDate(this.max);
        const minYear = minDate ? minDate.getFullYear() : currentYear - 100;
        sampleDate.setFullYear(minYear);
        const convertedMinYear = toOtherCalendar(sampleDate).getFullYear();
        const maxYear = maxDate ? maxDate.getFullYear() : currentYear + 100;
        sampleDate.setFullYear(maxYear);
        const convertedMaxYear = toOtherCalendar(sampleDate).getFullYear();
        const yearList = [];

        for (let year = convertedMinYear; year <= convertedMaxYear; year++) {
          yearList.push({
            label: year,
            value: year
          });
        }

        return yearList;
      }

      get computedMonth() {
        if (!this._connected) {
          return [];
        }

        this.removeCurrentlySelectedDateAttributes();
        const selectedDate = this.getSelectedDate();
        const renderDate = this.getCalendarDate();
        const cacheKey = this.getCalendarCacheKey(renderDate, selectedDate);

        if (cacheKey in calendarCache) {
          return calendarCache[cacheKey];
        }

        const todayDate = this.getTodaysDate();
        const focusableDate = this.getInitialFocusDate(todayDate, selectedDate, renderDate);
        const calendarDates = {
          selectedDate,
          renderDate,
          focusableDate,
          todayDate,
          minDate: this.parseDate(this.min),
          maxDate: this.parseDate(this.max)
        };
        const monthCells = [];
        const date = this.getCalendarStartDate(renderDate);

        for (let week = 0; week < WEEKS_PER_MONTH; week++) {
          const weekCells = {
            id: week,
            days: []
          };

          for (let weekday = 0; weekday < DAYS_PER_WEEK; weekday++) {
            const dayCell = this.getDateCellAttributes(date, calendarDates);
            weekCells.days.push(dayCell);
            date.setDate(date.getDate() + 1);
          }

          monthCells.push(weekCells);
        }

        calendarCache[cacheKey] = monthCells;
        return monthCells;
      }

      getDateCellAttributes(date, calendarDates) {
        const isDisabled = !this.dateInCalendar(date, calendarDates.renderDate) || !this.isBetween(date, calendarDates.minDate, calendarDates.maxDate);
        const isSelected = this.isSame(date, calendarDates.selectedDate);
        const isToday = this.isSame(date, calendarDates.todayDate);
        const ariaCurrent = isToday ? 'date' : false;
        const tabIndex = this.isSame(date, calendarDates.focusableDate) ? '0' : false;
        const className = classSet().add({
          'slds-is-today': isToday,
          'slds-is-selected': isSelected,
          'slds-disabled-text': isDisabled
        }).toString();
        return {
          date: date.getDate(),
          dateValue: this.formatDate(date),
          isDisabled,
          isSelected: isSelected ? 'true' : 'false',
          className,
          tabIndex,
          ariaCurrent
        };
      }

      dispatchSelectEvent() {
        this.dispatchEvent(new CustomEvent('select', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this.selectedDate
          }
        }));
      } // Determines if the date is in the rendered month/year calendar.


      dateInCalendar(date, calendarDate) {
        const renderedCalendar = calendarDate || this.getCalendarDate();
        return date.getMonth() === renderedCalendar.getMonth() && date.getFullYear() === renderedCalendar.getFullYear();
      }

      getInitialFocusDate(todayDate, selectedDate, renderedDate) {
        if (selectedDate && this.dateInCalendar(selectedDate, renderedDate)) {
          return selectedDate;
        }

        if (this.dateInCalendar(todayDate, renderedDate)) {
          return todayDate;
        }

        return new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
      }

      getTodaysDate() {
        if (this.todayDate) {
          return this.parseDate(this.todayDate);
        } // Today's date will be fetched in connectedCallback. In the meantime, use the date based on the device timezone.


        return new Date();
      }

      getSelectedDate() {
        return this.parseDate(this.selectedDate);
      } // returns the month and year in the calendar


      getCalendarDate() {
        if (this.calendarYear) {
          return new Date(this.calendarYear, this.calendarMonth, 1);
        }

        return this.getTodaysDate();
      }

      getCalendarStartDate(renderedDate) {
        const firstDayOfMonth = new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
        return this.getStartOfWeek(firstDayOfMonth);
      }

      getStartOfWeek(dayInWeek) {
        const firstDayOfWeek = this.getFirstDayOfWeek(); // Negative dates in JS will subtract days from the 1st of the given month

        let startDay = dayInWeek.getDay();

        while (startDay !== firstDayOfWeek) {
          dayInWeek.setDate(dayInWeek.getDate() - 1);
          startDay = dayInWeek.getDay();
        }

        return dayInWeek;
      }

      getFirstDayOfWeek() {
        return configProvider$1.getLocale().firstDayOfWeek - 1; // In Java, week days are 1 - 7
      } // This method is called when a new value is set, or when you click the today button.
      // In both cases, we need to check if newValue is in the currently rendered calendar


      selectDate(newDate) {
        if (this.dateInCalendar(newDate)) {
          const dateElement = this.getElementByDate(this.formatDate(newDate)); // do not select if date is disabled

          if (this.dateElementDisabled(dateElement)) {
            return;
          }

          this.selectDateInCalendar(dateElement);
        } else {
          this.renderCalendar(newDate);
        }
      } // Select a date in current calendar without the need to re-render the calendar


      selectDateInCalendar(dateElement) {
        this.selectedDate = dateElement.getAttribute('data-value');
        this.removeCurrentlySelectedDateAttributes();
        this.addSelectedDateAttributes(dateElement);
      }

      selectDateInCalendarAndDispatchSelect(dateElement) {
        // do not select if date is disabled
        if (this.dateElementDisabled(dateElement)) {
          return;
        }

        this.selectDateInCalendar(dateElement);
        this.dispatchSelectEvent();
      } // we should be able to control the select value with an attribute once we have a select component


      selectYear(year) {
        const sampleDate = new Date();
        sampleDate.setFullYear(year);
        const convertedYear = toOtherCalendar(sampleDate).getFullYear();
        const optionElement = this.template.querySelector(`option[value='${convertedYear}']`);

        if (optionElement) {
          optionElement.selected = true;
        }
      }

      getElementByDate(dateString) {
        return this.template.querySelector(`td[data-value='${dateString}']`);
      }

      getFocusableDateCell() {
        return this.template.querySelector(`td[tabIndex='0']`);
      }

      unfocusDateCell(element) {
        if (element) {
          element.removeAttribute('tabIndex');
        }
      }

      focusDateCell(element) {
        if (element) {
          element.setAttribute('tabIndex', 0);
          element.focus();
        }
      }

      focusElementByDate(date) {
        requestAnimationFrame(() => {
          const element = this.getElementByDate(this.formatDate(date));

          if (element) {
            this.unfocusDateCell(this.getFocusableDateCell());
            this.focusDateCell(element);
          }
        });
      }

      renderCalendar(newDate) {
        this.calendarMonth = newDate.getMonth();
        this.calendarYear = newDate.getFullYear();
        this.selectYear(newDate.getFullYear());
      }

      renderToday() {
        const todaysDate = this.getTodaysDate();

        if (this.dateInCalendar(todaysDate)) {
          this.removeCurrentlySelectedDateAttributes();
          this.unfocusDateCell(this.getFocusableDateCell());
          const todayElement = this.getElementByDate(this.todayDate);
          todayElement.setAttribute('tabIndex', 0);
        } else {
          this.renderCalendar(todaysDate);
        }
      }

      removeCurrentlySelectedDateAttributes() {
        const currentlySelectedElement = this.template.querySelector(`td[class*='slds-is-selected']`);

        if (currentlySelectedElement) {
          currentlySelectedElement.classList.remove('slds-is-selected');
          currentlySelectedElement.setAttribute('aria-selected', 'false');
        }

        this.unfocusDateCell(this.getFocusableDateCell());
      }

      addSelectedDateAttributes(dateElement) {
        this.focusDateCell(dateElement);
        dateElement.classList.add('slds-is-selected');
        dateElement.setAttribute('aria-selected', 'true');
      }

      dateElementDisabled(dateElement) {
        // do not select if date is disabled
        return !dateElement || dateElement.getAttribute('aria-disabled') === 'true';
      }

      handleCalendarKeyDown(event) {
        const dateString = event.target.getAttribute('data-value');
        handleKeyDownOnCalendar(event, this.parseDate(dateString), this.keyboardInterface);
      }

      handleTodayKeyDown(event) {
        handleKeyDownOnToday(event, this.keyboardInterface);
      }

      handlePrevNavKeyDown(event) {
        handleKeyDownOnPreviousMonthNav(event, this.keyboardInterface);
      }

      handleDateClick(event) {
        event.stopPropagation();
        const tdElement = event.target.parentElement;
        this.selectDateInCalendarAndDispatchSelect(tdElement);
      }

      handleTodayClick(event) {
        event.stopPropagation();
        this.selectedDate = this.todayDate;
        this.selectDate(this.getTodaysDate());
        this.dispatchSelectEvent();
      }

      handleYearSelectClick(event) {
        event.stopPropagation();
      }

      handleYearChange(event) {
        event.stopPropagation();
        const sampleDate = new Date();
        sampleDate.setFullYear(event.target.value);
        const convertedYear = fromOtherCalendar(sampleDate).getFullYear();

        if (this.calendarYear !== convertedYear) {
          this.calendarYear = convertedYear;
        }
      }

      goToNextMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() + 1);
        this.renderCalendar(calendarDate);
      }

      goToPreviousMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() - 1);
        this.renderCalendar(calendarDate);
      }

      calendarKeyboardInterface() {
        const that = this;
        return {
          focusDate(newDate) {
            if (!that.dateInCalendar(newDate)) {
              that.renderCalendar(newDate);
            }

            that.focusElementByDate(newDate);
          },

          getStartOfWeek(dayInWeek) {
            return that.getStartOfWeek(dayInWeek);
          },

          focusFirstFocusableElement() {
            that.template.querySelector('lightning-button-icon').focus();
          },

          focusLastFocusableElement() {
            that.template.querySelector('button[name="today"]').focus();
          },

          selectDate(dateElement) {
            that.selectDateInCalendarAndDispatchSelect(dateElement);
          }

        };
      }

      formatDate(date) {
        return formatDate(date, STANDARD_DATE_FORMAT);
      }

      parseDate(dateString) {
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      isSame(date1, date2) {
        if (!date1 || !date2) {
          return false;
        }

        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate() // getDate returns the day in month whereas getDay returns the weekday number
        ;
      }

      isBetween(date, date1, date2) {
        let isBeforeEndDate = true;
        let isAfterStartDate = true;

        if (date2) {
          isBeforeEndDate = isBefore(date, date2, 'day') || this.isSame(date, date2);
        }

        if (date1) {
          isAfterStartDate = isAfter(date, date1, 'day') || this.isSame(date, date1);
        }

        return isBeforeEndDate && isAfterStartDate;
      }

      getCalendarCacheKey(renderDate, selectedDate) {
        let key = renderDate.getFullYear() + '-' + renderDate.getMonth(); // Having the key include min/max seems enough for now.
        // We're not going to complicate things by checking if renderDate falls before/after the min/max.

        key += this.min ? 'min' + this.min : '';
        key += this.max ? 'max' + this.max : '';

        if (selectedDate && this.dateInCalendar(selectedDate, renderDate)) {
          key += '_' + selectedDate.getDate();
        }

        return key;
      }

    }

    lwc.registerDecorators(LightningCalendar, {
      publicProps: {
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        calendarYear: 1,
        calendarMonth: 1
      }
    });

    var _lightningCalendar = lwc.registerComponent(LightningCalendar, {
      tmpl: _tmpl$f
    });

    function tmpl$f($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-dropdown-trigger": true,
          "slds-dropdown-trigger_click": true,
          "slds-size_1-of-1": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 2
      }, [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 6
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-input-has-icon": true,
          "slds-input-has-icon_right": true
        },
        key: 7
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("input"),
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "aria-label": $cmp.ariaLabel,
          "autocomplete": $cmp.autocomplete
        },
        props: {
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 8,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleInputFocus)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleInputBlur)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeydown)),
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleInputClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "iconName": "utility:event",
          "variant": "bare",
          "disabled": $cmp.computedIconDisabledState,
          "title": $cmp.i18n.selectDate,
          "alternativeText": $cmp.i18n.selectDate
        },
        key: 9,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleDatePickerIconClick)),
          "keydown": _m7 || ($ctx._m7 = api_bind($cmp.handleDatePickerIconKeyDown)),
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleIconFocus)),
          "blur": _m9 || ($ctx._m9 = api_bind($cmp.handleIconBlur))
        }
      }, []), $cmp.isCalendarVisible ? api_custom_element("lightning-calendar", _lightningCalendar, {
        props: {
          "value": $cmp.value,
          "min": $cmp.min,
          "max": $cmp.max
        },
        key: 11,
        on: {
          "keydown": _m10 || ($ctx._m10 = api_bind($cmp.handleCalendarKeyDown)),
          "select": _m11 || ($ctx._m11 = api_bind($cmp.handleDateSelect)),
          "ready": _m12 || ($ctx._m12 = api_bind($cmp.startPositioning))
        }
      }, []) : null])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 13
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$g = lwc.registerTemplate(tmpl$f);
    tmpl$f.stylesheets = [];
    tmpl$f.stylesheetTokens = {
      hostAttribute: "lightning-datepicker_datepicker-host",
      shadowAttribute: "lightning-datepicker_datepicker"
    };

    var labelInvalidDate = 'Your entry does not match the allowed format {0}.';

    var labelRangeOverflow$1 = 'Value must be {0} or earlier.';

    var labelRangeUnderflow$1 = 'Value must be {0} or later.';

    var labelSelectDate = 'Select a date';

    function handleKeyDownOnDatePickerIcon(event, datepickerInterface) {
      switch (event.keyCode) {
        case keyCodes.enter:
        case keyCodes.space:
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.showCalendar();
          break;

        case keyCodes.escape:
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.hideCalendar();
          break;

        default:
      }
    }
    function handleBasicKeyDownBehaviour(event, datepickerInterface) {
      if (!datepickerInterface.isCalendarVisible()) {
        return;
      }

      if (event.keyCode === keyCodes.escape) {
        preventDefaultAndStopPropagation$1(event);
        datepickerInterface.hideCalendar();
      }
    }

    function preventDefaultAndStopPropagation$1(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    const i18n$6 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      selectDate: labelSelectDate
    };
    const ARIA_CONTROLS = 'aria-controls';
    const ARIA_LABEL = 'aria-label';
    const ARIA_LABELLEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$1 = 'aria-describedby';
    const DATE_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningDatePicker extends lwc.LightningElement {
      get messageWhenBadInput() {
        return this._messageWhenBadInput || this.formatString(this.i18n.invalidDate, this.dateFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this.formatString(this.i18n.rangeOverflow, this.max);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(this.i18n.rangeUnderflow, this.min);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      } // setter is required to properly trigger update


      get ariaLabel() {
        return this._ariaLabel;
      }

      set ariaLabel(val) {
        this._ariaLabel = val;
        this.synchronizeA11y();
      }

      set ariaLabelledByElement(el) {
        this._ariaLabelledBy = el;
        this.synchronizeA11y();
      }

      get ariaLabelledByElement() {
        return this._ariaLabelledBy;
      }

      set ariaControlsElement(el) {
        this._ariaControls = el;
        this.synchronizeA11y();
      }

      get ariaControlsElement() {
        return this._ariaControls;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedBy = el;
        } else {
          this._ariaDescribedBy = [el];
        }

        this.synchronizeA11y();
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedBy;
      }

      get ariaLabelledbyId() {
        return getRealDOMId(this._ariaLabelledBy);
      }

      get ariaControlsId() {
        return getRealDOMId(this.ariaControlsElement);
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY]: this.ariaLabelledbyId,
          [ARIA_DESCRIBEDBY$1]: this.computedAriaDescribedby,
          [ARIA_CONTROLS]: this.ariaControlsId,
          [ARIA_LABEL]: this._ariaLabel
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          const normalizedDate = normalizeISODate(normalizedValue, this.dateFormat);
          this._value = normalizedDate.isoValue;
          this._displayValue = normalizedDate.displayValue;
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this.connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this.connected) {
          this.inputElement.blur();
        }
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      get dateStyle() {
        return this._dateStyle;
      }

      set dateStyle(value) {
        this._dateStyle = normalizeString(value, {
          fallbackValue: DATE_STYLE.MEDIUM,
          validValues: [DATE_STYLE.SHORT, DATE_STYLE.MEDIUM, DATE_STYLE.LONG]
        });
        this.dateFormat = this.getDateFormatFromStyle(this._dateStyle);
        const normalizedDate = normalizeISODate(this._value, this.dateFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._value = null;
        this._calendarVisible = false;
        this._displayValue = null;
        this._errorMessage = '';
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this.label = void 0;
        this.name = void 0;
        this.max = void 0;
        this.min = void 0;
        this.placeholder = void 0;
        this.autocomplete = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaLabelledBy = void 0;
        this._ariaControls = void 0;
        this._ariaDescribedBy = [];
        this.uniqueId = generateUniqueId();
      }

      connectedCallback() {
        this.connected = true;
        this.keyboardInterface = this.datepickerKeyboardInterface();
        this.documentClickHandler = this.getClickHandler.bind(this);
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          if (this.connected) {
            this.dispatchEvent(new CustomEvent('blur'));
          }
        });
      }

      disconnectedCallback() {
        this.connected = false; // make sure the click handler has been removed from the document

        document.removeEventListener('click', this.documentClickHandler);
      }

      get i18n() {
        return i18n$6;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedUniqueErrorMessageElementId() {
        const el = this.template.querySelector('[data-error-message]');
        return getRealDOMId(el);
      }

      get isCalendarVisible() {
        return this._calendarVisible;
      }

      get displayValue() {
        return this._displayValue;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get computedIconDisabledState() {
        return this.disabled || this.readOnly;
      }

      get computedAriaDescribedby() {
        const ariaValues = [];

        if (this.errorMessage) {
          ariaValues.push(this.computedUniqueErrorMessageElementId);
        }

        this._ariaDescribedBy.forEach(item => {
          const id = getRealDOMId(item);

          if (id) {
            ariaValues.push(id);
          }
        });

        return normalizeAriaAttribute(ariaValues);
      }

      handleInputChange(event) {
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.currentTarget.value;
        this._value = this.parseFormattedDate(this._displayValue);
        this.dispatchChangeEvent();
      }

      handleInput() {
        // IE11 fires an input event along with the click event when the element has a placeholder.
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
        // remove this block when we stop support for IE11
        const normalizedInputValue = this.normalizeInputValue(this.inputElement.value);

        if (this._displayValue === normalizedInputValue) {
          return;
        } // keeping the display value in sync with the element's value


        this._displayValue = this.inputElement.value; // Making sure that the focus remains on the input and we're not triggering leave

        this.hideCalendarAndFocusTrigger();
      }

      handleInputFocus() {
        this.interactingState.enter();
      }

      handleInputBlur() {
        if (!this.isCalendarVisible) {
          if (this._value !== null) {
            const normalizedDate = normalizeISODate(this._value, this.dateFormat);
            this._displayValue = normalizedDate.displayValue;
          }

          this.interactingState.leave();
        }
      }

      handleInputClick(event) {
        if (this.readOnly) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showCalendar();
      }

      handleIconBlur() {
        if (!this.isCalendarVisible) {
          this.interactingState.leave();
        }
      }

      handleIconFocus() {
        this.interactingState.enter();
      }

      handleDatePickerIconClick(event) {
        if (this.readOnly || this.disabled) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showAndFocusCalendar();
      }

      handleInputKeydown(event) {
        this.calendarTrigger = event.target;
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDatePickerIconKeyDown(event) {
        this.calendarTrigger = event.target;
        handleKeyDownOnDatePickerIcon(event, this.keyboardInterface);
      }

      handleCalendarKeyDown(event) {
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDateSelect(event) {
        event.stopPropagation();
        this._value = event.detail.value;
        this._displayValue = normalizeISODate(this._value, this.dateFormat).displayValue;
        this.hideCalendarAndFocusTrigger();
        this.dispatchChangeEvent();
      }

      showAndFocusCalendar() {
        this.showCalendar();
        requestAnimationFrame(() => {
          this.focusCalendar();
        });
      }

      hideCalendarAndFocusTrigger() {
        this.hideCalendar();
        this.calendarTrigger.focus(); // in the case where the input already has focus, we should re-enter to make sure we are not triggering leave

        this.interactingState.enter();
      }

      focusCalendar() {
        const calendar = this.template.querySelector('lightning-calendar');

        if (calendar) {
          calendar.focus();
        }
      }

      startPositioning() {
        if (!this._relationship) {
          this._relationship = startPositioning(this, {
            target: () => this.template.querySelector('input'),
            element: () => this.template.querySelector('lightning-calendar').shadowRoot.querySelector('div'),
            align: {
              horizontal: Direction.Right,
              vertical: Direction.Top
            },
            targetAlign: {
              horizontal: Direction.Right,
              vertical: Direction.Bottom
            },
            autoFlip: true,
            // Auto flip direction if not have enough space
            leftAsBoundary: true // horizontal flip uses target left as boundary

          });
        } else {
          this._relationship.reposition();
        }
      }

      stopPositioning() {
        if (this._relationship) {
          stopPositioning(this._relationship);
          this._relationship = null;
        }
      }

      showCalendar() {
        if (!this.isCalendarVisible) {
          this.interactingState.enter(); // Async bind the click handler because we are currently handling a
          // click event and we don't want to immediately close the calendar.

          requestAnimationFrame(() => {
            this.addDocumentClickHandler();
          });
          this.rootElement.classList.add('slds-is-open');
          this._calendarVisible = true;
        }
      }

      hideCalendar() {
        if (this.isCalendarVisible) {
          this.removeDocumentClickHandler();
          this.rootElement.classList.remove('slds-is-open');
          this.stopPositioning();
          this._calendarVisible = false;
          this.interactingState.leave();
        }
      }

      get rootElement() {
        return this.template.querySelector('div');
      }

      get inputElement() {
        return this.template.querySelector('input');
      }

      get dateFormat() {
        if (!this._dateFormat) {
          this._dateFormat = this.getDateFormatFromStyle();
        }

        return this._dateFormat;
      }

      set dateFormat(value) {
        this._dateFormat = value;
      }

      getDateFormatFromStyle(dateStyle) {
        let dateFormat;

        switch (dateStyle) {
          case DATE_STYLE.SHORT:
            dateFormat = configProvider$1.getLocale().shortDateFormat;
            break;

          case DATE_STYLE.LONG:
            dateFormat = configProvider$1.getLocale().longDateFormat;
            break;

          default:
            dateFormat = configProvider$1.getLocale().dateFormat;
            break;
        }

        return dateFormat;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      addDocumentClickHandler() {
        document.addEventListener('click', this.documentClickHandler);
      }

      removeDocumentClickHandler() {
        document.removeEventListener('click', this.documentClickHandler);
      }

      getClickHandler(event) {
        const rootElement = this.rootElement;

        if (!rootElement.contains(event.target)) {
          this.hideCalendar();
        }
      }

      datepickerKeyboardInterface() {
        const that = this;
        return {
          showCalendar() {
            that.showAndFocusCalendar();
          },

          hideCalendar() {
            that.hideCalendarAndFocusTrigger();
          },

          isCalendarVisible() {
            return that.isCalendarVisible;
          }

        };
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return value;
      }

      parse(dateString) {
        // We cannot use parseDateTimeISO8601 here because that method does not have a strict flag. If the value is not an ISO string, that method will parse using the native Date()
        // Alternatively we could call isValidISODateTimeString and then parseDateTimeISO8601.
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      get allowedDateFormats() {
        // this method can't be static because at the time this file is interpreted,
        // getLocale don't have the injected Locale in the config provider.
        const locale = configProvider$1.getLocale(); // We should prioritize the long, because a long date matched with the medium format. An issue in aura?
        // Ex: September 8, 2017 when be parsed with the medium format, returns a valid iso date.

        return [locale.longDateFormat, locale.dateFormat, locale.shortDateFormat];
      }
      /**
       * Parses the input date and sets the dateFormat used to parse the displayValue
       * if it is a valid Date.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted date if displayValue is valid. null otherwise.
       */


      parseFormattedDate(displayValue) {
        const allowedFormats = this.allowedDateFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedDate(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        return value;
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningDatePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDatePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaLabelledByElement: {
          config: 3
        },
        ariaControlsElement: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        dateStyle: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "showHelpMessage", "hasBadInput"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _value: 1,
        _calendarVisible: 1,
        _displayValue: 1,
        _errorMessage: 1,
        _fieldLevelHelp: 1,
        _variant: 1
      }
    });

    var _lightningDatepicker = lwc.registerComponent(LightningDatePicker, {
      tmpl: _tmpl$g
    });

    function stylesheet$8(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-inline-logo" + shadowSelector + " {height: 1rem;margin-top: 1rem;margin-bottom: 1rem;}\n";
    }
    var _implicitStylesheets$8 = [stylesheet$8];

    function tmpl$g($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.state.iconName,
          "size": $cmp.size,
          "variant": $cmp.variant,
          "src": $cmp.state.src
        },
        key: 2
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.alternativeText)]) : null];
    }

    var _tmpl$h = lwc.registerTemplate(tmpl$g);
    tmpl$g.stylesheets = [];
    tmpl$g.stylesheetTokens = {
      hostAttribute: "lightning-icon_icon-host",
      shadowAttribute: "lightning-icon_icon"
    };

    /**
     * Represents a visual element that provides context and enhances usability.
     */

    class LightningIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {};
        this.alternativeText = void 0;
      }

      /**
       * A uri path to a custom svg sprite, including the name of the resouce,
       * for example: /assets/icons/standard-sprite/svg/test.svg#icon-heart
       * @type {string}
       */
      get src() {
        return this.privateSrc;
      }

      set src(value) {
        this.privateSrc = value; // if value is not present, then we set the state back
        // to the original iconName that was passed
        // this might happen if the user sets a custom icon, then
        // decides to revert back to SLDS by removing the src attribute

        if (!value) {
          this.state.iconName = this.iconName;
          this.classList.remove('slds-icon-standard-default');
        } // if isIE11 and the src is set
        // we'd like to show the 'standard:default' icon instead
        // for performance reasons.


        if (value && isIE11) {
          this.setDefault();
          return;
        }

        this.state.src = value;
      }
      /**
       * The Lightning Design System name of the icon.
       * Names are written in the format 'utility:down' where 'utility' is the category,
       * and 'down' is the specific icon to be displayed.
       * @type {string}
       * @required
       */


      get iconName() {
        return this.privateIconName;
      }

      set iconName(value) {
        this.privateIconName = value; // if src is set, we don't need to validate
        // iconName

        if (this.src) {
          return;
        }

        if (isValidName(value)) {
          const isAction = getCategory(value) === 'action'; // update classlist only if new iconName is different than state.iconName
          // otherwise classListMutation receives class:true and class: false and removes slds class

          if (value !== this.state.iconName) {
            classListMutation(this.classList, {
              'slds-icon_container_circle': isAction,
              [computeSldsClass(value)]: true,
              [computeSldsClass(this.state.iconName)]: false
            });
          }

          this.state.iconName = value;
        } else {
          console.warn(`<lightning-icon> Invalid icon name ${value}`); // eslint-disable-line no-console
          // Invalid icon names should render a blank icon. Remove any
          // classes that might have been previously added.

          classListMutation(this.classList, {
            'slds-icon_container_circle': false,
            [computeSldsClass(this.state.iconName)]: false
          });
          this.state.iconName = undefined;
        }
      }
      /**
       * The size of the icon. Options include xx-small, x-small, small, medium, or large.
       * The default is medium.
       * @type {string}
       * @default medium
       */


      get size() {
        return normalizeString(this.state.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      set size(value) {
        this.state.size = value;
      }
      /**
       * The variant changes the appearance of a utility icon.
       * Accepted variants include inverse, success, warning, and error.
       * Use the inverse variant to implement a white fill in utility icons on dark backgrounds.
       * @type {string}
       */


      get variant() {
        return normalizeVariant$1(this.state.variant, this.state.iconName);
      }

      set variant(value) {
        this.state.variant = value;
      }

      connectedCallback() {
        this.classList.add('slds-icon_container');
      }

      setDefault() {
        this.state.src = undefined;
        this.state.iconName = 'standard:default';
        this.classList.add('slds-icon-standard-default');
      }

    }

    lwc.registerDecorators(LightningIcon, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        src: {
          config: 3
        },
        iconName: {
          config: 3
        },
        size: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningIcon = lwc.registerComponent(LightningIcon, {
      tmpl: _tmpl$h
    });

    function normalizeVariant$1(variant, iconName) {
      // Unfortunately, the `bare` variant was implemented to do what the
      // `inverse` variant should have done. Keep this logic for as long as
      // we support the `bare` variant.
      if (variant === 'bare') {
        // TODO: Deprecation warning using strippable assertion
        variant = 'inverse';
      }

      if (getCategory(iconName) === 'utility') {
        return normalizeString(variant, {
          fallbackValue: '',
          validValues: ['error', 'inverse', 'warning', 'success']
        });
      }

      return 'inverse';
    }

    function tmpl$h($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator,
        f: api_flatten
      } = $api;
      return api_flatten([$cmp.hasParts ? api_iterator($cmp.text, function (item) {
        return [item.part.highlight ? api_element("strong", {
          key: api_key(5, item.key)
        }, [api_dynamic(item.part.text)]) : null, !item.part.highlight ? api_dynamic(item.part.text) : null];
      }) : [], !$cmp.hasParts ? api_dynamic($cmp.text) : null]);
    }

    var _tmpl$i = lwc.registerTemplate(tmpl$h);
    tmpl$h.stylesheets = [];
    tmpl$h.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText-host",
      shadowAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText"
    };

    class LightningBaseComboboxFormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._text = '';
        this.hasParts = void 0;
      }

      get text() {
        return this._text;
      }

      set text(value) {
        this.hasParts = Array.isArray(value) && value.length > 0;

        if (this.hasParts) {
          // Generate keys for LWC DOM
          this._text = value.map((part, i) => ({
            part,
            key: i
          }));
        } else {
          this._text = value;
        }
      }

    }

    lwc.registerDecorators(LightningBaseComboboxFormattedText, {
      publicProps: {
        text: {
          config: 3
        }
      },
      track: {
        _text: 1,
        hasParts: 1
      }
    });

    var _lightningBaseComboboxFormattedText = lwc.registerComponent(LightningBaseComboboxFormattedText, {
      tmpl: _tmpl$i
    });

    function tmpl$i($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true
        },
        key: 2
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.iconSize,
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName
        },
        key: 3
      }, [])]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 4
      }, [api_element("span", {
        classMap: {
          "slds-listbox__option-text": true,
          "slds-listbox__option-text_entity": true
        },
        key: 5
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 7
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.text,
          "text": $cmp.item.text
        },
        key: 9
      }, []) : null]), $cmp.hasSubText ? api_element("span", {
        classMap: {
          "slds-listbox__option-meta": true,
          "slds-listbox__option-meta_entity": true
        },
        key: 11
      }, [!$cmp.subTextHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.subText
        },
        key: 13
      }, [api_dynamic($cmp.item.subText)]) : null, $cmp.subTextHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.subText,
          "text": $cmp.item.subText
        },
        key: 15
      }, []) : null]) : null]), $cmp.item.rightIconName ? api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-media__figure_reverse": true
        },
        key: 17
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.rightIconSize,
          "alternativeText": $cmp.item.rightIconAlternativeText,
          "iconName": $cmp.item.rightIconName
        },
        key: 18
      }, [])]) : null];
    }

    var card = lwc.registerTemplate(tmpl$i);
    tmpl$i.stylesheets = [];
    tmpl$i.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_card-host",
      shadowAttribute: "lightning-baseComboboxItem_card"
    };

    function tmpl$j($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-listbox__option-icon": true
        },
        key: 2
      }, [$cmp.item.iconName ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName,
          "size": "x-small"
        },
        key: 4
      }, []) : null]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 5
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 7
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "text": $cmp.item.text,
          "title": $cmp.text
        },
        key: 9
      }, []) : null])];
    }

    var inline = lwc.registerTemplate(tmpl$j);
    tmpl$j.stylesheets = [];
    tmpl$j.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_inline-host",
      shadowAttribute: "lightning-baseComboboxItem_inline"
    };

    class LightningBaseComboboxItem extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.item = {};
      }

      connectedCallback() {
        // We want to make sure that the item has 'aria-selected' if it's selectable
        if (this.item.selectable) {
          this.setAttribute('aria-selected', 'false');
        }

        if (this.item.type === 'option-inline') {
          this.classList.add('slds-media_small', 'slds-listbox__option_plain');
        } else {
          this.classList.add('slds-listbox__option_entity');
        }
      }

      get textHasParts() {
        const text = this.item.text;
        return text && Array.isArray(text) && text.length > 0;
      }

      get subTextHasParts() {
        const subText = this.item.subText;
        return subText && Array.isArray(subText) && subText.length > 0;
      } // Return html based on the specified item type


      render() {
        if (this.item.type === 'option-card') {
          return card;
        }

        return inline;
      }

      highlight() {
        this.toggleHighlight(true);
      }

      removeHighlight() {
        this.toggleHighlight(false);
      }

      toggleHighlight(highlighted) {
        if (this.item.selectable) {
          this.setAttribute('aria-selected', highlighted ? 'true' : 'false');
          this.classList.toggle('slds-has-focus', highlighted);
        }
      } // Parts are needed for highlighting


      partsToText(parts) {
        if (parts && Array.isArray(parts) && parts.length > 0) {
          return parts.map(part => part.text).join('');
        }

        return parts;
      }

      get rightIconSize() {
        return this.item.rightIconSize || 'small';
      }

      get iconSize() {
        return this.item.iconSize || 'small';
      }

      get text() {
        return this.partsToText(this.item.text);
      }

      get subText() {
        return this.partsToText(this.item.subText);
      }

      get hasSubText() {
        const subText = this.item.subText;
        return subText && subText.length > 0;
      }

    }

    lwc.registerDecorators(LightningBaseComboboxItem, {
      publicProps: {
        item: {
          config: 0
        }
      },
      publicMethods: ["highlight", "removeHighlight"]
    });

    var _lightningBaseComboboxItem = lwc.registerComponent(LightningBaseComboboxItem, {
      tmpl: _tmpl$5
    });

    function tmpl$k($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("div", {
        className: $cmp.computedDropdownTriggerClass,
        attrs: {
          "role": "combobox",
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-haspopup": "listbox"
        },
        key: 2,
        on: {
          "click": _m14 || ($ctx._m14 = api_bind($cmp.handleTriggerClick))
        }
      }, [api_element("div", {
        className: $cmp.computedFormElementClass,
        attrs: {
          "role": "none"
        },
        key: 3
      }, [$cmp.hasInputPill ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-combobox__input-entity-icon": true
        },
        props: {
          "iconName": $cmp.inputPill.iconName,
          "alternativeText": $cmp.inputPill.iconAlternativeText,
          "size": "x-small"
        },
        key: 5
      }, []) : null, api_element("input", {
        className: $cmp.computedInputClass,
        attrs: {
          "id": api_scoped_id("input"),
          "type": "text",
          "role": "textbox",
          "autocomplete": "off",
          "name": $cmp.name,
          "placeholder": $cmp.computedPlaceholder,
          "maxlength": $cmp.inputMaxlength,
          "aria-autocomplete": $cmp.computedAriaAutocomplete,
          "aria-label": $cmp.inputLabel
        },
        props: {
          "value": $cmp.computedInputValue,
          "disabled": $cmp.disabled,
          "readOnly": $cmp._inputReadOnly
        },
        key: 6,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleInputSelect)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleTextChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeyDown)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur))
        }
      }, []), $cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 8
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        attrs: {
          "type": "button",
          "title": $cmp.i18n.pillCloseButtonAlternativeText
        },
        key: 9,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handlePillRemove))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 10
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 11
      }, [api_dynamic($cmp.i18n.pillCloseButtonAlternativeText)])])]) : null, !$cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 13
      }, [$cmp.showInputActivityIndicator ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 15
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 16
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 17
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 18
      }, [])]) : null, $cmp.inputIconName ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "alternativeText": $cmp.inputIconAlternativeText,
          "iconName": $cmp.inputIconName,
          "size": $cmp.inputIconSize
        },
        key: 20
      }, []) : null]) : null]), api_element("div", {
        className: $cmp.computedDropdownClass,
        attrs: {
          "id": api_scoped_id("dropdown-element"),
          "data-dropdown-element": true,
          "role": "listbox"
        },
        key: 21,
        on: {
          "scroll": _m9 || ($ctx._m9 = api_bind($cmp.handleListboxScroll)),
          "mousedown": _m10 || ($ctx._m10 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m12 || ($ctx._m12 = api_bind($cmp.handleDropdownMouseLeave)),
          "click": _m13 || ($ctx._m13 = api_bind($cmp.handleOptionClick))
        }
      }, $cmp._hasDropdownOpened ? api_flatten([api_iterator($cmp._items, function (item) {
        return [!item.items ? api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-media_center": true
          },
          attrs: {
            "data-item-id": item.id,
            "data-value": item.value
          },
          props: {
            "role": "option",
            "item": item,
            "id": api_scoped_id(item.id)
          },
          key: api_key(25, item.value),
          on: {
            "mouseenter": _m7 || ($ctx._m7 = api_bind($cmp.handleOptionMouseEnter))
          }
        }, []) : null, item.items ? api_element("ul", {
          attrs: {
            "role": "group",
            "aria-label": item.label
          },
          key: api_key(27, item.label)
        }, api_flatten([item.label ? api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 29
        }, [api_element("div", {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-listbox__option_plain": true,
            "slds-media_small": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 30
        }, [api_element("h3", {
          classMap: {
            "slds-text-title_caps": true
          },
          attrs: {
            "role": "presentation",
            "title": item.label
          },
          key: 31
        }, [api_dynamic(item.label)])])]) : null, api_iterator(item.items, function (groupItem) {
          return api_element("li", {
            classMap: {
              "slds-listbox__item": true
            },
            attrs: {
              "role": "presentation"
            },
            key: api_key(33, groupItem.value)
          }, [api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
            classMap: {
              "slds-media": true,
              "slds-listbox__option": true,
              "slds-media_center": true
            },
            attrs: {
              "data-item-id": groupItem.id,
              "data-value": groupItem.value
            },
            props: {
              "role": "option",
              "item": groupItem,
              "id": api_scoped_id(groupItem.id)
            },
            key: 34,
            on: {
              "mouseenter": _m8 || ($ctx._m8 = api_bind($cmp.handleOptionMouseEnter))
            }
          }, [])]);
        })])) : null];
      }), $cmp.showDropdownActivityIndicator ? api_element("div", {
        classMap: {
          "slds-listbox__item": true
        },
        attrs: {
          "role": "presentation"
        },
        key: 36
      }, [api_element("div", {
        classMap: {
          "slds-align_absolute-center": true,
          "slds-p-top_medium": true
        },
        key: 37
      }, [api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_x-small": true,
          "slds-spinner_inline": true
        },
        attrs: {
          "role": "status"
        },
        key: 38
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 39
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 40
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 41
      }, [])])])]) : null, $cmp.showAttribution ? api_element("div", {
        classMap: {
          "slds-align_absolute-center": true
        },
        key: 43
      }, [api_element("img", {
        classMap: {
          "slds-inline-logo": true
        },
        attrs: {
          "src": $cmp.attributionLogoUrl,
          "alt": $cmp.attributionLogoAssistiveText,
          "title": $cmp.attributionLogoAssistiveText
        },
        key: 44
      }, [])]) : null]) : [])])];
    }

    var _tmpl$j = lwc.registerTemplate(tmpl$k);
    tmpl$k.stylesheets = [];

    if (_implicitStylesheets$8) {
      tmpl$k.stylesheets.push.apply(tmpl$k.stylesheets, _implicitStylesheets$8);
    }
    tmpl$k.stylesheetTokens = {
      hostAttribute: "lightning-baseCombobox_baseCombobox-host",
      shadowAttribute: "lightning-baseCombobox_baseCombobox"
    };

    var labelAriaSelectedOptions = 'Selected Options:';

    var labelDeselectOptionKeyboard = 'Press delete or backspace to remove';

    var labelLoadingText = 'Loading';

    var labelPillCloseButtonAlternativeText = 'Clear Selection';

    function preventDefaultAndStopPropagation$2(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function handleEnterKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (dropdownInterface.isDropdownVisible() && currentIndex >= 0) {
        dropdownInterface.selectByIndex(currentIndex);
      } else {
        dropdownInterface.openDropdownIfNotEmpty();
      }
    }

    function handlePageUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const pageUpDownOptionSkipCount = 10;

      if (dropdownInterface.getTotalOptions() > 0) {
        requestAnimationFrame(() => {
          let highlightIndex = 0;

          if (event.key === 'PageUp') {
            highlightIndex = Math.max(currentIndex - pageUpDownOptionSkipCount, 0);
          } else {
            // Jump 10 options down
            highlightIndex = Math.min(currentIndex + pageUpDownOptionSkipCount, dropdownInterface.getTotalOptions() - 1);
          }

          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleHomeOrEndKey({
      event,
      dropdownInterface
    }) {
      // If not a read-only input we want the default browser behaviour
      if (!dropdownInterface.isInputReadOnly()) {
        return;
      }

      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        requestAnimationFrame(() => {
          const highlightIndex = event.key === 'Home' ? 0 : dropdownInterface.getTotalOptions() - 1;
          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const isUpKey = event.key === 'Up' || event.key === 'ArrowUp';
      let nextIndex;

      if (currentIndex >= 0) {
        nextIndex = isUpKey ? currentIndex - 1 : currentIndex + 1;

        if (nextIndex >= dropdownInterface.getTotalOptions()) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = dropdownInterface.getTotalOptions() - 1;
        }
      } else {
        nextIndex = isUpKey ? dropdownInterface.getTotalOptions() - 1 : 0;
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        requestAnimationFrame(() => {
          dropdownInterface.highlightOptionWithIndex(nextIndex);
        });
      }
    }

    function handleEscapeOrTabKey({
      event,
      dropdownInterface
    }) {
      if (dropdownInterface.isDropdownVisible()) {
        event.stopPropagation();
        dropdownInterface.closeDropdown();
      }
    }

    function handleTypedCharacters({
      event,
      currentIndex,
      dropdownInterface
    }) {
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.isInputReadOnly()) {
        // The element should be read only, it's a work-around for IE11 as it will still make editable an input
        // that has focus and was dynamically changed to be readonly on focus change. Remove once we no longer
        // support IE11
        event.preventDefault();
        requestAnimationFrame(() => runActionOnBufferedTypedCharacters(event, dropdownInterface.highlightOptionWithText.bind(this, currentIndex || 0)));
      }
    }

    const eventKeyToHandlerMap = {
      Enter: handleEnterKey,
      PageUp: handlePageUpOrDownKey,
      PageDown: handlePageUpOrDownKey,
      Home: handleHomeOrEndKey,
      End: handleHomeOrEndKey,
      Down: handleUpOrDownKey,
      // IE11/Edge specific
      Up: handleUpOrDownKey,
      // IE11/Edge specific
      ArrowUp: handleUpOrDownKey,
      ArrowDown: handleUpOrDownKey,
      Esc: handleEscapeOrTabKey,
      // IE11/Edge specific
      Escape: handleEscapeOrTabKey,
      Tab: handleEscapeOrTabKey
    };
    function handleKeyDownOnInput({
      event,
      currentIndex,
      dropdownInterface
    }) {
      const parameters = {
        event,
        currentIndex,
        dropdownInterface
      };

      if (eventKeyToHandlerMap[event.key]) {
        eventKeyToHandlerMap[event.key](parameters);
      } else {
        handleTypedCharacters(parameters);
      }
    }

    class BaseComboboxEvents {
      constructor(baseCombobox) {
        this.dispatchEvent = baseCombobox.dispatchEvent.bind(baseCombobox);
      }

      dispatchPillRemove(pill) {
        this.dispatchEvent(new CustomEvent('pillremove', {
          detail: {
            item: pill
          }
        }));
      }

      dispatchEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      dispatchFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      dispatchBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchTextInput(text) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text
          }
        }));
      }

      dispatchTextChange(text) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text
          }
        }));
      }

      dispatchSelect(value) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      }

      dispatchDropdownOpen() {
        this.dispatchEvent(new CustomEvent('dropdownopen'));
      }

      dispatchDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

    }

    const i18n$7 = {
      ariaSelectedOptions: labelAriaSelectedOptions,
      deselectOptionKeyboard: labelDeselectOptionKeyboard,
      pillCloseButtonAlternativeText: labelPillCloseButtonAlternativeText,
      loadingText: labelLoadingText
    };
    const SMALL_MIN_HEIGHT = '2.25rem';
    const MEDIUM_MIN_HEIGHT = '6.75rem';
    const ARIA_CONTROLS$1 = 'aria-controls';
    const ARIA_LABELLEDBY$1 = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$2 = 'aria-describedby';
    const ARIA_LABEL$1 = 'aria-label';
    const ARIA_ACTIVEDESCENDANT = 'aria-activedescendant';

    class LightningBaseCombobox extends lwc.LightningElement {
      constructor() {
        super();
        this.inputText = '';
        this.inputIconName = 'utility:down';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showInputActivityIndicator = false;
        this.dropdownAlignment = 'left';
        this.placeholder = 'Select an Item';
        this.inputLabel = void 0;
        this.name = void 0;
        this.inputPill = void 0;
        this.attributionLogoUrl = void 0;
        this.attributionLogoAssistiveText = void 0;
        this._showDropdownActivityIndicator = false;
        this._items = [];
        this._disabled = false;
        this._dropdownVisible = false;
        this._hasDropdownOpened = false;
        this._highlightedOptionElementId = null;
        this._variant = void 0;
        this._dropdownHeight = 'standard';
        this._readonly = false;
        this._logoLoaded = false;
        this._inputDescribedBy = [];
        this._inputAriaControls = void 0;
        this._activeElementDomId = void 0;
        this._events = new BaseComboboxEvents(this);
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready', {
          detail: {
            id: this.inputId,
            name: this.name
          }
        }));
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-combobox_container');
        this._connected = true;
        this._keyboardInterface = this.dropdownKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
        this._listBoxElementCache = undefined;
      }

      get inputControlsElement() {
        return this._inputAriaControls;
      }

      set inputControlsElement(el) {
        this._inputAriaControls = el;
        this.synchronizeA11y();
      }

      get inputDescribedByElements() {
        return this._inputDescribedBy;
      }

      set inputDescribedByElements(elements) {
        if (Array.isArray(elements)) {
          this._inputDescribedBy = elements;
        } else {
          this._inputDescribedBy = [elements];
        }

        this.synchronizeA11y();
      }

      get inputLabelledByElement() {
        return this._inputLabelledBy;
      }

      set inputLabelledByElement(el) {
        this._inputLabelledBy = el;
        this.synchronizeA11y();
      }

      get inputLabelledById() {
        return getRealDOMId(this._inputLabelledBy);
      }

      get inputAriaControlsId() {
        return getRealDOMId(this._inputAriaControls);
      }

      get inputId() {
        return getRealDOMId(this.template.querySelector('input'));
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        this._inputDescribedBy.forEach(el => {
          ariaValues.push(getRealDOMId(el));
        });

        return normalizeAriaAttribute(ariaValues);
      }

      get dropdownHeight() {
        return this._dropdownHeight;
      }

      set dropdownHeight(height) {
        this._dropdownHeight = normalizeString(height, {
          fallbackValue: 'standard',
          validValues: ['standard', 'small']
        });
      }

      get showDropdownActivityIndicator() {
        return this._showDropdownActivityIndicator;
      }

      set showDropdownActivityIndicator(value) {
        this._showDropdownActivityIndicator = normalizeBoolean(value);

        if (this._connected) {
          if (this._showDropdownActivityIndicator) {
            if (this._shouldOpenDropDown) {
              this.openDropdownIfNotEmpty();
            }
          } else if (this._dropdownVisible && this.isDropdownEmpty) {
            this.closeDropdown();
          }
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: VARIANT.STANDARD,
          validValues: [VARIANT.STANDARD, 'lookup']
        });
      }

      get items() {
        return this._unprocessedItems;
      }

      set items(items = []) {
        this._unprocessedItems = items;

        if (this._connected) {
          if (this._hasDropdownOpened) {
            // The dropdown has already been opened at least once, so process the items immediately
            this.updateItems(items);

            if (this._dropdownVisible) {
              // The dropdown is visible but there are no items to show, close it
              if (this.isDropdownEmpty) {
                this.closeDropdown();
              } else {
                // We have new items, update highlight
                this.highlightDefaultItem(); // Since the items have changed, the positioning should be recomputed

                this.startDropdownAutoPositioning();
              }
            }
          }

          if (this._shouldOpenDropDown) {
            this.openDropdownIfNotEmpty();
          }
        }
      }

      highlightInputText() {
        if (this._connected) {
          // Safari has issues with invoking set selection range immediately in the 'focus' handler, instead
          // we'd be doing it in an animation frame. Remove the requestAnimationFrame once/if this is fixed
          // in Safari
          requestAnimationFrame(() => {
            const {
              inputElement
            } = this;
            inputElement.setSelectionRange(0, inputElement.value.length);
          });
        }
      }

      get showAttribution() {
        return this.attributionLogoUrl;
      }

      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          if (!this._inputHasFocus) {
            this.focus();
          }

          this.openDropdownIfNotEmpty();
        }
      }

      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY$1]: this.inputLabelledById,
          [ARIA_DESCRIBEDBY$2]: this.computedAriaDescribedBy,
          [ARIA_ACTIVEDESCENDANT]: this._activeElementDomId,
          [ARIA_CONTROLS$1]: this.computedInputControls,
          [ARIA_LABEL$1]: this.inputLabel
        });
      }

      itemId(index) {
        return this.inputId + '-' + index;
      }

      itemIndexFromId(id) {
        // Extracts the index from an item id.
        return parseInt(id.substring(id.lastIndexOf('-') + 1), 10);
      }

      processItem(item) {
        const itemCopy = {}; // Supported item properties:
        // 'type' (string): option-inline, option-card
        // 'highlight' (boolean): Whether to highlight the item when dropdown opens
        // 'iconName': left icon name
        // 'iconSize': left icon size
        // 'iconAlternativeText': assistive text for the left icon
        // 'rightIconName': right icon name
        // 'rightIconSize': right icon size
        // 'rightIconAlternativeText': assistive text for the right icon
        // 'text': text to display
        // 'subText': sub-text to display (only option-card supports it)
        // 'value': value associated with the option

        itemCopy.type = item.type;
        itemCopy.iconName = item.iconName;
        itemCopy.iconSize = item.iconSize;
        itemCopy.iconAlternativeText = item.iconAlternativeText;
        itemCopy.rightIconName = item.rightIconName;
        itemCopy.rightIconSize = item.rightIconSize;
        itemCopy.rightIconAlternativeText = item.rightIconAlternativeText;
        itemCopy.text = item.text;
        itemCopy.subText = item.subText;
        itemCopy.value = item.value; // extra metadata needed

        itemCopy.selectable = ['option-card', 'option-inline'].indexOf(item.type) >= 0;

        if (itemCopy.selectable) {
          itemCopy.index = this._selectableItems;
          itemCopy.id = this.itemId(itemCopy.index);
          this._selectableItems += 1;

          if (item.highlight) {
            this._highlightedItemIndex = itemCopy.index;
          }
        }

        return itemCopy;
      }

      get _inputReadOnly() {
        return this._readonly || this.variant === VARIANT.STANDARD || this.hasInputPill;
      }

      get computedAriaAutocomplete() {
        if (this.hasInputPill) {
          // no aria-autocomplete when pill is showing
          return null;
        }

        return this._inputReadOnly ? 'none' : 'list';
      }

      get computedPlaceholder() {
        return this.hasInputPill ? this.inputPill.label : this.placeholder;
      }

      get computedInputValue() {
        return this.hasInputPill ? this.inputPill.label : this.inputText;
      }

      handleListboxScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
        const listbox = event.target;
        const height = listbox.getBoundingClientRect().height;
        const maxScroll = listbox.scrollHeight - height;
        const bottomReached = listbox.scrollTop >= maxScroll;

        if (bottomReached) {
          this._events.dispatchEndReached();
        }
      }

      get listboxElement() {
        if (!this._listBoxElementCache) {
          this._listBoxElementCache = this.template.querySelector('[role="listbox"]');
        }

        return this._listBoxElementCache;
      }

      get computedUniqueElementId() {
        return this.inputId;
      }

      get computedUniqueDropdownElementId() {
        return getRealDOMId(this.template.querySelector('[data-dropdown-element]'));
      }

      get computedInputControls() {
        const ariaValues = [this.computedUniqueDropdownElementId];

        if (this.inputControlsElement) {
          ariaValues.push(this.inputAriaControlsId);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get i18n() {
        return i18n$7;
      }

      get computedDropdownTriggerClass() {
        return classSet('slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click').add({
          'slds-is-open': this._dropdownVisible
        }).toString();
      }

      get computedDropdownClass() {
        const alignment = this.dropdownAlignment;
        return classSet('slds-listbox slds-listbox_vertical slds-dropdown slds-dropdown_fluid').add({
          'slds-dropdown_length-with-icon-10': this._dropdownHeight === 'standard',
          'slds-dropdown_length-with-icon-5': this._dropdownHeight === 'small',
          'slds-dropdown_left': alignment === 'left' || alignment === 'auto',
          'slds-dropdown_center': alignment === 'center',
          'slds-dropdown_right': alignment === 'right',
          'slds-dropdown_bottom': alignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': alignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': alignment === 'bottom-left'
        }).toString();
      }

      get computedInputClass() {
        const classes = classSet('slds-input slds-combobox__input');

        if (this.hasInputPill) {
          classes.add('slds-combobox__input-value');
        } else {
          classes.add({
            'slds-input-has-icon_group-right': this.showInputActivityIndicator
          });
        }

        return classes.toString();
      }

      get _shouldOpenDropDown() {
        // If items were empty and through a user interaction the dropdown should have opened, and if the
        // component still has the focus we'll open it on items update instead.
        return !this.dropdownDisabled && this._inputHasFocus && this._requestedDropdownOpen;
      }

      get dropdownDisabled() {
        return this.readOnly || this.disabled;
      }

      handleOptionClick(event) {
        if (event.target.hasAttribute('aria-selected')) {
          event.stopPropagation();
          event.preventDefault();
          this.selectOptionAndCloseDropdown(event.target);
        }
      }

      handleOptionMouseEnter(event) {
        if (event.target.hasAttribute('aria-selected')) {
          this.highlightOption(event.target);
        }
      }

      handleDropdownMouseLeave() {
        this.removeHighlight(); // This is to account for when a user makes a mousedown press on the dropdown and then leaves the dropdown
        // area, it would leave the dropdown open even though the focus would no longer be on the input

        if (!this._inputHasFocus) {
          this.closeDropdown();
        }
      }

      handleTriggerClick(event) {
        event.stopPropagation();
        this.allowBlur();

        if (this.dropdownDisabled) {
          return;
        }

        if (!this.hasInputPill) {
          // toggle dropdown only for readonly combobox, only open the dropdown otherwise
          // if it's not already opened.
          if (this._inputReadOnly) {
            if (this._dropdownVisible) {
              this.closeDropdown();
            } else {
              this.openDropdownIfNotEmpty();
            }
          } else {
            this.openDropdownIfNotEmpty();
          }

          this.inputElement.focus();
        }
      }

      handlePillKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        } // 'Del' is IE11 specific, remove once IE11 is no longer supported


        if (event.key === 'Delete' || event.key === 'Del') {
          this.handlePillRemove();
        }
      }

      handleInputKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        }

        if (this.hasInputPill) {
          this.handlePillKeyDown(event);
        } else {
          handleKeyDownOnInput({
            event,
            currentIndex: this.getCurrentHighlightedOptionIndex(),
            dropdownInterface: this._keyboardInterface
          });
        }
      }

      handleTextChange() {
        this._events.dispatchTextChange(this.inputElement.value);
      }

      handleFocus() {
        this._inputHasFocus = true;

        this._events.dispatchFocus();
      }

      handleInput() {
        this._events.dispatchTextInput(this.inputElement.value);
      }

      handleBlur() {
        this._inputHasFocus = false;

        if (this._cancelBlur) {
          return;
        }

        this.closeDropdown();

        this._events.dispatchBlur();
      }

      handleDropdownMouseDown(event) {
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }

      highlightOption(option) {
        this.removeHighlight();

        if (option) {
          option.highlight();
          this._highlightedOptionElement = option;
          this._highlightedOptionElementId = option.getAttribute('data-item-id'); // active element is a component id getter works properly

          this._activeElementDomId = option.id;
        }

        this.synchronizeA11y();
      }

      highlightOptionAndScrollIntoView(optionElement) {
        if (this._selectableItems.length === 0 || !optionElement) {
          return;
        }

        this.highlightOption(optionElement);
        scrollIntoViewIfNeeded(optionElement, this.listboxElement);
      }

      removeHighlight() {
        const option = this._highlightedOptionElement;

        if (option) {
          option.removeHighlight();
          this._highlightedOptionElement = null;
          this._highlightedOptionElementId = null;
          this._activeElementDomId = null;
        }
      }

      selectOptionAndCloseDropdown(optionElement) {
        this.closeDropdown();
        this.inputElement.focus();
        const value = optionElement.getAttribute('data-value');

        this._events.dispatchSelect(value);
      }

      handleInputSelect(event) {
        event.stopPropagation();
      }

      openDropdownIfNotEmpty() {
        if (this._dropdownVisible) {
          // Already visible
          return;
        }

        const noOptions = !Array.isArray(this.items) || this.items.length === 0;

        if (noOptions) {
          // Dispatch dropdown open request
          this._events.dispatchDropdownOpenRequest();
        } // Do not open if there's nothing to show in the dropdown (eg. no options and no dropdown activity indicator)


        if (this.isDropdownEmpty) {
          // We use this attribute to flag whether an attempt has been made via user-interaction
          // to open the dropdown
          this._requestedDropdownOpen = true;
          return;
        }

        if (!this._hasDropdownOpened) {
          if (this._unprocessedItems) {
            this.updateItems(this._unprocessedItems);
          }

          this._hasDropdownOpened = true;
        }

        this._requestedDropdownOpen = false;
        this._dropdownVisible = true;
        this.startDropdownAutoPositioning();
        this.highlightDefaultItem();

        this._events.dispatchDropdownOpen();
      }

      closeDropdown() {
        if (!this._dropdownVisible) {
          // Already closed
          return;
        }

        this.stopDropdownPositioning();
        this.removeHighlight();
        this._dropdownVisible = false;
      }

      findOptionElementByIndex(index) {
        return this.template.querySelector(`[data-item-id="${this.itemId(index)}"]`);
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      getCurrentHighlightedOptionIndex() {
        if (this._highlightedOptionElementId && this._highlightedOptionElementId.length > 0) {
          return this.itemIndexFromId(this._highlightedOptionElementId);
        }

        return -1;
      }

      get inputElement() {
        return this.template.querySelector('input');
      }

      startDropdownAutoPositioning() {
        if (this.dropdownAlignment !== 'auto') {
          return;
        }

        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('input'),
          element: () => this.template.querySelector('div.slds-dropdown'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true,
          alignWidth: true,
          autoShrinkHeight: true,
          minHeight: this.isDropdownHeightSmall ? SMALL_MIN_HEIGHT : MEDIUM_MIN_HEIGHT
        });
      }

      stopDropdownPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      get hasInputPill() {
        return this.inputPill && Object.keys(this.inputPill).length > 0;
      }

      handlePillRemove() {
        this.inputElement.focus();

        this._events.dispatchPillRemove(this.inputPill);
      }

      get computedFormElementClass() {
        const hasIcon = this.hasInputPill && this.inputPill.iconName;
        return classSet('slds-combobox__form-element slds-input-has-icon').add({
          'slds-input-has-icon_right': !hasIcon,
          'slds-input-has-icon_left-right': hasIcon
        }).toString();
      }

      get computedAriaExpanded() {
        return this._dropdownVisible ? 'true' : 'false';
      }

      updateItems(items) {
        if (!items) {
          return;
        }

        assert(Array.isArray(items), '"items" must be an array');
        this._selectableItems = 0;
        this._highlightedItemIndex = 0;
        this._items = items.map(item => {
          if (item.items) {
            // This is a group
            const groupCopy = {
              label: item.label
            };
            groupCopy.items = item.items.map(groupItem => {
              return this.processItem(groupItem);
            });
            return groupCopy;
          }

          return this.processItem(item);
        });
      }

      highlightDefaultItem() {
        this.removeHighlight();
        requestAnimationFrame(() => {
          this.highlightOptionAndScrollIntoView(this.findOptionElementByIndex(this._highlightedItemIndex));
        });
      }

      get isDropdownEmpty() {
        // If the activity indicator is showing then it's not empty
        return !this.showDropdownActivityIndicator && (!Array.isArray(this.items) || this.items.length === 0);
      }

      get isDropdownHeightSmall() {
        if (this.isDropdownEmpty) {
          return true;
        } // Check how many items could be present in dropdown.
        // >= 3, will be have MEDIUM_MIN_HEIGHT
        // < 3, will be have SMALL_MIN_HEIGHT


        let count = this._items ? this._items.length : 0;

        if (count === 1) {
          count += this._items[0].items ? this._items[0].items.length : 0;
        } else if (count === 2) {
          count += this._items[0].items ? this._items[0].items.length : 0;
          count += this._items[1].items ? this._items[1].items.length : 0;
        }

        return count < 3;
      }

      dropdownKeyboardInterface() {
        const that = this;
        return {
          getTotalOptions() {
            return that._selectableItems;
          },

          selectByIndex(index) {
            that.selectOptionAndCloseDropdown(that.findOptionElementByIndex(index));
          },

          highlightOptionWithIndex(index) {
            that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
          },

          isInputReadOnly() {
            return that._inputReadOnly;
          },

          highlightOptionWithText(currentIndex, text) {
            // This only supports a flat structure, groups are not supported
            for (let index = currentIndex + 1; index < that._items.length; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }

            for (let index = 0; index < currentIndex; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }
          },

          isDropdownVisible() {
            return that._dropdownVisible;
          },

          openDropdownIfNotEmpty() {
            that.openDropdownIfNotEmpty();
          },

          closeDropdown() {
            that.closeDropdown();
          }

        };
      }

    }

    LightningBaseCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningBaseCombobox, {
      publicProps: {
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showInputActivityIndicator: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        inputLabel: {
          config: 0
        },
        name: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        attributionLogoUrl: {
          config: 0
        },
        attributionLogoAssistiveText: {
          config: 0
        },
        inputControlsElement: {
          config: 3
        },
        inputDescribedByElements: {
          config: 3
        },
        inputLabelledByElement: {
          config: 3
        },
        dropdownHeight: {
          config: 3
        },
        showDropdownActivityIndicator: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur"],
      track: {
        _showDropdownActivityIndicator: 1,
        _items: 1,
        _disabled: 1,
        _dropdownVisible: 1,
        _hasDropdownOpened: 1,
        _highlightedOptionElementId: 1,
        _variant: 1,
        _dropdownHeight: 1,
        _readonly: 1,
        _logoLoaded: 1
      }
    });

    var _lightningBaseCombobox = lwc.registerComponent(LightningBaseCombobox, {
      tmpl: _tmpl$j
    });

    function scrollIntoViewIfNeeded(element, scrollingParent) {
      const parentRect = scrollingParent.getBoundingClientRect();
      const findMeRect = element.getBoundingClientRect();

      if (findMeRect.top < parentRect.top) {
        if (element.offsetTop + findMeRect.height < parentRect.height) {
          // If element fits by scrolling to the top, then do that
          scrollingParent.scrollTop = 0;
        } else {
          // Otherwise, top align the element
          scrollingParent.scrollTop = element.offsetTop;
        }
      } else if (findMeRect.bottom > parentRect.bottom) {
        // bottom align the element
        scrollingParent.scrollTop += findMeRect.bottom - parentRect.bottom;
      }
    }

    function tmpl$l($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "dropdownHeight": "small",
          "name": $cmp.name,
          "variant": "lookup",
          "placeholder": $cmp.placeholder,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "items": $cmp.items,
          "inputText": $cmp.displayValue,
          "inputIconName": "utility:clock",
          "inputLabel": $cmp.ariaLabel,
          "inputControlsElement": $cmp.ariaControlsElement,
          "inputLabelledByElement": $cmp.ariaLabelledByElement,
          "dropdownAlignment": "auto"
        },
        key: 7,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleReady)),
          "textchange": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "textinput": _m2 || ($ctx._m2 = api_bind($cmp.handleTextInput)),
          "dropdownopenrequest": _m3 || ($ctx._m3 = api_bind($cmp.handleDropdownOpenRequest)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "select": _m6 || ($ctx._m6 = api_bind($cmp.handleTimeSelect))
        }
      }, [])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 9
      }, [api_dynamic($cmp._errorMessage)]) : null];
    }

    var _tmpl$k = lwc.registerTemplate(tmpl$l);
    tmpl$l.stylesheets = [];
    tmpl$l.stylesheetTokens = {
      hostAttribute: "lightning-timepicker_timepicker-host",
      shadowAttribute: "lightning-timepicker_timepicker"
    };

    /* returns the closes time in the list that should be highlighted in case the value is not in the list. E.g.
    - if value is 16:18 and the list has 15 minute intervals, returns 16:30
    */

    function getTimeToHighlight(value, step) {
      const selectedTime = parseTime(value);

      if (!selectedTime) {
        return null;
      }

      selectedTime.setSeconds(0, 0);
      let closestHour = selectedTime.getHours();
      let closestMinute = selectedTime.getMinutes();
      const mod = closestMinute % step;
      const quotient = Math.floor(closestMinute / step);

      if (mod !== 0) {
        const multiplier = mod < step / 2 ? quotient : quotient + 1;
        closestMinute = multiplier * step;

        if (closestMinute >= 60) {
          if (closestHour === 23) {
            closestMinute -= step;
          } else {
            closestMinute = 0;
            closestHour++;
          }
        }

        selectedTime.setHours(closestHour);
        selectedTime.setMinutes(closestMinute);
      }

      return formatTime(selectedTime, STANDARD_TIME_FORMAT);
    }

    const i18n$8 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired
    };
    const STEP = 15; // in minutes

    const TIME_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningTimePicker extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._disabled = false;
        this._required = false;
        this._displayValue = null;
        this._value = null;
        this._items = [];
        this._fieldLevelHelp = void 0;
        this._variant = 'lookup';
        this._mainInputId = void 0;
        this._errorMessage = void 0;
        this._readonly = true;
        this._describedByElements = [];
        this.label = void 0;
        this.name = void 0;
        this.max = void 0;
        this.min = void 0;
        this.placeholder = '';
        this.ariaLabelledByElement = void 0;
        this.ariaControlsElement = void 0;
        this.ariaLabel = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaDescribedByElements = void 0;
      }

      get messageWhenBadInput() {
        return this._messageWhenBadInput || this.formatString(i18n$8.invalidDate, this.timeFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        // using isoValue since the manually entered time could have seconds/milliseconds and the locale format generally doesn't have this precision
        return this._messageWhenRangeOverflow || this.formatString(i18n$8.rangeOverflow, normalizeISOTime(this.max, this.timeFormat).isoValue);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(i18n$8.rangeUnderflow, normalizeISOTime(this.min, this.timeFormat).isoValue);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedByElements = el;
        } else {
          this.ariaDescribedByElements = [el];
        }
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedByElements;
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          const normalizedTime = normalizeISOTime(normalizedValue, this.timeFormat);
          this._value = normalizedTime.isoValue;
          this._displayValue = normalizedTime.displayValue;
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly) {
          this._variant = VARIANT.STANDARD;
        }
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this.connected) {
          this.getCombobox().focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this.connected) {
          this.getCombobox().blur();
        }
      }

      get timeStyle() {
        return this._timeStyle;
      }

      set timeStyle(value) {
        this._timeStyle = normalizeString(value, {
          fallbackValue: TIME_STYLE.SHORT,
          validValues: [TIME_STYLE.SHORT, TIME_STYLE.MEDIUM, TIME_STYLE.LONG]
        });
        this.timeFormat = this.getTimeFormatFromStyle(this._timeStyle);
        const normalizedDate = normalizeISOTime(this._value, this.timeFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      connectedCallback() {
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      synchronizeA11y() {
        const label = this.template.querySelector('label');
        const comboBox = this.template.querySelector('lightning-base-combobox');
        let describedByElements = [];

        if (this._ariaDescribedByElements) {
          describedByElements = describedByElements.concat(this._ariaDescribedByElements);
        }

        const errorMessage = this.template.querySelector('[data-error-message]');

        if (errorMessage) {
          describedByElements.push(errorMessage);
        }

        comboBox.inputDescribedByElements = describedByElements;
        synchronizeAttrs(label, {
          for: this._mainInputId
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get displayValue() {
        return this._displayValue;
      }

      get items() {
        return this._items;
      }

      get i18n() {
        return i18n$8;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleReady(e) {
        this._mainInputId = e.detail.id;
      }

      buildTimeList() {
        // We should always display the options in the short style since m/l will add an extra :00 to the options.
        const optionsTimeFormat = configProvider$1.getLocale().shortTimeFormat;
        const timeList = [];
        const minTime = parseTime(this.normalizeInputValue(this.min));
        const minHour = minTime ? minTime.getHours() : 0;
        const maxTime = parseTime(this.normalizeInputValue(this.max));
        const maxHour = maxTime ? maxTime.getHours() + 1 : 24;
        const date = new Date();

        for (let hour = minHour; hour < maxHour; hour++) {
          for (let minutes = 0; minutes < 60; minutes += STEP) {
            date.setHours(hour, minutes);
            date.setSeconds(0, 0);

            if (this.isBeforeMinTime(date, minTime)) {
              continue; // eslint-disable-line no-continue
            }

            if (this.isAfterMaxTime(date, maxTime)) {
              break;
            } // @todo: should we always display it short in the combobox given that it makes no sense?


            timeList.push({
              type: 'option-inline',
              text: this.format(date, optionsTimeFormat),
              value: this.format(date)
            });
          }
        }

        return timeList;
      }

      get timeList() {
        if (!this._timeList) {
          this._timeList = this.buildTimeList();
        }

        if (!this._value) {
          return this._timeList;
        }

        const timeToHighlight = getTimeToHighlight(this._value, STEP);

        const timeList = this._timeList.map(item => {
          const itemCopy = Object.assign({}, item);

          if (item.value === this._value) {
            itemCopy.iconName = 'utility:check';
          }

          if (item.value === timeToHighlight) {
            itemCopy.highlight = true;
          }

          return itemCopy;
        });

        return timeList;
      }

      get timeFormat() {
        if (!this._timeFormat) {
          this._timeFormat = this.getTimeFormatFromStyle();
        }

        return this._timeFormat;
      }

      set timeFormat(value) {
        this._timeFormat = value;
      }

      getCombobox() {
        return this.template.querySelector('lightning-base-combobox');
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleInputChange(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
        this._value = this.parseFormattedTime(this._displayValue);
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleTextInput(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
      }

      handleTimeSelect(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from grouped-combobox

        if (!event.detail) {
          return;
        }

        this._value = event.detail.value;
        this._displayValue = normalizeISOTime(this._value, this.timeFormat).displayValue;
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleDropdownOpenRequest() {
        this._items = this.timeList;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return removeTimeZoneSuffix(value);
      }

      format(date, formatString) {
        return formatTime(date, formatString || STANDARD_TIME_FORMAT);
      }

      isBeforeMinTime(date, minTime) {
        const minDate = minTime || parseTime(this.normalizeInputValue(this.min));
        return minDate ? isBefore(date, minDate, 'minute') : false;
      }

      isAfterMaxTime(date, maxTime) {
        const maxDate = maxTime || parseTime(this.normalizeInputValue(this.max));
        return maxDate ? isAfter(date, maxDate, 'minute') : false;
      }

      getTimeFormatFromStyle(timeStyle) {
        let timeFormat;

        switch (timeStyle) {
          case TIME_STYLE.MEDIUM:
          case TIME_STYLE.LONG:
            timeFormat = configProvider$1.getLocale().timeFormat;
            break;

          default:
            timeFormat = configProvider$1.getLocale().shortTimeFormat;
            break;
        }

        return timeFormat;
      }

      get allowedTimeFormats() {
        // this method can't be static because at the time this file is interpreted,
        // getLocale don't have the injected Locale in the config provider.
        const locale = configProvider$1.getLocale(); // the locale.timeFormat is the medium format. Locale dont supports a large
        // time format at the moment.

        return [locale.timeFormat, locale.shortTimeFormat];
      }
      /**
       * Parses the input time and sets the timeFormat used to parse the displayValue
       * if it is a valid time.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted time if displayValue is valid. null otherwise.
       */


      parseFormattedTime(displayValue) {
        const allowedFormats = this.allowedTimeFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedTime(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        if (value !== null) {
          this.timeFormat = allowedFormats[i - 1];
        }

        return value;
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        ariaLabelledByElement: {
          config: 0
        },
        ariaControlsElement: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        timeStyle: {
          config: 3
        }
      },
      publicMethods: ["hasBadInput", "showHelpMessage", "focus", "blur"],
      track: {
        _disabled: 1,
        _required: 1,
        _displayValue: 1,
        _value: 1,
        _items: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _mainInputId: 1,
        _errorMessage: 1,
        _readonly: 1,
        _describedByElements: 1
      }
    });

    var _lightningTimepicker = lwc.registerComponent(LightningTimePicker, {
      tmpl: _tmpl$k
    });

    function tmpl$m($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form": true,
          "slds-form_compound": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 2
      }, [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 3
      }, [api_element("legend", {
        className: $cmp.computedLabelClass,
        key: 4
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 6
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 7
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 9
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 10
      }, [api_custom_element("lightning-datepicker", _lightningDatepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "value": $cmp.dateValue,
          "min": $cmp.dateMin,
          "max": $cmp.dateMax,
          "label": $cmp.i18n.date,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "autocomplete": $cmp.autocomplete,
          "dateStyle": $cmp.dateStyle
        },
        key: 11,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleDatepickerFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleDatepickerBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleDateChange))
        }
      }, []), api_custom_element("lightning-timepicker", _lightningTimepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "value": $cmp.timeValue,
          "label": $cmp.i18n.time,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 12,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTimepickerFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTimepickerBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleTimeChange))
        }
      }, [])])])]), $cmp.customErrorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-error-message": true,
          "id": api_scoped_id("errormessage"),
          "aria-live": "assertive"
        },
        key: 14
      }, [api_dynamic($cmp.customErrorMessage)]) : null])])];
    }

    var _tmpl$l = lwc.registerTemplate(tmpl$m);
    tmpl$m.stylesheets = [];
    tmpl$m.stylesheetTokens = {
      hostAttribute: "lightning-datetimepicker_datetimepicker-host",
      shadowAttribute: "lightning-datetimepicker_datetimepicker"
    };

    var labelDate = 'Date';

    var labelTime = 'Time';

    const i18n$9 = {
      date: labelDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      time: labelTime
    };

    class LightningDateTimePicker extends lwc.LightningElement {
      // getters and setters necessary to trigger sync
      set timeAriaControls(val) {
        this._timeAriaControls = val;
        this.synchronizeA11y();
      }

      get timeAriaControls() {
        return this._timeAriaControls;
      }

      set timeAriaLabelledBy(val) {
        this._timeAriaLabelledBy = val;
        this.synchronizeA11y();
      }

      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(val) {
        this._timeAriaDescribedBy = val;
        this.synchronizeA11y();
      }

      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      get messageWhenBadInput() {
        if (this._messageWhenBadInput) {
          return this._messageWhenBadInput;
        } else if (this.hasBadDateInput) {
          return this.getDatepicker().messageWhenBadInput;
        } else if (this.hasBadTimeInput) {
          return this.getTimepicker().messageWhenBadInput;
        }

        return null;
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this.formatString(i18n$9.rangeOverflow, this.formattedMax);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(i18n$9.rangeUnderflow, this.formattedMin);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      get max() {
        return this.maxValue;
      }

      set max(newValue) {
        this.maxValue = newValue;
        this.calculateFormattedMaxValue();
      }

      get min() {
        return this.minValue;
      }

      set min(newValue) {
        this.minValue = newValue;
        this.calculateFormattedMinValue();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          if (!this.connected) {
            // we set the values in connectedCallback to make sure timezone is available.
            this._initialValue = normalizedValue;
            return;
          }

          this.setDateAndTimeValues(normalizedValue);
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }
      /**
       * Sets focus on the date input element.
       */


      focus() {
        if (this.connected) {
          this.getDatepicker().focus();
        }
      }
      /**
       * Removes keyboard focus from the input elements.
       */


      blur() {
        if (this.connected) {
          this.getDatepicker().blur();
          this.getTimepicker().blur();
        }
      }

      hasBadInput() {
        return this.connected && (this.hasBadDateInput || this.hasBadTimeInput);
      }

      get hasBadDateInput() {
        return this.getDatepicker().hasBadInput();
      }

      get hasBadTimeInput() {
        const timeBadInput = this.getTimepicker().hasBadInput();
        const timeMissing = this.required && this._dateValue && !this._timeValue;
        return timeMissing || timeBadInput;
      }

      showHelpMessage(message) {
        if (!this.connected) {
          return;
        }

        if (!message) {
          this.clearHelpMessage();
          return;
        }

        if (this.hasBadDateInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getDatepicker().showHelpMessage(message);
          return;
        }

        if (this.hasBadTimeInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getTimepicker().showHelpMessage(message);
          return;
        }

        this.classList.add('slds-has-error');
        this._customErrorMessage = message;
      }

      clearHelpMessage() {
        this.classList.remove('slds-has-error');
        this._customErrorMessage = '';
        this.getDatepicker().showHelpMessage('');
        this.getTimepicker().showHelpMessage('');
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__legend slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get i18n() {
        return i18n$9;
      }

      get dateValue() {
        return this._dateValue;
      }

      get timeValue() {
        return this._timeValue;
      }

      get customErrorMessage() {
        return this._customErrorMessage;
      }

      get dateMin() {
        return this._dateMin;
      }

      get dateMax() {
        return this._dateMax;
      }

      get errorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-error-message'));
      }

      get computedDateAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.dateAriaDescribedBy) {
          ariaValues.push(this.dateAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedTimeAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.timeAriaDescribedBy) {
          ariaValues.push(this.timeAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._value = null;
        this._dateValue = null;
        this._timeValue = null;
        this._customErrorMessage = '';
        this._dateMin = void 0;
        this._dateMax = void 0;
        this.label = void 0;
        this.name = void 0;
        this.timezone = void 0;
        this.placeholder = '';
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.timeAriaLabel = void 0;
        this.autocomplete = void 0;
        this.dateAriaControls = void 0;
        this.dateAriaLabel = void 0;
        this.dateAriaLabelledBy = void 0;
        this.dateAriaDescribedBy = void 0;
        this.messageWhenValueMissing = void 0;
        this.uniqueId = generateUniqueId();
      }

      synchronizeA11y() {
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.dateAriaLabelledBy,
            ariaDescribedByElements: this.computedDateAriaDescribedBy,
            ariaControlsElement: this.dateAriaControls,
            'aria-label': this.dateAriaLabel
          });
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.timeAriaLabelledBy,
            ariaDescribedByElements: this.computedTimeAriaDescribedBy,
            ariaControlsElement: this.timeAriaControls,
            'aria-label': this.timeAriaLabel
          });
        }
      }

      connectedCallback() {
        this.classList.add('slds-form_compound');
        this.calculateFormattedMinValue();
        this.calculateFormattedMaxValue();
        this.connected = true; // we set the initial values here in order to make sure timezone is available.

        this.setDateAndTimeValues(this._initialValue);
        this.interactingState = new InteractingState();
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this.connected = false;
      }

      getTimepicker() {
        return this.template.querySelector('lightning-timepicker');
      }

      getDatepicker() {
        return this.template.querySelector('lightning-datepicker');
      }

      handleDatepickerFocus() {
        this._dateFocus = true;
        this.interactingState.enter();
      }

      handleTimepickerFocus() {
        this._timeFocus = true;
        this.interactingState.enter();
      }

      handleDatepickerBlur() {
        this._dateFocus = false; // timepicker fires focus before datepicker fires blur

        if (!this._timeFocus) {
          this.interactingState.leave();
        }
      }

      handleTimepickerBlur() {
        this._timeFocus = false; // datepicker fires focus before timepicker fires blur

        if (!this._dateFocus) {
          this.interactingState.leave();
        }
      }

      handleDateChange(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from listbox

        if (!event.detail) {
          return;
        }

        this._dateValue = event.detail.value;

        if (this._dateValue) {
          this._timeValue = this._timeValue || getCurrentTime(this.timezone);
        }

        this.updateValue();
      }

      handleTimeChange(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from listbox

        if (!event.detail) {
          return;
        }

        this._timeValue = event.detail.value;
        this.updateValue();
      }

      updateValue() {
        const dateValue = this._dateValue;
        const timeValue = this._timeValue;

        if (dateValue && timeValue) {
          const dateTimeString = dateValue + TIME_SEPARATOR + timeValue;
          this._value = normalizeFormattedDateTime(dateTimeString, this.timezone);
          this.dispatchChangeEvent();
        } else if (!dateValue) {
          this._value = null;
          this._timeValue = null;
          this.dispatchChangeEvent();
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return value;
      }

      setDateAndTimeValues(value) {
        const normalizedValue = normalizeISODateTime(value, this.timezone).isoValue;
        const isDateOnly = normalizedValue && value.indexOf(TIME_SEPARATOR) < 0;

        if (isDateOnly) {
          this._dateValue = value;
          this._value = this._dateValue;
          return;
        }

        const dateAndTime = this.separateDateTime(normalizedValue);
        this._dateValue = dateAndTime && dateAndTime[0];
        this._timeValue = dateAndTime && dateAndTime[1];
        this._value = normalizedValue;
      }

      calculateFormattedMinValue() {
        if (!this.min) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.min, this.timezone);
        this._dateMin = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMin = normalizedDate.displayValue;
      }

      calculateFormattedMaxValue() {
        if (!this.max) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.max, this.timezone);
        this._dateMax = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMax = normalizedDate.displayValue;
      }

      separateDateTime(isoString) {
        return typeof isoString === 'string' ? isoString.split(TIME_SEPARATOR) : null;
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningDateTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDateTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        timezone: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        timeAriaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        timeAriaControls: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 0
        },
        dateAriaDescribedBy: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "hasBadInput", "showHelpMessage"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _value: 1,
        _dateValue: 1,
        _timeValue: 1,
        _customErrorMessage: 1,
        _dateMin: 1,
        _dateMax: 1
      }
    });

    var _lightningDatetimepicker = lwc.registerComponent(LightningDateTimePicker, {
      tmpl: _tmpl$l
    });

    function tmpl$n($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        t: api_text,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16,
        _m17,
        _m18,
        _m19,
        _m20,
        _m21,
        _m22,
        _m23,
        _m24,
        _m25,
        _m26,
        _m27,
        _m28,
        _m29,
        _m30,
        _m31,
        _m32,
        _m33,
        _m34,
        _m35,
        _m36,
        _m37,
        _m38,
        _m39,
        _m40
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "data-aria": true
        },
        key: 2
      }, []), $cmp.isTypeSimple ? api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 4
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 6
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeSimple ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 7
      }, []) : null : null, $cmp.isTypeSimple ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 8
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": $cmp._internalType,
          "id": api_scoped_id("input"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "autocomplete": $cmp.autocomplete,
          "max": $cmp.normalizedMax,
          "min": $cmp.normalizedMin,
          "step": $cmp.step,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "pattern": $cmp.pattern,
          "placeholder": $cmp.placeholder,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 9,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keypress": _m4 || ($ctx._m4 = api_bind($cmp.handleKeyPress)),
          "touchend": _m5 || ($ctx._m5 = api_bind($cmp.handleTouchEnd))
        }
      }, []), $cmp.isTypeSearch ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:search",
          "variant": "bare",
          "svgClass": "slds-input__icon slds-input__icon_left slds-icon-text-default"
        },
        key: 11
      }, []) : null, $cmp.isTypeSearch ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 12
      }, [$cmp.isLoading ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 14
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 15
      }, [api_dynamic($cmp.i18n.loading)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 16
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 17
      }, [])]) : null, $cmp._showClearButton ? api_element("button", {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true,
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "data-element-id": "searchClear"
        },
        key: 19,
        on: {
          "blur": _m6 || ($ctx._m6 = api_bind($cmp.handleBlur)),
          "click": _m7 || ($ctx._m7 = api_bind($cmp.clearAndSetFocusOnInput))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:clear",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 20
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 21
      }, [api_dynamic($cmp.i18n.clear)])]) : null]) : null]) : null, $cmp.isTypeToggle ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-checkbox_toggle": true,
          "slds-grid": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-toggle")}`
        },
        key: 24
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 26
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 27
      }, [api_dynamic($cmp.label)]), api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-toggle"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 28,
        on: {
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "focus": _m9 || ($ctx._m9 = api_bind($cmp.handleFocus)),
          "change": _m10 || ($ctx._m10 = api_bind($cmp.handleChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_faux_container": true
        },
        attrs: {
          "id": api_scoped_id("toggle-description"),
          "data-toggle-description": true,
          "aria-live": "assertive"
        },
        key: 29
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 30
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_on": true
        },
        key: 31
      }, [api_dynamic($cmp.messageToggleActive)]), api_element("span", {
        classMap: {
          "slds-checkbox_off": true
        },
        key: 32
      }, [api_dynamic($cmp.messageToggleInactive)])])])]) : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 35
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 37
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 38
      }, [api_dynamic($cmp.label)])]) : null : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 39
      }, []) : null : null : null, $cmp.isTypeCheckbox ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 40
      }, [api_element("span", {
        className: $cmp.computedCheckboxClass,
        key: 41
      }, [$cmp.isStandardVariant ? $cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 44
      }, [api_text("*")]) : null : null, api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 45,
        on: {
          "blur": _m11 || ($ctx._m11 = api_bind($cmp.handleBlur)),
          "focus": _m12 || ($ctx._m12 = api_bind($cmp.handleFocus)),
          "change": _m13 || ($ctx._m13 = api_bind($cmp.handleChange))
        }
      }, []), !$cmp.isStandardVariant ? api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 47
      }, []) : null, $cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 49
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 50
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 51
      }, [api_dynamic($cmp.label)])]) : null, $cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 52
      }, []) : null : null])]) : null, $cmp.isTypeCheckboxButton ? api_element("div", {
        classMap: {
          "slds-checkbox_add-button": true
        },
        key: 54
      }, [api_element("input", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-button"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 55,
        on: {
          "blur": _m14 || ($ctx._m14 = api_bind($cmp.handleBlur)),
          "focus": _m15 || ($ctx._m15 = api_bind($cmp.handleFocus)),
          "change": _m16 || ($ctx._m16 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox_faux": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-button")}`
        },
        key: 56
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 57
      }, [api_dynamic($cmp.label)])])]) : null, $cmp.isTypeRadio ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 59
      }, [api_element("span", {
        classMap: {
          "slds-radio": true
        },
        key: 60
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "id": api_scoped_id("radio"),
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 61,
        on: {
          "blur": _m17 || ($ctx._m17 = api_bind($cmp.handleBlur)),
          "focus": _m18 || ($ctx._m18 = api_bind($cmp.handleFocus)),
          "change": _m19 || ($ctx._m19 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-radio__label": true
        },
        attrs: {
          "for": `${api_scoped_id("radio")}`
        },
        key: 62
      }, [api_element("span", {
        classMap: {
          "slds-radio_faux": true
        },
        key: 63
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 64
      }, [api_dynamic($cmp.label)])])])]) : null, $cmp.isTypeFile ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("form-label"),
          "data-form-label": true
        },
        key: 66
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 68
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeFile ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 69
      }, [api_element("div", {
        classMap: {
          "slds-file-selector": true,
          "slds-file-selector_files": true
        },
        key: 70,
        on: {
          "drop": _m24 || ($ctx._m24 = api_bind($cmp.handleDropFiles))
        }
      }, [api_custom_element("lightning-primitive-file-droppable-zone", _lightningPrimitiveFileDroppableZone, {
        props: {
          "multiple": $cmp.multiple,
          "disabled": $cmp.disabled
        },
        key: 71
      }, [api_element("input", {
        classMap: {
          "slds-file-selector__input": true,
          "slds-assistive-text": true
        },
        attrs: {
          "type": "file",
          "id": api_scoped_id("input-file"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "accept": $cmp.accept,
          "name": $cmp.name
        },
        props: {
          "multiple": $cmp.multiple,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 72,
        on: {
          "blur": _m20 || ($ctx._m20 = api_bind($cmp.handleBlur)),
          "click": _m21 || ($ctx._m21 = api_bind($cmp.handleFileClick)),
          "focus": _m22 || ($ctx._m22 = api_bind($cmp.handleFocus)),
          "change": _m23 || ($ctx._m23 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-file-selector__body": true
        },
        attrs: {
          "id": api_scoped_id("file-selector-label"),
          "data-file-selector-label": true,
          "for": `${api_scoped_id("input-file")}`
        },
        key: 73
      }, [api_element("span", {
        classMap: {
          "slds-file-selector__button": true,
          "slds-button": true,
          "slds-button_neutral": true
        },
        key: 74
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:upload",
          "variant": "bare",
          "svgClass": "slds-button__icon slds-button__icon_left"
        },
        key: 75
      }, []), api_dynamic($cmp.i18n.inputFileButtonLabel)]), api_element("span", {
        classMap: {
          "slds-file-selector__text": true,
          "slds-medium-show": true
        },
        key: 76
      }, [api_dynamic($cmp.i18n.inputFileBodyText)])])])])]) : null, $cmp.isTypeColor ? api_element("div", {
        classMap: {
          "slds-color-picker": true
        },
        key: 78
      }, [api_element("div", {
        classMap: {
          "slds-color-picker__summary": true
        },
        key: 79
      }, [api_element("label", {
        className: $cmp.computedColorLabelClass,
        attrs: {
          "for": `${api_scoped_id("color")}`
        },
        key: 80
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 82
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "value": $cmp.value,
          "disabled": $cmp.disabled
        },
        key: 83,
        on: {
          "blur": _m25 || ($ctx._m25 = api_bind($cmp.handleBlur)),
          "focus": _m26 || ($ctx._m26 = api_bind($cmp.handleFocus)),
          "change": _m27 || ($ctx._m27 = api_bind($cmp.handleColorChange))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__summary-input": true
        },
        key: 84
      }, [api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 85
      }, [api_element("input", {
        classMap: {
          "slds-input": true,
          "slds-m-right_x-small": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("color"),
          "name": $cmp.name,
          "autocomplete": $cmp.autocomplete,
          "accesskey": $cmp.accesskey,
          "aria-label": $cmp.computedAriaLabel,
          "minlength": "4",
          "maxlength": "7",
          "placeholder": $cmp.placeholder,
          "pattern": $cmp.pattern
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 86,
        on: {
          "blur": _m28 || ($ctx._m28 = api_bind($cmp.handleBlur)),
          "focus": _m29 || ($ctx._m29 = api_bind($cmp.handleFocus)),
          "change": _m30 || ($ctx._m30 = api_bind($cmp.handleChange)),
          "input": _m31 || ($ctx._m31 = api_bind($cmp.handleInput))
        }
      }, [])])]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 87
      }, []) : null])]) : null, $cmp.isTypeDesktopDate ? api_custom_element("lightning-datepicker", _lightningDatepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "ariaLabel": $cmp.ariaLabel,
          "dateStyle": $cmp.dateStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 89,
        on: {
          "change": _m32 || ($ctx._m32 = api_bind($cmp.handleChange)),
          "blur": _m33 || ($ctx._m33 = api_bind($cmp.handleBlur)),
          "focus": _m34 || ($ctx._m34 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopTime ? api_custom_element("lightning-timepicker", _lightningTimepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "ariaLabel": $cmp.ariaLabel,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 91,
        on: {
          "change": _m35 || ($ctx._m35 = api_bind($cmp.handleChange)),
          "blur": _m36 || ($ctx._m36 = api_bind($cmp.handleBlur)),
          "focus": _m37 || ($ctx._m37 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopDateTime ? api_custom_element("lightning-datetimepicker", _lightningDatetimepicker, {
        props: {
          "dateAriaControls": $cmp.dateAriaControls,
          "dateAriaLabel": $cmp.dateAriaLabel,
          "dateAriaLabelledBy": $cmp.dateAriaLabelledBy,
          "dateAriaDescribedBy": $cmp.dateAriaDescribedBy,
          "dateStyle": $cmp.dateStyle,
          "timeStyle": $cmp.timeStyle,
          "timeAriaControls": $cmp.timeAriaControls,
          "timeAriaLabel": $cmp.timeAriaLabel,
          "timeAriaLabelledBy": $cmp.timeAriaLabelledBy,
          "timeAriaDescribedBy": $cmp.timeAriaDescribedBy,
          "max": $cmp.max,
          "min": $cmp.min,
          "timezone": $cmp.timezone,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 93,
        on: {
          "change": _m38 || ($ctx._m38 = api_bind($cmp.handleChange)),
          "blur": _m39 || ($ctx._m39 = api_bind($cmp.handleBlur)),
          "focus": _m40 || ($ctx._m40 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 95
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$m = lwc.registerTemplate(tmpl$n);
    tmpl$n.stylesheets = [];

    if (_implicitStylesheets$5) {
      tmpl$n.stylesheets.push.apply(tmpl$n.stylesheets, _implicitStylesheets$5);
    }
    tmpl$n.stylesheetTokens = {
      hostAttribute: "lightning-input_input-host",
      shadowAttribute: "lightning-input_input"
    };

    var labelInputFileBodyText = 'Or drop files';

    var labelInputFileButtonLabel = 'Upload Files';

    var labelMessageToggleActive = 'Active';

    var labelMessageToggleInactive = 'Inactive';

    var labelClearInput = 'Clear';

    var labelLoadingIndicator = 'Loading';

    function normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return value;
      }

      return '';
    }
    function normalizeDate(value) {
      return normalizeISODate(value).isoValue || '';
    }
    function normalizeTime(value) {
      return normalizeISOTime(value, STANDARD_TIME_FORMAT).isoValue || '';
    } // Converts value to the user's timezone and formats it in a way that will be accepted by the input

    function normalizeUTCDateTime(value, timezone) {
      return normalizeISODateTime(value, timezone).isoValue || '';
    } // parses the input value and converts it back to UTC from the user's timezone

    function normalizeDateTimeToUTC(value, timezone) {
      return normalizeFormattedDateTime(value, timezone) || '';
    }

    const i18n$a = {
      a11yTriggerText: labelA11yTriggerText,
      inputFileBodyText: labelInputFileBodyText,
      inputFileButtonLabel: labelInputFileButtonLabel,
      messageToggleActive: labelMessageToggleActive,
      messageToggleInactive: labelMessageToggleInactive,
      required: labelRequired,
      clear: labelClearInput,
      loading: labelLoadingIndicator
    };
    const ARIA_CONTROLS$2 = 'aria-controls';
    const ARIA_LABEL$2 = 'aria-label';
    const ARIA_LABELEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$3 = 'aria-describedby';
    /*
    * This component supports the regular native input types, with the addition of toggle, checkbox-button and color.
    * Furthermore the file type supports a droppable zone, search has a clear button, number has formatting.
    * Input changes (native oninput event) triggers an onchange event,
    *     the native even is stopped, the dispatched custom event has a value that points to the state of the component
    *     in case of files it's the files uploaded (via droppable zone or through the upload button),
    *     checked for radio and checkbox, checkbox-button, and just straight input's value for everything else
    *
    *
    * _Toggle_ (always has an aria-describedby, on error has an additional one, default label text for active and inactive
    * states)
    * _File_ (as it has a droppable zone, the validity returned would have to be valid - unless a custom error message was
    *    passed)
    * _Search_ (it has the clear button and the icon)
    * _Number_ (formatting when not in focus, when in focus shows raw value)
    *
    * */

    const VALID_NUMBER_FORMATTERS = ['decimal', 'percent', 'percent-fixed', 'currency'];
    const DEFAULT_COLOR$1 = '#000000';
    const DEFAULT_FORMATTER = VALID_NUMBER_FORMATTERS[0];
    /**
     * Returns an aria string with all the non-autolinked values removed
     * @param {String} values space sperated list of ids
     * @returns {String} The aria values with the non-auto linked ones removed
     */

    function filterNonAutoLink(values) {
      const ariaValues = values.split(/\s+/);
      return ariaValues.filter(value => {
        return !!value.match(/^auto-link/);
      }).join(' ');
    }
    /**
     * Represents interactive controls that accept user input depending on the type attribute.
     */


    class LightningInput extends lwc.LightningElement {
      /**
       * Text that is displayed when the field is empty, to prompt the user for a valid entry.
       * @type {string}
       *
       */

      /**
       * Specifies the name of an input element.
       * @type {string}
       *
       */

      /**
       * Text label for the input.
       * @type {string}
       * @required
       *
       */

      /**
       * Error message to be displayed when a bad input is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a pattern mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range overflow is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range underflow is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a step mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too short.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too long.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a type mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is missing.
       * @type {string}
       *
       */

      /**
       * Text shown for the active state of a toggle. The default is "Active".
       * @type {string}
       */

      /**
       * Text shown for the inactive state of a toggle. The default is "Inactive".
       * @type {string}
       */

      /**
       * Describes the input to assistive technologies.
       * @type {string}
       */

      /**
       * Controls autofilling of the field. Input types that support autocomplete are
       * email, search, tel, text, and url. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * @type {string}
       */
      constructor() {
        super();
        this.placeholder = void 0;
        this.name = void 0;
        this.label = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenPatternMismatch = void 0;
        this.messageWhenRangeOverflow = void 0;
        this.messageWhenRangeUnderflow = void 0;
        this.messageWhenStepMismatch = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenTypeMismatch = void 0;
        this.messageWhenValueMissing = void 0;
        this.messageToggleActive = i18n$a.messageToggleActive;
        this.messageToggleInactive = i18n$a.messageToggleInactive;
        this.ariaLabel = void 0;
        this.autocomplete = void 0;
        this._timeAriaDescribedBy = void 0;
        this._timeAriaLabelledBy = void 0;
        this._timeAriaControls = void 0;
        this._dateAriaControls = void 0;
        this._dateAriaDescribedBy = void 0;
        this._dateAriaLabelledBy = void 0;
        this._value = '';
        this._type = 'text';
        this._pattern = void 0;
        this._max = void 0;
        this._min = void 0;
        this._step = void 0;
        this._disabled = false;
        this._readOnly = false;
        this._required = false;
        this._checked = false;
        this._isLoading = false;
        this._multiple = false;
        this._timezone = false;
        this._helpMessage = null;
        this._isColorPickerPanelOpen = false;
        this._fieldLevelHelp = void 0;
        this._accesskey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._accept = void 0;
        this._variant = void 0;
        this._connected = void 0;
        this._formatter = DEFAULT_FORMATTER;
        this._showRawNumber = false;
        this._initialValueSet = false;
        this._files = null;
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.dateAriaLabel = void 0;
        this.ariaObserver = new ContentMutation(this); // Native Shadow Root will return [native code].
        // Our synthetic method will return the function source.

        this.isNative = this.template.querySelector.toString().match(/\[native code\]/);
      }
      /**
       * Reserved for internal use.
       * @type {number}
       *
       */


      get formatFractionDigits() {
        return this._formatFractionDigits;
      }

      set formatFractionDigits(value) {
        this._formatFractionDigits = value;

        if (this._connected && this.isTypeNumber) {
          this.inputElement.value = this.displayedValue;
        }
      }

      set timeAriaControls(refs) {
        this._timeAriaControls = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaControls = ref;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * time input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and date-aria-controls to describe the native date time input.
       * @type {string}
       */


      get timeAriaControls() {
        return this._timeAriaControls;
      }
      /**
       * The display style of the date when type='date' or type='datetime'. Valid values are
       * short, medium (default), and long. The format of each style is specific to the locale.
       * On mobile devices this attribute has no effect.
       * @type {string}
       * @default medium
       */


      set dateAriaLabelledBy(refs) {
        this._dateAriaLabelledBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaLabelledBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the date input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and time-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       */


      get dateAriaLabelledBy() {
        return this._dateAriaLabelledBy;
      }

      set timeAriaLabelledBy(refs) {
        this._timeAriaLabelledBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaLabelledBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the time input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and date-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       *
       */


      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(refs) {
        this._timeAriaDescribedBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaDescribedBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the time input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and date-aria-described-by
       * to describe the native date time input.
       *  @type {string}
       *
       */


      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      set dateAriaControls(refs) {
        this._dateAriaControls = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaControls = ref;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * date input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and time-aria-controls to describe the native date time input.
       * @type {string}
       *
       */


      get dateAriaControls() {
        return this._dateAriaControls;
      }

      set dateAriaDescribedBy(refs) {
        this._dateAriaDescribedBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaDescribedBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the date input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and time-aria-described-by
       * to describe the native date time input.
       * @type {string}
       */


      get dateAriaDescribedBy() {
        return this._dateAriaDescribedBy;
      }

      set ariaControls(refs) {
        this._ariaControls = refs;
        this.ariaObserver.link('input', 'aria-controls', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the input.
       * @type {string}
       */


      get ariaControls() {
        return this._ariaControls;
      }

      set ariaLabelledBy(refs) {
        this._ariaLabelledBy = refs;
        this.ariaObserver.link('input', 'aria-labelledby', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide labels for the input.
       * @type {string}
       */


      get ariaLabelledBy() {
        // native version returns the auto linked value
        if (this.isNative) {
          const ariaValues = this.template.querySelector('input').getAttribute('aria-labelledby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaLabelledBy;
      }

      set ariaDescribedBy(refs) {
        this._ariaDescribedBy = refs;
        this.ariaObserver.link('input', 'aria-describedby', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the input.
       * @type {string}
       */


      get ariaDescribedBy() {
        if (this.isNative) {
          // in native case return the linked value
          const ariaValues = this.template.querySelector('input').getAttribute('aria-describedby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaDescribedBy;
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
          return;
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
          return;
        }

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELEDBY]: this.computedAriaLabelledBy,
          [ARIA_DESCRIBEDBY$3]: this.computedAriaDescribedBy,
          [ARIA_CONTROLS$2]: this.computedAriaControls,
          [ARIA_LABEL$2]: this.computedAriaLabel
        });
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.validateRequiredAttributes();
        this._connected = true;
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
        this._initialValueSet = false;
        this._inputElement = undefined;
      }

      renderedCallback() {
        if (!this._initialValueSet && this.inputElement) {
          this.inputElement.value = this.displayedValue;

          if (this.isTypeCheckable) {
            this.inputElement.checked = this._checked;
          }

          this._initialValueSet = true;
        }

        this.ariaObserver.sync();
        this.synchronizeA11y();
      }
      /**
       * String value with the formatter to be used for number input. Valid values include
       * decimal, percent, percent-fixed, and currency.
       * @type {string}
       */


      get formatter() {
        return this._formatter;
      }

      set formatter(value) {
        this._formatter = normalizeString(value, {
          fallbackValue: DEFAULT_FORMATTER,
          validValues: VALID_NUMBER_FORMATTERS
        });

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * The type of the input. This value defaults to text.
       * @type {string}
       * @default text
       */


      get type() {
        return this._type;
      }

      set type(value) {
        const normalizedValue = normalizeString(value);
        this._type = normalizedValue === 'datetime' ? 'datetime-local' : normalizedValue;
        this.validateType(normalizedValue);
        this._inputElementRefreshNeeded = true;

        if (this._connected) {
          // The type is being changed after render, which means the input element may be different (eg. changing
          // from text to 'checkbox', so we need to set the initial value again
          this._initialValueSet = false;
        }

        this._updateProxyInputAttributes(['type', 'value', 'max', 'min', 'required', 'pattern']);
      }
      /**
       * For the search type only. If present, a spinner is displayed to indicate that data is loading.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return this._isLoading;
      }

      set isLoading(value) {
        this._isLoading = normalizeBoolean(value);
      }
      /**
       * Specifies the regular expression that the input's value is checked against.
       * This attribute is supported for text, search, url, tel, email, and password types.
       * @type {string}
       *
       */


      get pattern() {
        if (this.isTypeColor) {
          return '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$';
        }

        return this._pattern;
      }

      set pattern(value) {
        this._pattern = value;

        this._updateProxyInputAttributes('pattern');
      }
      /**
       * The maximum number of characters allowed in the field.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * Specifies the types of files that the server accepts. This attribute can be used only when type='file'.
       * @type {string}
       */


      get accept() {
        return this._accept;
      }

      set accept(value) {
        this._accept = value;

        this._updateProxyInputAttributes('accept');
      }
      /**
       * The minimum number of characters allowed in the field.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      } // number and date/time

      /**
       * The maximum acceptable value for the input.  This attribute can be used only with number,
       * range, date, time, and datetime input types. For number and range type, the max value is a
       * decimal number. For the date, time, and datetime types, the max value must use a valid string for the type.
       * @type {decimal|string}
       */


      get max() {
        return this._max;
      }

      set max(value) {
        this._max = value;

        this._updateProxyInputAttributes('max');
      }
      /**
       * The minimum acceptable value for the input. This attribute can be used only with number,
       * range, date, time, and datetime input types. For number and range types, the min value
       * is a decimal number. For the date, time, and datetime types, the min value must use a valid string for the type.
       * @type {decimal|string}
       */


      get min() {
        return this._min;
      }

      set min(value) {
        this._min = value;

        this._updateProxyInputAttributes('min');
      }
      /**
       * Granularity of the value, specified as a positive floating point number.
       * Use 'any' when granularity is not a concern. This value defaults to 1.
       * @type {decimal|string}
       * @default 1
       */


      get step() {
        const stepNotSupportedYet = this.isTypeDateTime || this.isTypeTime; // The step attribute is broken on IE11; e.g. 123.45 with step=0.01 returns stepMismatch. See W-5356698 for details.

        const nativeStepBroken = this.isTypeNumber && isIE11;

        if (stepNotSupportedYet || nativeStepBroken) {
          return 'any';
        }

        return this._step;
      }

      set step(value) {
        this._step = normalizeInput(value);

        this._updateProxyInputAttributes('step');

        this._calculateFractionDigitsFromStep(value);

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * If present, the checkbox is selected.
       * @type {boolean}
       * @default false
       */


      get checked() {
        // checkable inputs can be part of a named group, in that case there won't be a change event thrown and so
        // the internal tracking _checked would be out of sync with the actual input value.
        if (this.isTypeCheckable && this._initialValueSet) {
          return this.inputElement.checked;
        }

        return this._checked;
      }

      set checked(value) {
        this._checked = normalizeBoolean(value);

        this._updateProxyInputAttributes('checked');

        if (this._connected) {
          this.inputElement.checked = this._checked;
        }
      }
      /**
       * Specifies that a user can enter more than one value. This attribute can be used only when type='file' or type='email'.
       * @type {boolean}
       * @default false
       */


      get multiple() {
        return this._multiple;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);

        this._updateProxyInputAttributes('multiple');
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        this._value = normalizeInput(value);

        this._updateProxyInputAttributes('value'); // Setting value of a type file isn't allowed, but due to the design of Aura/LWC interop layer
        // it will try to set the value after a change event


        if (!this.isTypeFile) {
          // Again, due to the interop layer we need to check whether the value being set
          // is different, otherwise we're duplicating the sets on the input, which result
          // in different bugs like Japanese IME duplication of characters in Safari (likely a browser bug) or
          // character position re-set in IE11.
          if (this._connected && this.inputElement.value !== this.displayedValue) {
            this.inputElement.value = this.displayedValue;
          }
        }
      }
      /**
       * The variant changes the appearance of an input field.
       * Accepted variants include standard, label-inline, label-hidden, and label-stacked.
       * This value defaults to standard, which displays the label above the field.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input field.
       * Use label-stacked to place the label above the input field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the input field is read-only and cannot be edited by users.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * Specifies the time zone used when type='datetime' only. This value defaults to the user's Salesforce time zone setting.
       * @type {string}
       *
       */


      get timezone() {
        return this._timezone || configProvider$1.getLocale().timezone;
      }

      set timezone(value) {
        this._timezone = value; // mobile date/time normalization of value/max/min depends on timezone, so we need to update here as well

        this._updateProxyInputAttributes(['value', 'max', 'min']);
      }
      /**
       * A FileList that contains selected files. This attribute can be used only when type='file'.
       * @type {object}
       *
       */


      get files() {
        if (this.isTypeFile) {
          return lwc.unwrap(this._files);
        }

        return null;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Sets a custom error message to be displayed when a form is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          if (this._connected && !this.isNativeInput) {
            this.inputElement.showHelpMessage(message);
          } else {
            this._helpMessage = message;
          }
        });
      }

      get isNativeInput() {
        return !(this.isTypeDesktopDate || this.isTypeDesktopDateTime || this.isTypeDesktopTime);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * This attribute isn't supported for file, radio, toggle, and checkbox-button types.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      get computedAriaControls() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaControls);
          ariaValues.push(this.timeAriaControls);
        }

        if (this.ariaControls) {
          ariaValues.push(this.ariaControls);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabel() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabel);
          ariaValues.push(this.timeAriaLabel);
        }

        if (this.ariaLabel) {
          ariaValues.push(this.ariaLabel);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabelledBy() {
        const ariaValues = [];

        if (this.isTypeFile) {
          ariaValues.push(this.computedUniqueFileElementLabelledById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabelledBy);
          ariaValues.push(this.timeAriaLabelledBy);
        }

        if (this.ariaLabelledBy) {
          ariaValues.push(this.ariaLabelledBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        if (this._helpMessage) {
          ariaValues.push(this.computedUniqueHelpElementId);
        } // The toggle type is described by a secondary element


        if (this.isTypeToggle) {
          ariaValues.push(this.computedUniqueToggleElementDescribedById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaDescribedBy);
          ariaValues.push(this.timeAriaDescribedBy);
        }

        if (this.ariaDescribedBy) {
          ariaValues.push(this.ariaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }
      /**
       * Specifies a shortcut key to activate or focus an element.
       * @type {string}
       *
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get isLabelStacked() {
        return this.variant === VARIANT.LABEL_STACKED;
      }

      get accesskey() {
        return this._accesskey;
      }

      get isTypeCheckable() {
        return this.isTypeCheckbox || this.isTypeCheckboxButton || this.isTypeRadio || this.isTypeToggle;
      }

      get colorInputElementValue() {
        return this.validity.valid && this.value ? this.value : DEFAULT_COLOR$1;
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      get computedUniqueHelpElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get computedUniqueToggleElementDescribedById() {
        if (this.isTypeToggle) {
          const toggle = this.template.querySelector('[data-toggle-description]');
          return getRealDOMId(toggle);
        }

        return null;
      }

      get computedUniqueFormLabelId() {
        if (this.isTypeFile) {
          const formLabel = this.template.querySelector('[data-form-label]');
          return getRealDOMId(formLabel);
        }

        return null;
      }

      get computedUniqueFileSelectorLabelId() {
        if (this.isTypeFile) {
          const fileBodyLabel = this.template.querySelector('[data-file-selector-label]');
          return getRealDOMId(fileBodyLabel);
        }

        return null;
      }

      get computedUniqueFileElementLabelledById() {
        if (this.isTypeFile) {
          const labelIds = [this.computedUniqueFormLabelId, this.computedUniqueFileSelectorLabelId];
          return labelIds.join(' ');
        }

        return null;
      }

      get computedFormElementClass() {
        const classes = classSet('slds-form-element__control slds-grow');

        if (this.isTypeSearch) {
          classes.add('slds-input-has-icon slds-input-has-icon_left-right');
        }

        return classes.toString();
      }

      get i18n() {
        return i18n$a;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');

        if (this.isTypeCheckable || this.isTypeFile) ; else if (this.isTypeToggle) {
          classnames.add('slds-m-bottom_none');
        } else {
          classnames.add('slds-no-flex');
        }

        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedNumberClass() {
        return classSet('slds-input').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedColorLabelClass() {
        return classSet('slds-color-picker__summary-label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedCheckboxClass() {
        return classSet('slds-checkbox').add({
          'slds-checkbox_standalone': !this.isStandardVariant
        }).toString();
      }

      get normalizedMax() {
        return this.normalizeDateTimeString(this.max);
      }

      get normalizedMin() {
        return this.normalizeDateTimeString(this.min);
      }

      get isTypeNumber() {
        return this.type === 'number';
      }

      get isTypeSearch() {
        return this.type === 'search';
      }

      get isTypeToggle() {
        return this.type === 'toggle';
      }

      get isTypeText() {
        return this.type === 'text';
      }

      get isTypeCheckbox() {
        return this.type === 'checkbox';
      }

      get isTypeRadio() {
        return this.type === 'radio';
      }

      get isTypeCheckboxButton() {
        return this.type === 'checkbox-button';
      }

      get isTypeFile() {
        return this.type === 'file';
      }

      get isTypeColor() {
        return this.type === 'color';
      }

      get isTypeDate() {
        return this.type === 'date';
      }

      get isTypeDateTime() {
        return this.type === 'datetime' || this.type === 'datetime-local';
      }

      get isTypeTime() {
        return this.type === 'time';
      }

      get isTypeMobileDate() {
        return this.isTypeDate && !this.isDesktopBrowser();
      }

      get isTypeDesktopDate() {
        return this.isTypeDate && this.isDesktopBrowser();
      }

      get isTypeMobileDateTime() {
        return this.isTypeDateTime && !this.isDesktopBrowser();
      }

      get isTypeDesktopDateTime() {
        return this.isTypeDateTime && this.isDesktopBrowser();
      }

      get isTypeMobileTime() {
        return this.isTypeTime && !this.isDesktopBrowser();
      }

      get isTypeDesktopTime() {
        return this.isTypeTime && this.isDesktopBrowser();
      }

      get isTypeSimple() {
        return !this.isTypeCheckbox && !this.isTypeCheckboxButton && !this.isTypeToggle && !this.isTypeRadio && !this.isTypeFile && !this.isTypeColor && !this.isTypeDesktopDate && !this.isTypeDesktopDateTime && !this.isTypeDesktopTime;
      }

      get inputElement() {
        if (!this._connected) {
          return undefined;
        }

        if (!this._inputElement || this._inputElementRefreshNeeded) {
          let inputElement;

          if (this.isTypeDesktopDate) {
            inputElement = this.template.querySelector('lightning-datepicker');
          } else if (this.isTypeDesktopDateTime) {
            inputElement = this.template.querySelector('lightning-datetimepicker');
          } else if (this.isTypeDesktopTime) {
            inputElement = this.template.querySelector('lightning-timepicker');
          } else {
            inputElement = this.template.querySelector('input');
          }

          this._inputElementRefreshNeeded = false;
          this._inputElement = inputElement;
        }

        return this._inputElement;
      }

      get nativeInputType() {
        let inputType = 'text';

        if (this.isTypeSimple) {
          inputType = this.type;
        } else if (this.isTypeToggle || this.isTypeCheckboxButton || this.isTypeCheckbox) {
          inputType = 'checkbox';
        } else if (this.isTypeRadio) {
          inputType = 'radio';
        } else if (this.isTypeFile) {
          inputType = 'file';
        } else if (this.isTypeDateTime) {
          inputType = 'datetime-local';
        } else if (this.isTypeTime) {
          inputType = 'time';
        } else if (this.isTypeDate) {
          inputType = 'date';
        }

        return inputType;
      }

      clearAndSetFocusOnInput(event) {
        this.interactingState.enter();
        this.inputElement.value = '';

        this._updateValueAndValidityAttribute('');

        this.dispatchChangeEventWithDetail({
          value: this._value
        });
        this.inputElement.focus(); // button is removed from template, but
        // event still is propagated, For example, captured by panel,
        // then cause panel think is clicked outside.

        event.stopPropagation();
      }

      dispatchChangeEventWithDetail(detail) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }

      getFormattedValue(value) {
        if (!this.isTypeNumber) {
          return value;
        }

        if (isEmptyString(value)) {
          return '';
        }

        let formattedValue = value;
        let inputValue = value; // set formatter style & default options

        const formatStyle = this.formatter;
        const formatOptions = {
          style: formatStyle
        }; // Use the min/max fraction digits from the formatFractionDigits provided by the user if available.
        // Otherwise, use the number of digits calculated from step

        if (this._formatFractionDigits !== undefined) {
          formatOptions.minimumFractionDigits = this._formatFractionDigits;
          formatOptions.maximumFractionDigits = this._formatFractionDigits;
        } else if (this._calculatedFractionDigits !== undefined) {
          formatOptions.minimumFractionDigits = this._calculatedFractionDigits;
          formatOptions.maximumFractionDigits = this._calculatedFractionDigits;
        }

        if (formatStyle === 'percent-fixed') {
          // percent-fixed just uses percent format and divides the value by 100
          // before passing to the library, this is to deal with the
          // fact that percentages in salesforce are 0-100, not 0-1
          formatOptions.style = 'percent';
          const inputValueAsString = inputValue.toString();
          const normalisedNumberInPercent = parseFloat(inputValue) / 100; // If the number contains fraction digits and is not in an exponent format

          if (inputValueAsString.indexOf('.') > 0 && inputValueAsString.indexOf('e') < 0) {
            // Depending on the input number, division by 100 may lead to rounding errors
            // (e.g 0.785 / 100 is 0.007850000000000001), so we need to round back
            // to the correct precision, that is - existing number of fractional digits
            // plus extra 2 for division by 100.
            inputValue = normalisedNumberInPercent.toFixed(inputValueAsString.split('.')[1].length + 2);
          } else {
            inputValue = normalisedNumberInPercent;
          }
        }

        try {
          formattedValue = numberFormat(formatOptions).format(inputValue) || '';
        } catch (ignore) {// ignore any errors
        }

        return formattedValue;
      }

      validateType(type) {
        assert(type !== 'hidden', `<lightning-input> The type attribute value "hidden" is invalid. Use a regular <input type="hidden"> instead.`);
        assert(type !== 'submit' && type !== 'reset' && type !== 'image' && type !== 'button', `<lightning-input> The type attribute value "${type}" is invalid. Use <lightning:button> instead.`);

        if (this.isTypeRadio) {
          assert(!this.required, `<lightning-input> The required attribute is not supported on radio inputs directly. It should be implemented at the radio group level.`);
        }
      }

      validateRequiredAttributes() {
        const {
          label
        } = this;
        assert(typeof label === 'string' && label.length, `<lightning-input> The required label attribute value "${label}" is invalid.`);
      }

      handleFileClick() {
        this.inputElement.value = null;

        this._updateValueAndValidityAttribute(null);
      }

      handleDropFiles(event) {
        // drop doesn't trigger focus nor blur, so set state to interacting
        // and auto leave when there's no more action
        this.interactingState.interacting();
        this.fileUploadedViaDroppableZone = true;
        this._files = event.dataTransfer && event.dataTransfer.files;

        this._updateProxyInputAttributes('required');

        this.dispatchChangeEventWithDetail({
          files: lwc.unwrap(this._files)
        });
      } // We need this handler to account for mobile platforms' soft keyboards.
      // The type of the underlying native input for type="number" needs to be changed before the focus event is triggered,
      // this way the correct soft keyboard is shown on iOS, and on Android you don't need to tap twice to get the
      // keyboard to show.
      //
      // The minor side-effect of this is that if a touch drag ends on the input, the input will change type and
      // displayed value without the focus being triggered.


      handleTouchEnd() {
        if (this._connected && this.isTypeNumber) {
          this._switchInputTypeToNumber();
        }
      }

      handleFocus() {
        this.interactingState.enter();

        if (this.isTypeColor) {
          this._isColorPickerPanelOpen = false;
        }

        if (this._connected && this.isTypeNumber) {
          this._switchInputTypeToNumber();
        } // W-6176985: IE11 input when set value, will move cursor to beginning.
        // This fix is only for input type=number on IE11, and force the cursor to the end.


        if (isIE11 && this.isTypeNumber) {
          const length = this.inputElement.value.length;
          this.inputElement.selectionStart = length;
          this.inputElement.selectionEnd = length;
        }

        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur(event) {
        this.interactingState.leave();

        if (this._connected && this.isTypeNumber) {
          // Don't need to change type to text and show the formatted number when value is empty.
          // This also fixes the issue where the component resets to empty string when
          // there's invalid value since input in badInput validity state gives us back an empty
          // string instead of the invalid value.
          this._showRawNumber = isEmptyString(this._value);

          if (!this._showRawNumber) {
            this.inputElement.type = 'text';
            this.inputElement.value = this.displayedValue;
          }
        }

        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleChange(event) {
        event.stopPropagation();

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this.dispatchChangeEvent();
      }

      handleInput(event) {
        event.stopPropagation();

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this.dispatchChangeEvent();
      }

      handleKeyPress(event) {
        if (this.isTypeNumber && !this.isFunctionKeyStroke(event) && !this.isValidNumericKeyStroke(event)) {
          event.preventDefault();
        }
      }

      dispatchChangeEvent() {
        this.interactingState.enter();
        const detail = {};

        if (this.isTypeCheckable) {
          this._updateCheckedAndValidityAttribute(this.inputElement.checked);

          detail.checked = this._checked;
        } else if (this.isTypeFile) {
          this._files = this.inputElement.files; // this.template.querySelector returns a proxy, and .files would also be proxied
          // we're unwrapping it here so that native apis can be used on it

          detail.files = lwc.unwrap(this._files);

          this._updateProxyInputAttributes('required');
        }

        if (!this.isTypeCheckable) {
          detail.value = this.inputElement.value;

          if (this.isTypeMobileDateTime) {
            detail.value = normalizeDateTimeToUTC(detail.value, this.timezone);
          } else if (this.isTypeMobileTime) {
            detail.value = normalizeTime(detail.value);
          }

          this._updateValueAndValidityAttribute(detail.value);
        }

        this.dispatchChangeEventWithDetail(detail);
      }

      get _showClearButton() {
        return this.isTypeSearch && this._value !== undefined && this._value !== null && this._value !== '';
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault(); // Don't want error state inside panel

        if (!this.validity.valid) {
          this.inputElement.value = DEFAULT_COLOR$1;

          this._updateValueAndValidityAttribute(DEFAULT_COLOR$1);

          this._helpMessage = null;
          this.classList.remove('slds-has-error');
          this.dispatchChangeEventWithDetail({
            value: DEFAULT_COLOR$1
          });
        }
      }

      handleColorChange(event) {
        const selectedColor = event.detail.color;

        if (selectedColor !== this.inputElement.value) {
          this.inputElement.value = selectedColor;

          this._updateValueAndValidityAttribute(selectedColor);

          this.focus();
          this.dispatchChangeEventWithDetail({
            value: selectedColor
          });
        }

        this.template.querySelector('lightning-primitive-colorpicker-button').focus();
      }

      isNonPrintableKeyStroke(keyCode) {
        return Object.keys(keyCodes).some(code => keyCodes[code] === keyCode);
      }

      isFunctionKeyStroke(event) {
        return event.ctrlKey || event.metaKey || this.isNonPrintableKeyStroke(event.keyCode);
      }

      isValidNumericKeyStroke(event) {
        return /^[0-9eE.,+-]$/.test(event.key);
      }

      isDesktopBrowser() {
        return configProvider$1.getFormFactor() === 'DESKTOP';
      }

      normalizeDateTimeString(value) {
        let result = value;

        if (this.isTypeDate) {
          result = normalizeDate(value);
        } else if (this.isTypeTime) {
          result = normalizeTime(value);
        } else if (this.isTypeDateTime) {
          result = normalizeUTCDateTime(value, this.timezone);
        }

        return result;
      }

      get displayedValue() {
        if (this.isTypeNumber && !this._showRawNumber) {
          return this.getFormattedValue(this._value);
        }

        if (this.isTypeMobileDate || this.isTypeMobileDateTime || this.isTypeMobileTime) {
          return this.normalizeDateTimeString(this._value);
        }

        return this._value;
      }

      get _internalType() {
        if (this.isTypeNumber) {
          return 'text';
        }

        return this._type;
      }

      get isStandardVariant() {
        return this.variant === VARIANT.STANDARD || this.variant === VARIANT.LABEL_HIDDEN;
      }

      _updateValueAndValidityAttribute(value) {
        this._value = value;

        this._updateProxyInputAttributes('value');
      }

      _updateCheckedAndValidityAttribute(value) {
        this._checked = value;

        this._updateProxyInputAttributes('checked');
      }

      _calculateFractionDigitsFromStep(step) {
        // clear any previous value if set
        this._calculatedFractionDigits = undefined;

        if (step && step !== 'any') {
          let numDecimals = 0; // calculate number of decimals using step

          const decimals = String(step).split('.')[1]; // we're parsing the decimals to account for cases where the step is
          // '1.0'

          if (decimals && parseInt(decimals, 10) > 0) {
            numDecimals = decimals.length;
          }

          this._calculatedFractionDigits = numDecimals;
        }
      }

      get _ignoreRequired() {
        // If uploading via the drop zone or via the input directly, we should
        // ignore the required flag as a file has been uploaded
        return this.isTypeFile && this._required && (this.fileUploadedViaDroppableZone || this._files && this._files.length > 0);
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          const overrides = {
            badInput: () => {
              if (!this._connected) {
                return false;
              }

              if (this.isTypeNumber && this.getFormattedValue(this._value) === 'NaN') {
                return true;
              }

              if (!this.isNativeInput) {
                return this.inputElement.hasBadInput();
              }

              return this.inputElement.validity.badInput;
            },
            tooLong: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as maxlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._connected && this.inputElement.validity.tooLong,
            tooShort: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as minlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._connected && this.inputElement.validity.tooShort,
            patternMismatch: () => this.isNativeInput && this._connected && this.inputElement.validity.patternMismatch
          }; // FF, IE and Safari don't support type datetime-local,
          // IE and Safari don't support type date or time
          // we need to defer to the base component to check rangeOverflow/rangeUnderflow.
          // Due to the custom override, changing the type to or from datetime/time would affect the validation

          if (this.isTypeDesktopDateTime || this.isTypeDesktopTime || this.isTypeDesktopDate) {
            overrides.rangeOverflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const max = this.isTypeDesktopTime ? normalizeTime(this.max) : this.max;
              return isAfter(this.value, max);
            };

            overrides.rangeUnderflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const min = this.isTypeDesktopTime ? normalizeTime(this.min) : this.min;
              return isBefore(this.value, min);
            };
          }

          this._constraintApi = new FieldConstraintApiWithProxyInput(() => {
            // The date/time components display their own errors and have custom messages for badInput and rangeOverflow/Underflow.
            if (!this.isNativeInput) {
              return this.inputElement;
            }

            return this;
          }, overrides);
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            type: () => this.nativeInputType,
            // We need to normalize value so that it's consumable by the proxy input (otherwise the value
            // will be invalid for the native input)
            value: () => this.normalizeDateTimeString(this.value),
            checked: () => this.checked,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            // 'pattern' depends on type
            pattern: () => this.pattern,
            // 'max' and 'min' depend on type and timezone
            max: () => this.normalizedMax,
            min: () => this.normalizedMin,
            step: () => this.step,
            accept: () => this.accept,
            multiple: () => this.multiple,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            // depends on type and whether an upload has been made
            required: () => this.required && !this._ignoreRequired
          });
        }

        return this._constraintApi;
      }

      _updateInputDisplayValueIfTypeNumber() {
        // Displayed value depends on the format number, so if we're not showing the raw
        // number we should update the value
        if (this._connected && this.isTypeNumber && !this._showRawNumber && this.inputElement) {
          this.inputElement.value = this.displayedValue;
        }
      }

      _switchInputTypeToNumber() {
        this._showRawNumber = true;
        this.inputElement.value = this.displayedValue;
        this.inputElement.inputMode = 'decimal'; // The below check is needed due to a bug in Firefox with switching the
        // type to/from 'number'.
        // Remove the check once https://bugzilla.mozilla.org/show_bug.cgi?id=981248 is fixed

        const isFirefox = navigator.userAgent.indexOf('Firefox') >= 0;

        if (isFirefox) {
          if (this.validity.badInput) {
            // reset value manually for Firefox to emulate the behaviour of
            // a native input type number
            this.inputElement.value = '';
          }
        } else {
          this.inputElement.type = 'number';
        }
      }

    }

    LightningInput.delegatesFocus = true;

    lwc.registerDecorators(LightningInput, {
      publicProps: {
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        label: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenPatternMismatch: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 0
        },
        messageWhenRangeUnderflow: {
          config: 0
        },
        messageWhenStepMismatch: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenTypeMismatch: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageToggleActive: {
          config: 0
        },
        messageToggleInactive: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        formatFractionDigits: {
          config: 3
        },
        timeAriaControls: {
          config: 3
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 3
        },
        dateAriaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        formatter: {
          config: 3
        },
        type: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        pattern: {
          config: 3
        },
        maxLength: {
          config: 3
        },
        accept: {
          config: 3
        },
        minLength: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        step: {
          config: 3
        },
        checked: {
          config: 3
        },
        multiple: {
          config: 3
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        timezone: {
          config: 3
        },
        files: {
          config: 1
        },
        validity: {
          config: 1
        },
        fieldLevelHelp: {
          config: 3
        },
        accessKey: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "setCustomValidity", "reportValidity", "focus", "blur", "showHelpMessageIfInvalid"],
      track: {
        _timeAriaDescribedBy: 1,
        _timeAriaLabelledBy: 1,
        _timeAriaControls: 1,
        _dateAriaControls: 1,
        _dateAriaDescribedBy: 1,
        _dateAriaLabelledBy: 1,
        _value: 1,
        _type: 1,
        _pattern: 1,
        _max: 1,
        _min: 1,
        _step: 1,
        _disabled: 1,
        _readOnly: 1,
        _required: 1,
        _checked: 1,
        _isLoading: 1,
        _multiple: 1,
        _timezone: 1,
        _helpMessage: 1,
        _isColorPickerPanelOpen: 1,
        _fieldLevelHelp: 1,
        _accesskey: 1,
        _maxLength: 1,
        _minLength: 1,
        _accept: 1,
        _variant: 1,
        _connected: 1
      }
    });

    var _lightningInput = lwc.registerComponent(LightningInput, {
      tmpl: _tmpl$m
    });
    LightningInput.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function stylesheet$9(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$9 = [stylesheet$9];

    function stylesheet$a(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$a = [stylesheet$a];

    function tmpl$o($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        className: $cmp.computedClass,
        attrs: {
          "role": "status"
        },
        key: 2
      }, [$cmp.validAlternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.alternativeText)]) : null, api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 4
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 5
      }, [])])];
    }

    var _tmpl$n = lwc.registerTemplate(tmpl$o);
    tmpl$o.stylesheets = [];
    tmpl$o.stylesheetTokens = {
      hostAttribute: "lightning-spinner_spinner-host",
      shadowAttribute: "lightning-spinner_spinner"
    };

    /**
     * Displays an animated spinner.
     */

    class LightningSpinner extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = void 0;
        this.size = 'medium';
        this.variant = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-spinner_container');
        this.template.addEventListener('mousewheel', this.stopScrolling);
        this.template.addEventListener('touchmove', this.stopScrolling);
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'base',
          validValues: ['base', 'brand', 'inverse']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['small', 'medium', 'large']
        });
      }

      get computedClass() {
        const {
          normalizedVariant,
          normalizedSize
        } = this;
        const classes = classSet('slds-spinner'); // add variant-specific class

        if (normalizedVariant !== 'base') {
          classes.add(`slds-spinner_${normalizedVariant}`);
        } // add size-specific class


        classes.add(`slds-spinner_${normalizedSize}`);
        return classes.toString();
      } // alternativeText validation


      get validAlternativeText() {
        const hasAlternativeText = !!this.alternativeText; // if we have an empty value output a console warning

        if (!hasAlternativeText) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-spinner> The alternativeText attribute should not be empty. Please add a description of what is causing the wait.`);
        }

        return hasAlternativeText;
      } // prevent scrolling


      stopScrolling(event) {
        event.preventDefault();
      }

    }

    lwc.registerDecorators(LightningSpinner, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      }
    });

    var _lightningSpinner = lwc.registerComponent(LightningSpinner, {
      tmpl: _tmpl$n
    });

    function tmpl$p($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        ti: api_tab_index,
        b: api_bind,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        attrs: {
          "role": "group",
          "aria-labelledby": `${api_scoped_id("group-label")}`
        },
        key: 2
      }, [api_element("div", {
        className: $cmp.computedGroupLabelClass,
        attrs: {
          "id": api_scoped_id("group-label")
        },
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 6
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-dueling-list": true
        },
        key: 8,
        on: {
          "focusin": _m8 || ($ctx._m8 = api_bind($cmp.handleFocus)),
          "focusout": _m9 || ($ctx._m9 = api_bind($cmp.handleBlur))
        }
      }, [api_element("div", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("assertive-thing"),
          "aria-live": "assertive"
        },
        key: 9
      }, []), api_element("div", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("keyboard-interacton")
        },
        key: 10
      }, [api_dynamic($cmp.i18n.componentAssistiveText)]), api_element("div", {
        className: $cmp.computedLeftColumnClass,
        key: 11
      }, [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "id": api_scoped_id("source-list-label")
        },
        key: 12
      }, [api_dynamic($cmp.sourceLabel)]), api_element("div", {
        className: $cmp.computedListboxContainerClass,
        style: $cmp.computedColumnStyle,
        key: 13
      }, [api_element("ul", {
        classMap: {
          "slds-listbox": true,
          "slds-listbox_vertical": true
        },
        attrs: {
          "data-source-list": true,
          "id": api_scoped_id("source-list"),
          "aria-describedby": `${api_scoped_id("keyboard-interacton")}`,
          "aria-labelledby": `${api_scoped_id("source-list-label")}`,
          "aria-multiselectable": "true",
          "role": "listbox",
          "aria-disabled": $cmp.ariaDisabled
        },
        key: 14
      }, api_iterator($cmp.computedSourceList, function (option, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(16, option.value)
        }, [api_element("div", {
          className: option.classList,
          attrs: {
            "aria-selected": option.selected,
            "role": "option",
            "tabindex": api_tab_index(option.tabIndex),
            "data-index": index,
            "data-value": option.value,
            "data-type": $cmp.computedSourceListId
          },
          key: 17,
          on: {
            "click": _m0 || ($ctx._m0 = api_bind($cmp.handleOptionClick)),
            "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleOptionKeyDown))
          }
        }, [api_element("span", {
          classMap: {
            "slds-media__body": true
          },
          key: 18
        }, [api_element("span", {
          classMap: {
            "slds-truncate": true
          },
          attrs: {
            "title": option.label
          },
          key: 19
        }, [api_dynamic(option.label)])])])]);
      }))]), $cmp.showActivityIndicator ? api_element("div", {
        key: 20
      }, [api_custom_element("lightning-spinner", _lightningSpinner, {
        props: {
          "size": "small",
          "variant": "brand",
          "alternativeText": $cmp.i18n.loadingText
        },
        key: 21
      }, [])]) : null]), api_element("div", {
        classMap: {
          "slds-dueling-list__column": true
        },
        key: 22
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "disabled": $cmp.moveButtonsDisabled,
          "title": $cmp.addButtonLabel,
          "alternativeText": $cmp.addButtonLabel
        },
        key: 23,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleRightButtonClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "disabled": $cmp.moveButtonsDisabled,
          "title": $cmp.removeButtonLabel,
          "alternativeText": $cmp.removeButtonLabel
        },
        key: 24,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleLeftButtonClick))
        }
      }, [])]), api_element("div", {
        classMap: {
          "slds-dueling-list__column": true,
          "slds-dueling-list__column_responsive": true
        },
        key: 25
      }, [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "id": api_scoped_id("selected-list-label")
        },
        key: 26
      }, [api_dynamic($cmp.selectedLabel)]), api_element("div", {
        className: $cmp.computedListboxContainerClass,
        style: $cmp.computedColumnStyle,
        key: 27
      }, [api_element("ul", {
        classMap: {
          "slds-listbox": true,
          "slds-listbox_vertical": true
        },
        attrs: {
          "data-selected-list": true,
          "id": api_scoped_id("selected-list"),
          "aria-describedby": `${api_scoped_id("keyboard-interacton")}`,
          "aria-labelledby": `${api_scoped_id("selected-list-label")}`,
          "aria-multiselectable": "true",
          "role": "listbox",
          "aria-disabled": $cmp.ariaDisabled
        },
        key: 28
      }, api_iterator($cmp.computedSelectedList, function (option, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(30, option.value)
        }, [api_element("div", {
          className: option.classList,
          attrs: {
            "aria-selected": option.selected,
            "role": "option",
            "tabindex": api_tab_index(option.tabIndex),
            "data-index": index,
            "data-value": option.value,
            "data-type": $cmp.computedSelectedListId
          },
          key: 31,
          on: {
            "click": _m4 || ($ctx._m4 = api_bind($cmp.handleOptionClick)),
            "keydown": _m5 || ($ctx._m5 = api_bind($cmp.handleOptionKeyDown))
          }
        }, [api_element("span", {
          classMap: {
            "slds-media__body": true
          },
          key: 32
        }, [api_element("span", {
          classMap: {
            "slds-truncate": true
          },
          attrs: {
            "title": option.label
          },
          key: 33
        }, [api_dynamic(option.label)])]), option.isLocked ? api_element("span", {
          classMap: {
            "slds-media__figure": true,
            "slds-media__figure_reverse": true
          },
          key: 35
        }, [api_custom_element("lightning-icon", _lightningIcon, {
          props: {
            "iconName": "utility:lock",
            "size": "x-small",
            "alternativeText": $cmp.computedLockAssistiveText
          },
          key: 36
        }, [])]) : null])]);
      }))])]), !$cmp.disableReordering ? api_element("div", {
        classMap: {
          "slds-dueling-list__column": true
        },
        key: 38
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:up",
          "variant": "container",
          "disabled": $cmp.disabled,
          "title": $cmp.upButtonLabel,
          "alternativeText": $cmp.upButtonLabel
        },
        key: 39,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleUpButtonClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:down",
          "variant": "container",
          "disabled": $cmp.disabled,
          "title": $cmp.downButtonLabel,
          "alternativeText": $cmp.downButtonLabel
        },
        key: 40,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.handleDownButtonClick))
        }
      }, [])]) : null])]), $cmp.errorMessage ? api_element("span", {
        classMap: {
          "slds-has-error": true,
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "aria-live": "assertive"
        },
        key: 42
      }, [api_dynamic($cmp.errorMessage)]) : null])];
    }

    var _tmpl$o = lwc.registerTemplate(tmpl$p);
    tmpl$p.stylesheets = [];

    if (_implicitStylesheets$a) {
      tmpl$p.stylesheets.push.apply(tmpl$p.stylesheets, _implicitStylesheets$a);
    }
    tmpl$p.stylesheetTokens = {
      hostAttribute: "lightning-dualListbox_dualListbox-host",
      shadowAttribute: "lightning-dualListbox_dualListbox"
    };

    var labelComponentAssistiveText = 'Press Ctrl (Cmd on Mac) + Left Arrow or Ctrl (Cmd on Mac) + Right Arrow to move items between lists.';

    var labelDownButtonAssistiveText = 'Move selection down';

    var labelMaxError = 'Select at most {0} options';

    var labelMaxHelp = ' [and a maximum of {0}]';

    var labelMinErrorPlural = 'Select at least {0} options';

    var labelMinErrorSingular = 'Select at least 1 option';

    var labelMinHelp = ' [and a minimum of {0}]';

    var labelMinRequiredErrorPlural = 'At least {0} options must be selected';

    var labelMinRequiredErrorSingular = 'At least 1 option must be selected';

    var labelOptionLockAssistiveText = ': item cannot be removed from {0}';

    var labelRequiredError = 'An option must be selected';

    var labelRequiredOptionError = '{0} must be selected';

    var labelUpButtonAssistiveText = 'Move selection up';

    var labelMoveSelectionToAssistiveText = 'Move selection to {0}';

    function preventDefaultAndStopPropagation$3(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function setFocusOnNextOption(option, moveUp, intf) {
      const index = parseInt(option.getAttribute('data-index'), 10);
      const i = index + (moveUp ? -1 : 1);
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const next = options[i];

      if (next) {
        next.focus();
      }
    }

    function selectNextOption(option, moveUp, intf) {
      const selected = option.getAttribute('aria-selected') === 'true';
      const index = parseInt(option.getAttribute('data-index'), 10);
      const i = index + (selected ? moveUp ? -1 : 1 : 0);
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const next = options[i];

      if (next) {
        intf.updateSelectedOptions(next, true, false);
      }
    }

    function selectNextOptionFromShift(option, moveUp, isMultiple, intf) {
      const curr = parseInt(option.getAttribute('data-index'), 10);

      if (intf.getShiftIndex() < 0) {
        intf.setShiftIndex(curr);
        intf.setLastShift(moveUp);
      }

      const next = curr + (intf.getLastShift() !== moveUp ? 0 : moveUp ? -1 : 1);
      const pos = next < intf.getShiftIndex();
      const shiftAdd = pos === moveUp || intf.getShiftIndex() === next;
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const nextOption = options[next];

      if (nextOption) {
        intf.updateSelectedOptions(nextOption, shiftAdd, true);
        intf.setLastShift(moveUp);
      }
    }

    function handleKeyDownOnOption(event, keyboardInterface) {
      if (event.metaKey || event.ctrlKey) {
        keyboardInterface.setShiftIndex(-1);
        const keyCodesA = 'A'.charCodeAt(0);
        const selected = event.target.getAttribute('aria-selected') === 'true';

        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            setFocusOnNextOption(event.target, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            setFocusOnNextOption(event.target, false, keyboardInterface);
            break;

          case keyCodes.right:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.moveOptionsBetweenLists(true);
            break;

          case keyCodes.left:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.moveOptionsBetweenLists(false);
            break;

          case keyCodes.space:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.updateSelectedOptions(event.target, !selected, true);
            break;

          case keyCodesA:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.selectAllOptions(event.target);
            break;

          default: // do nothing

        }
      } else if (event.shiftKey) {
        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            selectNextOptionFromShift(event.target, true, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            selectNextOptionFromShift(event.target, false, true, keyboardInterface);
            break;

          default: // do nothing

        }
      } else {
        keyboardInterface.setShiftIndex(-1);

        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            selectNextOption(event.target, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            selectNextOption(event.target, false, keyboardInterface);
            break;

          default: // do nothing

        }
      }
    }

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(Object(source)); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const i18n$b = {
      componentAssistiveText: labelComponentAssistiveText,
      downButtonAssistiveText: labelDownButtonAssistiveText,
      maxError: labelMaxError,
      maxHelp: labelMaxHelp,
      minErrorPlural: labelMinErrorPlural,
      minErrorSingular: labelMinErrorSingular,
      minHelp: labelMinHelp,
      minRequiredErrorPlural: labelMinRequiredErrorPlural,
      minRequiredErrorSingular: labelMinRequiredErrorSingular,
      optionLockAssistiveText: labelOptionLockAssistiveText,
      required: labelRequired,
      requiredError: labelRequiredError,
      requiredOptionError: labelRequiredOptionError,
      upButtonAssistiveText: labelUpButtonAssistiveText,
      moveSelectionToAssistiveText: labelMoveSelectionToAssistiveText,
      loadingText: labelLoadingText
    };
    /**
     * A pair of listboxes that enables multiple options to be selected and reordered.
     */

    class LightningDualListbox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.sourceLabel = void 0;
        this.selectedLabel = void 0;
        this.label = void 0;
        this.options = void 0;
        this.min = 0;
        this.max = void 0;
        this.name = void 0;
        this._showActivityIndicator = false;
        this._requiredOptions = [];
        this._selectedValues = [];
        this._variant = void 0;
        this._disabled = void 0;
        this._disableReordering = false;
        this._required = false;
        this._addButtonLabel = void 0;
        this._removeButtonLabel = void 0;
        this._upButtonLabel = void 0;
        this._downButtonLabel = void 0;
        this._size = void 0;
        this.errorMessage = '';
        this.highlightedOptions = [];
        this.focusableInSource = void 0;
        this.focusableInSelected = void 0;
        this.isFocusOnList = false;
        this.messageWhenValueMissing = i18n$b.requiredError;
        this.fieldLevelHelp = void 0;
      }

      /**
       * Error message to be displayed when a range overflow is detected.
       * @type {string}
       */
      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this._overflowMessage;
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }
      /**
       * Error message to be displayed when a range underflow is detected.
       * @type {string}
       */


      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this._underflowMessage;
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }
      /**
       * If present, the listbox is disabled and users cannot interact with it.
       * @type {string}
       */


      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the user must add an item to the selected listbox before submitting the form.
       * @type {string}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * A list of default options that are included in the selected options listbox. This list is populated with values from the options attribute.
       * @type {list}
       */


      get value() {
        return this._selectedValues;
      }

      set value(newValue) {
        this._selectedValues = newValue || [];

        if (this._connected) {
          this.addRequiredOptionsToValue();
        }
      }
      /**
       * A list of required options that cannot be removed from selected options listbox. This list is populated with values from the options attribute.
       * @type {list}
       */


      get requiredOptions() {
        return this._requiredOptions;
      }

      set requiredOptions(newValue) {
        this._requiredOptions = newValue || [];

        if (this._connected) {
          this.addRequiredOptionsToValue();
        }
      }
      /**
       * The variant changes the appearance of the dual listbox.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and dual listbox.
       * Use label-stacked to place the label above the dual listbox.
       * @type {string}
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      set size(value) {
        this._size = value;
      }
      /**
       * Number of items that display in the listboxes before vertical scrollbars are displayed. Determines the vertical size of the listbox.
       * @type {number}
       * @default
       */


      get size() {
        return this._size;
      }
      /**
       * Help text detailing the purpose and function of the dual listbox.
       * @type {string}
       */


      set disableReordering(value) {
        this._disableReordering = normalizeBoolean(value);
      }
      /**
       * If present, the Up and Down buttons used for reordering the selected list items are hidden.
       * @type {boolean}
       * @default false
       */


      get disableReordering() {
        return this._disableReordering;
      }
      /**
       * If present, a spinner is displayed in the first listbox to indicate loading activity.
       * @type {boolean}
       * @default false
       */


      get showActivityIndicator() {
        return this._showActivityIndicator;
      }

      set showActivityIndicator(value) {
        this._showActivityIndicator = normalizeBoolean(value);
      }
      /**
       * Sets focus on the first option from either list.
       * If the source list doesn't contain any options, the first option on the selected list is focused on.
       */


      focus() {
        // focus on the first option from either list
        // if nothing on source, then it'll pick the one on selected
        const firstOption = this.template.querySelector(`div[data-index='0']`);

        if (firstOption) {
          firstOption.focus();
          this.updateSelectedOptions(firstOption, true, false);
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the dual listbox meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this.errorMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the dual listbox value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message
       *     is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays an error message if the dual listbox value is required.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.keyboardInterface = this.selectKeyboardInterface();
        this._connected = true;
        this.addRequiredOptionsToValue(); // debounceInteraction since DualListbox has multiple focusable elements

        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.showHelpMessageIfInvalid();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        this.assertRequiredAttributes();

        if (this.disabled) {
          return;
        }

        if (this.optionToFocus) {
          // value could have an apostrophe, which is why we need to escape it otherwise the queryselector will not work
          const option = this.template.querySelector(`div[data-value='${this.optionToFocus.replace(/'/g, "\\'")}']`);

          if (option) {
            this.isFocusOnList = true;
            option.focus();
          }
        }
      }

      get computedUniqueId() {
        return this.uniqueId;
      }

      get computedSourceListId() {
        return getRealDOMId(this.template.querySelector('[data-source-list]'));
      }

      get computedSelectedListId() {
        return getRealDOMId(this.template.querySelector('[data-selected-list]'));
      }

      get ariaDisabled() {
        // aria-disabled works only with String not Boolean value
        return String(this.disabled);
      }

      get computedSourceList() {
        let sourceListOptions = [];

        if (this.options) {
          const required = this.requiredOptions;
          const values = this.value;
          sourceListOptions = this.options.filter(option => values.indexOf(option.value) === -1 && required.indexOf(option.value) === -1);
        }

        return this.computeListOptions(sourceListOptions, this.focusableInSource);
      }

      get computedSelectedList() {
        const selectedListOptions = [];

        if (this.options) {
          const optionsMap = {};
          this.options.forEach(option => {
            optionsMap[option.value] = _objectSpread$2({}, option);
          });
          this.value.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              option.isSelected = true;
            }
          });
          this.requiredOptions.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              option.isLocked = true;
            }
          }); // add selected items in the given order

          this.value.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              selectedListOptions.push(option);
            }
          });
        }

        return this.computeListOptions(selectedListOptions, this.focusableInSelected);
      }

      computeListOptions(options, focusableOptionValue) {
        if (options.length > 0) {
          const focusableOption = options.find(option => {
            return option.value === focusableOptionValue;
          });
          const focusableValue = focusableOption ? focusableOption.value : options[0].value;
          return options.map(option => {
            return this.computeOptionProperties(option, focusableValue);
          });
        }

        return [];
      }

      computeOptionProperties(option, focusableValue) {
        const isSelected = this.highlightedOptions.indexOf(option.value) > -1;
        const classList = classSet('slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline').add({
          'slds-is-selected': isSelected
        }).toString();
        return _objectSpread$2({}, option, {
          tabIndex: option.value === focusableValue ? '0' : '-1',
          selected: isSelected ? 'true' : 'false',
          classList
        });
      }

      get computedLeftColumnClass() {
        return classSet('slds-dueling-list__column slds-dueling-list__column_responsive').add({
          'slds-is-relative': this.showActivityIndicator
        }).toString();
      }

      get computedColumnStyle() {
        if (this.isNumber(this.size)) {
          // From the SLDS page on how to adjust the height: lightningdesignsystem.com/components/dueling-picklist/#Responsive
          const newHeight = parseInt(this.size, 10) * 2.25 + 1;
          return `height:${newHeight}rem`;
        }

        return '';
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedGroupLabelClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedListboxContainerClass() {
        return classSet('slds-dueling-list__options').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedLockAssistiveText() {
        return this.formatString(this.i18n.optionLockAssistiveText, this.selectedLabel);
      }

      get i18n() {
        return i18n$b;
      }

      getRightButtonAssistiveText() {
        return this.formatString(i18n$b.moveSelectionToAssistiveText, this.selectedLabel);
      }
      /**
       * Label for add button.
       * @type {string}
       * @default Move selection to {selectedLabel}
       */


      get addButtonLabel() {
        if (this._addButtonLabel) {
          return this._addButtonLabel;
        }

        return this.getRightButtonAssistiveText();
      }

      set addButtonLabel(value) {
        this._addButtonLabel = value;
      }

      getLeftButtonAssistiveText() {
        return this.formatString(i18n$b.moveSelectionToAssistiveText, this.sourceLabel);
      }
      /**
       * Label for remove button.
       * @type {string}
       * @default "Move selection to {sourceLabel}"
       */


      get removeButtonLabel() {
        if (this._removeButtonLabel) {
          return this._removeButtonLabel;
        }

        return this.getLeftButtonAssistiveText();
      }

      set removeButtonLabel(value) {
        this._removeButtonLabel = value;
      }
      /**
       * Label for up button.
       * @type {string}
       * @default "Move selection up"
       */


      get upButtonLabel() {
        return this._upButtonLabel || this.i18n.upButtonAssistiveText;
      }

      set upButtonLabel(value) {
        this._upButtonLabel = value;
      }
      /**
       * Label for down button.
       * @type {string}
       * @default "Move selection down"
       */


      get downButtonLabel() {
        return this._downButtonLabel || this.i18n.downButtonAssistiveText;
      }

      set downButtonLabel(value) {
        this._downButtonLabel = value;
      }

      get moveButtonsDisabled() {
        return this.disabled || this.showActivityIndicator;
      }

      handleOptionClick(event) {
        this.interactingState.interacting();

        if (this.disabled) {
          return;
        }

        const selectMultiple = event.metaKey || event.ctrlKey || event.shiftKey;
        const option = event.currentTarget;

        if (event.shiftKey) {
          this.selectAllFromLastSelectedToOption(option, false);
          return;
        }

        const selected = selectMultiple && option.getAttribute('aria-selected') === 'true';
        this.updateSelectedOptions(option, !selected, selectMultiple);
        this.shiftIndex = -1;
      }

      handleFocus(event) {
        this.interactingState.enter(); // select the focused option if entering a listbox

        const element = event.target;

        if (element.role === 'option') {
          if (!this.isFocusOnList) {
            this.isFocusOnList = true;
            this.updateSelectedOptions(element, true, false);
          }
        }
      }

      handleBlur(event) {
        this.interactingState.leave();
        const element = event.target;

        if (element.role !== 'option') {
          this.isFocusOnList = false;
        }
      }

      handleRightButtonClick() {
        this.interactingState.interacting();
        this.moveOptionsBetweenLists(true);
      }

      handleLeftButtonClick() {
        this.interactingState.interacting();
        this.moveOptionsBetweenLists(false);
      }

      handleUpButtonClick() {
        this.interactingState.interacting();
        this.changeOrderOfOptionsInList(true);
      }

      handleDownButtonClick() {
        this.interactingState.interacting();
        this.changeOrderOfOptionsInList(false);
      }

      handleOptionKeyDown(event) {
        this.interactingState.interacting();

        if (this.disabled) {
          return;
        }

        handleKeyDownOnOption(event, this.keyboardInterface);
      }

      moveOptionsBetweenLists(addToSelect, retainFocus) {
        const isValidList = addToSelect ? this.selectedList === this.computedSourceListId : this.selectedList === this.computedSelectedListId;

        if (!isValidList) {
          return;
        }

        const toMove = this.highlightedOptions;
        const values = this.computedSelectedList.map(option => option.value);
        const required = this.requiredOptions;
        let newValues = [];

        if (addToSelect) {
          newValues = values.concat(toMove);
        } else {
          newValues = values.filter(value => toMove.indexOf(value) === -1 || required.indexOf(value) > -1);
        }

        const oldSelectedValues = this._selectedValues;
        this._selectedValues = newValues;
        const invalidMove = this.validity.valueMissing || this.validity.rangeOverflow && this.selectedList === this.computedSourceListId || this.validity.rangeUnderflow && this.selectedList === this.computedSelectedListId;

        if (invalidMove || toMove.length === 0) {
          this.showHelpMessageIfInvalid();
          this._selectedValues = oldSelectedValues;
          return;
        }

        if (retainFocus) {
          const listId = addToSelect ? this.computedSelectedListId : this.computedSourceListId;
          this.selectedList = listId;
          this.updateFocusableOption(listId, toMove[0]);
        } else {
          this.interactingState.leave();
          this.isFocusOnList = false;
          this.highlightedOptions = [];
          this.optionToFocus = null;
        }

        this.dispatchChangeEvent(newValues);
      }

      changeOrderOfOptionsInList(moveUp) {
        const elementList = this.getElementsOfList(this.selectedList);
        const values = this.computedSelectedList.map(option => option.value);
        const toMove = values.filter(option => this.highlightedOptions.indexOf(option) > -1);
        const validSelection = toMove.length === 0 || this.selectedList !== this.computedSelectedListId;

        if (validSelection) {
          return;
        }

        let start = moveUp ? 0 : toMove.length - 1;
        let index = values.indexOf(toMove[start]);
        const validMove = moveUp && index === 0 || !moveUp && index === values.length - 1;

        if (validMove) {
          return;
        }

        if (moveUp) {
          while (start < toMove.length) {
            index = values.indexOf(toMove[start]);
            this.swapOptions(index, index - 1, values, elementList);
            start++;
          }
        } else {
          while (start > -1) {
            index = values.indexOf(toMove[start]);
            this.swapOptions(index, index + 1, values, elementList);
            start--;
          }
        }

        this._selectedValues = values;
        this.updateFocusableOption(this.selectedList, toMove[0]);
        this.optionToFocus = null;
        this.dispatchChangeEvent(values);
      }

      selectAllFromLastSelectedToOption(option, all) {
        const listId = option.getAttribute('data-type');
        this.updateCurrentSelectedList(listId, true);
        const options = this.getElementsOfList(listId);
        const end = all ? 0 : this.getOptionIndex(option);
        this.lastSelected = this.lastSelected < 0 ? end : this.lastSelected;
        const start = all ? options.length : this.lastSelected;
        let val, select;
        this.highlightedOptions = [];

        for (let i = 0; i < options.length; i++) {
          select = (i - start) * (i - end) <= 0;

          if (select) {
            val = options[i].getAttribute('data-value');
            this.highlightedOptions.push(val);
          }
        }
      }

      updateSelectedOptions(option, select, isMultiple) {
        const value = option.getAttribute('data-value');
        const listId = this.getListId(option);
        const optionIndex = this.getOptionIndex(option);
        this.updateCurrentSelectedList(listId, isMultiple);

        if (select) {
          if (this.highlightedOptions.indexOf(value) === -1) {
            this.highlightedOptions.push(value);
          }
        } else {
          this.highlightedOptions.splice(this.highlightedOptions.indexOf(value), 1);
        }

        this.updateFocusableOption(listId, value);
        this.lastSelected = optionIndex;
      }

      addRequiredOptionsToValue() {
        if (!this.options || !this.options.length || !this._requiredOptions || !this._requiredOptions.length) {
          // no options/requiredOptions, just ignore
          return;
        }

        const numOfSelectedValues = this._selectedValues.length;
        const allValues = this.options.map(option => option.value);

        const requiredValues = this._requiredOptions.filter(option => allValues.includes(option)); // add required options to the selected values as they are already displayed in the selected list


        this._selectedValues = [...new Set([...requiredValues, ...this._selectedValues])];

        if (numOfSelectedValues !== this._selectedValues.length) {
          // value was changed
          this.dispatchChangeEvent(this._selectedValues);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && this.computedSelectedList.length < 1,
            rangeUnderflow: () => this.computedSelectedList.length < this.min,
            rangeOverflow: () => this.computedSelectedList.length > this.max
          });
        }

        return this._constraintApi;
      }

      get _overflowMessage() {
        const minHelpMsg = this.min > 0 ? this.formatString(this.i18n.minHelp, this.min) : '';
        return this.formatString(this.i18n.maxError, this.max) + minHelpMsg;
      }

      get _underflowMessage() {
        const maxHelpMsg = this.max ? this.formatString(this.i18n.maxHelp, this.max) : '';
        const minRequiredError = this.min > 1 ? this.formatString(this.i18n.minRequiredErrorPlural, this.min) : this.i18n.minRequiredErrorSingular;
        const minError = this.min > 1 ? this.formatString(this.i18n.minErrorPlural, this.min) : this.i18n.minErrorSingular;
        return this.required ? minRequiredError + maxHelpMsg : minError + maxHelpMsg;
      }

      updateCurrentSelectedList(currentList, isMultiple) {
        if (this.selectedList !== currentList || !isMultiple) {
          if (this.selectedList) {
            this.highlightedOptions = [];
            this.lastSelected = -1;
          }

          this.selectedList = currentList;
        }
      }

      dispatchChangeEvent(values) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: values
          }
        }));
      }

      assertRequiredAttributes() {
        assert(!!this.label, `<lightning-dual-listbox> Missing required "label" attribute.`);
        assert(!!this.sourceLabel, `<lightning-dual-listbox> Missing required "sourceLabel" attribute.`);
        assert(!!this.selectedLabel, `<lightning-dual-listbox> Missing required "selectedLabel" attribute.`);
        assert(!!this.options, `<lightning-dual-listbox> Missing required "options" attribute.`);
      }

      swapOptions(i, j, array) {
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }

      formatString(str, ...args) {
        if (str) {
          return str.replace(/{(\d+)}/g, (match, i) => {
            return typeof args[i] !== 'undefined' ? args[i] : match;
          });
        }

        return '';
      }

      getElementsOfList(listId) {
        const elements = this.template.querySelectorAll(`div[data-type='${listId}']`);
        return elements ? elements : [];
      }

      selectKeyboardInterface() {
        const that = this;
        that.shiftIndex = -1;
        that.lastShift = null;
        return {
          getShiftIndex() {
            return that.shiftIndex;
          },

          setShiftIndex(value) {
            that.shiftIndex = value;
          },

          getLastShift() {
            return that.lastShift;
          },

          setLastShift(value) {
            that.lastShift = value;
          },

          getElementsOfList(listId) {
            return that.getElementsOfList(listId);
          },

          selectAllOptions(option) {
            that.selectAllFromLastSelectedToOption(option, true);
          },

          updateSelectedOptions(option, select, isMultiple) {
            that.updateSelectedOptions(option, select, isMultiple);
          },

          moveOptionsBetweenLists(addToSelect) {
            that.moveOptionsBetweenLists(addToSelect, true);
          }

        };
      }

      getOptionIndex(optionElement) {
        return parseInt(optionElement.getAttribute('data-index'), 10);
      }

      getListId(optionElement) {
        return getRealDOMId(optionElement.parentElement.parentElement);
      }

      updateFocusableOption(listId, value) {
        if (listId === this.computedSourceListId) {
          this.focusableInSource = value;
        } else if (listId === this.computedSelectedListId) {
          this.focusableInSelected = value;
        }

        this.optionToFocus = value;
      }

      isNumber(value) {
        return value !== '' && value !== null && isFinite(value);
      }

    }

    lwc.registerDecorators(LightningDualListbox, {
      publicProps: {
        sourceLabel: {
          config: 0
        },
        selectedLabel: {
          config: 0
        },
        label: {
          config: 0
        },
        options: {
          config: 0
        },
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        value: {
          config: 3
        },
        requiredOptions: {
          config: 3
        },
        variant: {
          config: 3
        },
        size: {
          config: 3
        },
        fieldLevelHelp: {
          config: 0
        },
        disableReordering: {
          config: 3
        },
        showActivityIndicator: {
          config: 3
        },
        validity: {
          config: 1
        },
        addButtonLabel: {
          config: 3
        },
        removeButtonLabel: {
          config: 3
        },
        upButtonLabel: {
          config: 3
        },
        downButtonLabel: {
          config: 3
        }
      },
      publicMethods: ["focus", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _showActivityIndicator: 1,
        _requiredOptions: 1,
        _selectedValues: 1,
        _variant: 1,
        _disabled: 1,
        _disableReordering: 1,
        _required: 1,
        _addButtonLabel: 1,
        _removeButtonLabel: 1,
        _upButtonLabel: 1,
        _downButtonLabel: 1,
        _size: 1,
        errorMessage: 1,
        highlightedOptions: 1,
        focusableInSource: 1,
        focusableInSelected: 1
      }
    });

    var _lightningDualListbox = lwc.registerComponent(LightningDualListbox, {
      tmpl: _tmpl$o
    });

    function stylesheet$b(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$b = [stylesheet$b];

    function tmpl$q($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp._fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp._fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "name": $cmp.name,
          "disabled": $cmp.disabled,
          "placeholder": $cmp.placeholder,
          "items": $cmp._items,
          "inputText": $cmp._selectedLabel,
          "inputIconSize": "xx-small",
          "inputIconName": "utility:down",
          "showDropdownActivityIndicator": $cmp.spinnerActive,
          "dropdownAlignment": $cmp.dropdownAlignment
        },
        key: 7,
        on: {
          "dropdownopen": _m0 || ($ctx._m0 = api_bind($cmp.handleDropdownOpen)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "ready": _m3 || ($ctx._m3 = api_bind($cmp.handleComboboxReady)),
          "select": _m4 || ($ctx._m4 = api_bind($cmp.handleSelect))
        }
      }, [])]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-text"),
          "data-help-text": true,
          "aria-live": "assertive"
        },
        key: 9
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$p = lwc.registerTemplate(tmpl$q);
    tmpl$q.stylesheets = [];

    if (_implicitStylesheets$b) {
      tmpl$q.stylesheets.push.apply(tmpl$q.stylesheets, _implicitStylesheets$b);
    }
    tmpl$q.stylesheetTokens = {
      hostAttribute: "lightning-combobox_combobox-host",
      shadowAttribute: "lightning-combobox_combobox"
    };

    var labelPlaceholder = 'Select an Option';

    const i18n$c = {
      required: labelRequired,
      placeholder: labelPlaceholder
    };
    /**
     * A widget that provides an input field that is readonly,
     * accompanied by a dropdown list of selectable options.
     */

    class LightningCombobox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._ariaLabelledBy = '';
        this._ariaDescribedBy = '';
        this._fieldLevelHelp = '';
        this._selectedLabel = '';
        this._disabled = false;
        this._readOnly = false;
        this._spinnerActive = false;
        this._required = false;
        this.label = void 0;
        this.dropdownAlignment = 'left';
        this.placeholder = i18n$c.placeholder;
        this.messageWhenValueMissing = void 0;
        this.name = void 0;
        this._items = [];
        this._variant = void 0;
        this._helpMessage = void 0;
        this._labelForId = void 0;
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid()); // The connected logic here is needed because at the point when @api setters
        // are called other values may not have been set yet, so it could happen that the 'value' was set, but 'options'
        // are not available, or that the 'options' and 'value' have been set but 'multiple' hasn't been set yet.
        // So here we make sure that we start processing the data only once the element is actually in DOM, which
        // should be beneficial for performance as well

        this.connected = true;
        this._items = this.generateItems(this.options);

        if (this.options && this.selectedValue !== undefined) {
          this.updateSelectedOptions();
        }
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this.connected = false;
      }
      /**
       * Reserved for internal use. Use the standard aria-labelledby instead. A space-separated list of element IDs that provide labels for the combobox.
       * @type {string}
       */


      get ariaLabelledBy() {
        return this._ariaLabelledBy;
      }

      set ariaLabelledBy(labelledBy) {
        this._ariaLabelledBy = labelledBy;
      }
      /**
       * Reserved for internal use. Use the standard aria-describedby instead. A space-separated list of element IDs that provide descriptive labels for the combobox.
       * @type {string}
       */


      get ariaDescribedBy() {
        return this._ariaDescribedBy;
      }

      set ariaDescribedBy(describedBy) {
        this._ariaDescribedBy = describedBy;
      }
      /**
       * Help text detailing the purpose and function of the combobox.
       * @type {string}
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * The variant changes the appearance of the combobox.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and combobox.
       * Use label-stacked to place the label above the combobox.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this.selectedValue;
      }

      set value(newValue) {
        // There are some cases where this won't work correctly
        // See https://git.soma.salesforce.com/raptor/raptor/issues/457
        if (newValue !== this.selectedValue) {
          this.selectedValue = newValue;

          if (this.connected && this.options) {
            this.updateSelectedOptions();
          }
        }
      }
      /**
       * A list of options that are available for selection. Each option has the following attributes: label and value.
       * @type {object[]}
       * @required
       */


      get options() {
        return this._options || [];
      }

      set options(newValue) {
        this._options = normalizeArray(newValue);

        if (this.connected) {
          this._items = this.generateItems(this._options);
          this.updateSelectedOptions();
        }
      }
      /**
       * If present, the combobox is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled || this._readOnly || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the combobox is read-only.
       * A read-only combobox is also disabled.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this.disabled;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);
      }
      /**
       * If present, a value must be selected before the form can be submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * If present, a spinner is displayed below the menu items to indicate loading activity.
       * @type {boolean}
       * @default false
       */


      get spinnerActive() {
        return this._spinnerActive;
      }

      set spinnerActive(value) {
        this._spinnerActive = normalizeBoolean(value);
      }
      /**
       * Sets focus on the combobox.
       */


      focus() {
        if (this.connected) {
          this.getBaseComboboxElement().focus();
        }
      }
      /**
       * Removes focus from the combobox.
       */


      blur() {
        if (this.connected) {
          this.getBaseComboboxElement().blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       * @required
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the combobox has any validity errors.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the combobox.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the combobox value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message
       * is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Shows the help message if the combobox is in an invalid state.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleComboboxReady(e) {
        this._labelForId = e.detail.id;
      }

      synchronizeA11y() {
        synchronizeAttrs(this.template.querySelector('label'), {
          for: this._labelForId
        });
        const baseCombobox = this.template.querySelector('lightning-base-combobox');
        baseCombobox.inputLabelledByElement = this.ariaLabelledBy;
        baseCombobox.inputDescribedByElements = this.computedAriaDescribedBy;
      }

      get i18n() {
        return i18n$c;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        const describedByElements = [];

        if (this._helpMessage) {
          const helpText = this.template.querySelector('[data-help-text]');
          describedByElements.push(helpText);
        }

        if (typeof this.ariaDescribedBy === 'string') {
          describedByElements.push(this.ariaDescribedBy);
        }

        return describedByElements;
      }

      handleSelect(event) {
        if (event.detail.value === this.selectedValue) {
          return;
        }

        this.selectedValue = event.detail.value;
        this.updateSelectedOptions();
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this.selectedValue
          }
        }));
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleDropdownOpen() {
        this.dispatchEvent(new CustomEvent('open'));
      }

      updateSelectedOptions() {
        this.updateSelectedLabelFromValue(this.selectedValue);
        this.markOptionSelectedFromValue(this.selectedValue);
      }

      markOptionSelectedFromValue(value) {
        if (this._items) {
          const selectedItem = this._items.find(item => item.value === value); // de-select previously selected item


          if (this._selectedItem) {
            this._selectedItem.iconName = undefined;
            this._selectedItem.highlight = false;
          }

          this._selectedItem = selectedItem;

          if (selectedItem) {
            selectedItem.iconName = 'utility:check';
            this._selectedItem.highlight = true;
          } // Make a shallow copy to trigger an update on the combobox


          this._items = this._items.slice();
        }
      }

      updateSelectedLabelFromValue(newValue) {
        this._selectedLabel = this.getOptionLabelByValue(newValue);
      }

      getOptionLabelByValue(value) {
        const foundOption = this.options.find(option => option.value === value);

        if (foundOption) {
          return foundOption.label;
        }

        return '';
      }

      generateItems(options) {
        return options.map(option => {
          return {
            type: 'option-inline',
            text: option.label,
            highlight: this.value === option.value,
            value: option.value
          };
        });
      }

      getBaseComboboxElement() {
        return this.template.querySelector('lightning-base-combobox');
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.selectedValue)
          });
        }

        return this._constraintApi;
      }

    }

    LightningCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningCombobox, {
      publicProps: {
        label: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        name: {
          config: 0
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        spinnerActive: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _ariaLabelledBy: 1,
        _ariaDescribedBy: 1,
        _fieldLevelHelp: 1,
        _selectedLabel: 1,
        _disabled: 1,
        _readOnly: 1,
        _spinnerActive: 1,
        _required: 1,
        _items: 1,
        _variant: 1,
        _helpMessage: 1
      }
    });

    var _lightningCombobox = lwc.registerComponent(LightningCombobox, {
      tmpl: _tmpl$p
    });

    function tmpl$r($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [$cmp.isDesktop ? $cmp.multiple ? api_custom_element("lightning-dual-listbox", _lightningDualListbox, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "size": $cmp.size,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "showActivityIndicator": $cmp.showActivityIndicator,
          "disableReordering": $cmp.disableReordering,
          "sourceLabel": $cmp.i18n.available,
          "selectedLabel": $cmp.i18n.chosen
        },
        key: 4,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.isDesktop ? !$cmp.multiple ? api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "spinnerActive": $cmp.showActivityIndicator,
          "dropdownAlignment": "auto"
        },
        key: 6,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange)),
          "open": _m6 || ($ctx._m6 = api_bind($cmp.handleOpen))
        }
      }, []) : null : null, !$cmp.isDesktop ? api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "label": $cmp.label,
          "multiple": $cmp.multiple,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "size": $cmp.size,
          "disabled": $cmp.disabled,
          "required": $cmp.required
        },
        key: 8,
        on: {
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []) : null];
    }

    var _tmpl$q = lwc.registerTemplate(tmpl$r);
    tmpl$r.stylesheets = [];

    if (_implicitStylesheets$9) {
      tmpl$r.stylesheets.push.apply(tmpl$r.stylesheets, _implicitStylesheets$9);
    }
    tmpl$r.stylesheetTokens = {
      hostAttribute: "lightning-picklist_picklist-host",
      shadowAttribute: "lightning-picklist_picklist"
    };

    var labelNoneLabel = '--None--';

    var labelAvailable = 'Available';

    var labelChosen = 'Chosen';

    const i18n$d = {
      noneLabel: labelNoneLabel,
      available: labelAvailable,
      chosen: labelChosen
    };

    class LightningPicklist extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._internalValue = void 0;
        this._picklistValue = void 0;
        this._options = void 0;
        this._required = false;
        this._disabled = false;
        this._size = 4;
        this._showActivityIndicator = false;
        this._fieldLevelHelp = void 0;
        this.label = void 0;
        this.name = void 0;
        this.placeholder = void 0;
        this.variant = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set value(newValue) {
        this._picklistValue = newValue;

        if (this.connected) {
          this._internalValue = this.getInternalValue(newValue);
        }
      }

      get value() {
        return this._picklistValue;
      } // only works for multi-select picklists


      set size(value) {
        this._size = this.normalizeSize(value);
      }

      get size() {
        return this._size;
      }

      set options(newOptions) {
        this._options = newOptions;

        if (this.connected) {
          this.updatePicklistOptions(newOptions);
        }
      }

      get options() {
        return this._options;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set required(value) {
        this._required = normalizeBoolean(value); // reset the flag that hides the required indicator when we have no options

        this._requiredButDisabled = false;
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value); // There are two ways a picklist could end up in a disabled state:
        // 1- explicitly setting disabled and 2- when the picklist has no options
        // If the element is explicitly set to be disabled, it should always remain disabled even when new options are provided

        this._externalDisabled = value;
      }

      get disabled() {
        return this._disabled;
      }

      set showActivityIndicator(value) {
        this._showActivityIndicator = normalizeBoolean(value);
      }

      get showActivityIndicator() {
        return this._showActivityIndicator || false;
      }

      connectedCallback() {
        this.updatePicklistOptions(this._options, true);
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        this.getElement.focus();
      }

      blur() {
        this.getElement.blur();
      }

      get validity() {
        return this.getElement.validity;
      }

      checkValidity() {
        return this.validity.valid;
      }

      setCustomValidity(message) {
        this.getElement.setCustomValidity(message);
      }

      reportValidity() {
        return this.getElement.reportValidity();
      }

      showHelpMessageIfInvalid() {
        this.getElement.showHelpMessageIfInvalid();
      }

      get i18n() {
        return i18n$d;
      }

      get internalValue() {
        return this._internalValue;
      }

      get getElement() {
        return this.template.querySelector('lightning-combobox,lightning-dual-listbox,lightning-primitive-select');
      } // disable reordering functionality on dual-listbox


      get disableReordering() {
        return true;
      }

      get isDesktop() {
        return configProvider$1.getFormFactor() === 'DESKTOP';
      }

      updatePicklistOptions(options, addMissingValues) {
        const newOptions = options ? [...options] : [];
        const existingInternalValue = this.internalValue !== undefined ? this.internalValue : this.getInternalValue(this._picklistValue);

        if (addMissingValues) {
          this.addMissingValuesToOptions(newOptions, existingInternalValue);
        }

        this.maybeAddNoneOption(newOptions);
        this._options = newOptions;
        this.updateDisabledState(options);
        this.updateRequiredState(options);
        const value = this.getValueToSelect(this.options, existingInternalValue);
        this._internalValue = value;

        if (!this.isSameValue(value, existingInternalValue)) {
          this._picklistValue = this.getPicklistValue(value);
          this.dispatchChangeEvent();
        }
      }

      isSameValue(value1, value2) {
        if (Array.isArray(value1) && Array.isArray(value2)) {
          return value1.sort().join(',') === value2.sort().join(',');
        }

        return value1 === value2;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._picklistValue = this.getPicklistValue(event.detail.value);
        this._internalValue = this.getInternalValue(event.detail.value);
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleOpen() {
        // fire internal event for some force components to leverage
        // e.g. to display the spinner while loading more picklist values
        this.dispatchEvent(new CustomEvent('open'));
      }

      maybeAddNoneOption(options) {
        if (this.shouldAddNoneOption(options.length)) {
          this.addOption(options, this.i18n.noneLabel, '');
        }
      }

      addOption(options, label, value) {
        options.unshift({
          label,
          value
        });
      }

      shouldDisablePicklist(options) {
        if (!options || options.length === 0) {
          return true;
        }

        return false;
      }

      shouldAddNoneOption(numberOfOptions) {
        if (this.multiple) {
          return false;
        }

        if (this.required && numberOfOptions === 1) {
          return false;
        }

        return true;
      }

      updateDisabledState(options) {
        this._disabled = this._externalDisabled !== undefined ? normalizeBoolean(this._externalDisabled) : this.shouldDisablePicklist(options);
      }

      updateRequiredState(options) {
        const shouldDisable = this.shouldDisablePicklist(options);

        if (shouldDisable) {
          if (this._required) {
            // when disabling the picklist, we should remove the required indicator
            this._required = false;
            this._requiredButDisabled = true;
          }

          if (this.connected && this.validity.valueMissing) {
            // if we're disabling the picklist, we should make sure any existing valueMissing message is cleared
            requestAnimationFrame(() => {
              this.showHelpMessageIfInvalid();
            });
          }
        } else if (this._requiredButDisabled) {
          // we now have some options and are not going to have a disabled picklist, so we'll put the required flag back to what it was before
          this._requiredButDisabled = false;
          this._required = true;
        }
      }

      getValueToSelect(options, existingValue) {
        if (!options || options.length === 0) {
          return this.multiple ? [] : '';
        }

        if (this.isValueInOptions(existingValue, options)) {
          return existingValue;
        }

        if (this.multiple) {
          return [];
        }

        if (this.shouldAddNoneOption([...options].length)) {
          return '';
        }

        return options[0].value;
      }

      isValueInOptions(value, options) {
        if (!options || options.length === 0) {
          return false;
        }

        const valueIsInOptions = valueToCheck => options.some(option => {
          return option.value === valueToCheck;
        });

        let valueExists = false;

        if (Array.isArray(value)) {
          valueExists = value.every(valueToCheck => {
            return valueIsInOptions(valueToCheck);
          });
        } else {
          valueExists = valueIsInOptions(value);
        }

        return valueExists;
      } // If values are missing from the options, we will add them to the options.
      // However, since we don't have the label, the same value will be used as label
      // See W-4829389


      addMissingValuesToOptions(newOptions, value) {
        if (!value || Array.isArray(value) && value.length === 0) {
          return;
        }

        const valueIsInOptions = valueToCheck => {
          return newOptions.some(option => {
            return option.value === valueToCheck;
          });
        };

        const maybeAddOption = valueToCheck => {
          if (!valueIsInOptions(valueToCheck)) {
            // Since we don't have the label, we will use the value instead
            this.addOption(newOptions, valueToCheck, valueToCheck);
          }
        };

        if (Array.isArray(value)) {
          value.forEach(valueToCheck => {
            maybeAddOption(valueToCheck);
          });
        } else {
          maybeAddOption(value);
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._picklistValue
          }
        }));
      }

      getPicklistValue(value) {
        // multi select picklists should have a ';' separated value string
        if (this.multiple && Array.isArray(value)) {
          return value.join(';');
        }

        return value;
      } // This is the value that is passed into the subcomponents dual-listbox and combobox.
      // In the case of dual-listbox, the component accepts an array of selected values.


      getInternalValue(value) {
        if (this.multiple) {
          if (Array.isArray(value)) {
            return value;
          }

          return typeof value === 'string' && value !== '' && value.split(';') || [];
        }

        return value;
      }

      normalizeSize(value) {
        const parsedValue = parseInt(value, 10);

        if (isNaN(parsedValue) || parsedValue < 3 || parsedValue > 10) {
          // A picklist field can only have a size between 3 and 10 when created declaratively
          // however, there seems to be cases where the size can be outside of this range.
          // In such cases, we will use the default value instead of throwing an error
          return 4;
        }

        return parsedValue;
      }

    }

    LightningPicklist.delegatesFocus = true;

    lwc.registerDecorators(LightningPicklist, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        variant: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        value: {
          config: 3
        },
        size: {
          config: 3
        },
        options: {
          config: 3
        },
        multiple: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showActivityIndicator: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "setCustomValidity", "reportValidity", "showHelpMessageIfInvalid"],
      track: {
        _internalValue: 1,
        _picklistValue: 1,
        _options: 1,
        _required: 1,
        _disabled: 1,
        _size: 1,
        _showActivityIndicator: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningPicklist = lwc.registerComponent(LightningPicklist, {
      tmpl: _tmpl$q
    });

    function tmpl$s($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 2
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 7
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 9
      }, api_iterator($cmp.fieldsMetaData, function (field, index) {
        return api_element("div", {
          classMap: {
            "slds-form-element__row": true
          },
          key: api_key(11, field.name)
        }, [field.isInput ? api_custom_element("lightning-input", _lightningInput, {
          attrs: {
            "data-field": field.name
          },
          props: {
            "name": field.name,
            "label": field.label,
            "value": field.value,
            "maxLength": field.maxlength,
            "placeholder": field.placeholder,
            "required": field.required,
            "disabled": $cmp.disabled,
            "readOnly": $cmp.readOnly
          },
          key: 13,
          on: {
            "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
            "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
            "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
          }
        }, []) : null, field.isCombobox ? api_custom_element("lightning-picklist", _lightningPicklist, {
          attrs: {
            "data-field": field.name
          },
          props: {
            "name": field.name,
            "label": field.label,
            "value": field.value,
            "options": field.options,
            "disabled": $cmp.disabled,
            "placeholder": field.placeholder
          },
          key: 15,
          on: {
            "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
            "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
            "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange))
          }
        }, []) : null]);
      }))])])];
    }

    var _tmpl$r = lwc.registerTemplate(tmpl$s);
    tmpl$s.stylesheets = [];

    if (_implicitStylesheets$3) {
      tmpl$s.stylesheets.push.apply(tmpl$s.stylesheets, _implicitStylesheets$3);
    }
    tmpl$s.stylesheetTokens = {
      hostAttribute: "lightning-inputName_inputName-host",
      shadowAttribute: "lightning-inputName_inputName"
    };

    var labelFirstName = 'First Name';

    var labelInformalName = 'Informal Name';

    var labelLastName = 'Last Name';

    var labelMiddleName = 'Middle Name';

    var labelNone = 'None';

    var labelSalutation = 'Salutation';

    var labelSuffix = 'Suffix';

    const FORMAT_CODE_MAP = {
      L: 'lastName',
      M: 'middleName',
      F: 'firstName',
      S: 'salutation',
      X: 'suffix',
      I: 'informalName'
    };
    const parseFieldsFormat = function (format) {
      if (isValidLocaleFormat(format)) {
        return format.toUpperCase().split(/(?=[A-Z])/).map(formatCode => FORMAT_CODE_MAP[formatCode]);
      }

      return [];
    };
    const getFieldsOrder = function () {
      const locale = getLocaleTag().replace(/-/g, '_');
      const inputOrder = parseFieldsFormat(name.getNameInputOrder(locale));
      return inputOrder;
    };

    function isValidLocaleFormat(value) {
      return typeof value === 'string' && /^[LMFSXI]+$/i.test(value);
    }

    const FIELD_TYPE = {
      INPUT: 'input',
      PICKLIST: 'combobox'
    };
    const DEFAULT_MAXLENGTH = 40;
    const DEFAULT_FIELD_META = {
      salutation: {
        inputType: FIELD_TYPE.PICKLIST
      },
      firstName: {},
      middleName: {},
      informalName: {},
      lastName: {
        maxlength: 80,
        required: true
      },
      suffix: {}
    };
    const i18n$e = {
      firstName: labelFirstName,
      informalName: labelInformalName,
      lastName: labelLastName,
      middleName: labelMiddleName,
      none: labelNone,
      required: labelRequired,
      salutation: labelSalutation,
      suffix: labelSuffix
    };
    /**
     * Represents a name compound field.
     */

    class LightningInputName extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.options = void 0;
        this.fieldsToDisplay = ['firstName', 'salutation', 'lastName'];
        this._salutation = '';
        this._lastName = '';
        this._firstName = '';
        this._middleName = '';
        this._informalName = '';
        this._suffix = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._variant = void 0;
        this._fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element', 'slds-form-compound');
        this.updateClassList();
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.showHelpMessageIfInvalid();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Displays the Salutation field as a dropdown menu. An array of label-value pairs must be provided using the options attribute.
       * @type {string}
       *
       */


      get salutation() {
        return this._salutation;
      }

      set salutation(value) {
        this._salutation = value;
      }
      /**
       * Displays the First Name field.
       * @type {string}
       *
       */


      get firstName() {
        return this._firstName;
      }

      set firstName(value) {
        this._firstName = value;
      }
      /**
       * Displays the Middle Name field.
       * @type {string}
       *
       */


      get middleName() {
        return this._middleName;
      }

      set middleName(value) {
        this._middleName = value;
      }
      /**
       * Displays the Informal Name field.
       * @type {string}
       *
       */


      get informalName() {
        return this._informalName;
      }

      set informalName(value) {
        this._informalName = value;
      }
      /**
       * Displays the Last Name field.
       * @type {string}
       *
       */


      get lastName() {
        return this._lastName;
      }

      set lastName(value) {
        this._lastName = value;
      }
      /**
       * Displays the Suffix field.
       * @type {string}
       *
       */


      get suffix() {
        return this._suffix;
      }

      set suffix(value) {
        this._suffix = value;
      }
      /**
       * If present, the input name field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the input name field is read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the input name field must be filled out before the form is submitted.
       * A red asterisk is displayed on the Last Name field. An error
       * message is displayed if a user interacts with the Last Name
       * field and does not provide a value.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of a name compound field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and name fields.
       * Use label-stacked to place the label above the name fields.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the first input field.
       */


      focus() {
        this.template.querySelector('[data-field]').focus();
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        const inputs = this.template.querySelectorAll('[data-field]');

        for (let i = 0; i < inputs.length; i++) {
          inputs[i].blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the latitude or longitude field if the coordinates are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the input name fields when
       * the input value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - The name of the input name field.
       */


      setCustomValidityForField(message, fieldName) {
        assert(DEFAULT_FIELD_META[fieldName] !== undefined, `Invalid 'fieldName': ${fieldName}`);

        this._fieldConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        this.fieldsToDisplay.forEach(field => {
          this._reportValidityForField(field);
        });
        return valid;
      }

      get i18n() {
        return i18n$e;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleBlur(event) {
        this.interactingState.leave();
        const field = event.target.dataset.field;

        this._reportValidityForField(field);
      }

      handleChange(event) {
        event.stopPropagation();
        const value = event.detail.value;
        const fieldName = event.target.dataset.field;

        if (this.getFieldValue(fieldName) === value) {
          // Value didn't change. No need to dispatch.
          return;
        } // update the value for changing field


        this[fieldName] = value;
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            salutation: this.salutation,
            firstName: this.firstName,
            middleName: this.middleName,
            lastName: this.lastName,
            informalName: this.informalName,
            suffix: this.suffix,
            validity: this.validity
          }
        }));
      }

      initializeFieldsMetaData(fieldsOrder) {
        const fields = []; // setup what fields are needed with the field name

        fieldsOrder.forEach(fieldName => {
          fields.push({
            name: fieldName
          });
        });
        return fields;
      }

      getFieldObject(field) {
        const fieldDefault = DEFAULT_FIELD_META[field];
        const value = this[field];
        const label = this.i18n[field];
        const fieldsToDisplay = this.fieldsToDisplay.map(fieldName => {
          return fieldName.toUpperCase();
        });

        if (fieldsToDisplay.indexOf(field.toUpperCase()) > -1) {
          return {
            isInput: fieldDefault.inputType !== 'combobox',
            isCombobox: fieldDefault.inputType === 'combobox',
            required: fieldDefault.required && this.required,
            options: this.options,
            placeholder: fieldDefault.inputType === 'combobox' ? this.i18n.none : label,
            maxlength: fieldDefault.maxlength || DEFAULT_MAXLENGTH,
            name: field,
            label,
            value
          };
        }

        return null;
      }

      get fieldsMetaData() {
        const fieldsOrder = getFieldsOrder();
        const fieldsData = this.initializeFieldsMetaData(fieldsOrder);
        const fields = [];
        fieldsData.forEach(row => {
          const fieldName = row.name;
          const fieldObject = this.getFieldObject(fieldName);

          if (fieldObject) {
            fields.push(fieldObject);
          }
        });
        return fields;
      }

      getFieldValue(fieldName) {
        return this[fieldName];
      }

      getFieldElement(fieldName) {
        return this.template.querySelector(`[data-field="${fieldName}"]`);
      }

      get _fieldConstraints() {
        if (!this._fieldConstraintApis) {
          // For every field to display create an appropriate constraint
          this._fieldConstraintApis = Object.keys(DEFAULT_FIELD_META).reduce((constraints, field) => {
            constraints[field] = new FieldConstraintApi(() => this.getFieldElement(field), {
              valueMissing: () => !this.disabled && this.required && this.fieldsToDisplay.indexOf(field) >= 0 && DEFAULT_FIELD_META[field].required && isEmptyString(this[field])
            });
            return constraints;
          }, {});
        }

        return this._fieldConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.customError),
            valueMissing: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.valueMissing)
          });
        }

        return this._combinedConstraintApi;
      }

      _reportValidityForField(field) {
        if (this._fieldConstraints[field]) {
          this._fieldConstraints[field].reportValidity(helpMessage => {
            const fieldElement = this.getFieldElement(field);
            fieldElement.setCustomValidity(helpMessage);
            fieldElement.reportValidity();
          });
        }
      }

    }

    LightningInputName.delegatesFocus = true;

    lwc.registerDecorators(LightningInputName, {
      publicProps: {
        label: {
          config: 0
        },
        options: {
          config: 0
        },
        fieldsToDisplay: {
          config: 0
        },
        salutation: {
          config: 3
        },
        firstName: {
          config: 3
        },
        middleName: {
          config: 3
        },
        informalName: {
          config: 3
        },
        lastName: {
          config: 3
        },
        suffix: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity"],
      track: {
        _salutation: 1,
        _lastName: 1,
        _firstName: 1,
        _middleName: 1,
        _informalName: 1,
        _suffix: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _variant: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningInputName = lwc.registerComponent(LightningInputName, {
      tmpl: _tmpl$r
    });

    function stylesheet$c(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$c = [stylesheet$c];

    function tmpl$t($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("iframe", {
        style: $cmp.frameStyle,
        attrs: {
          "src": $cmp.src,
          "title": $cmp.title,
          "width": $cmp.width,
          "height": $cmp.height
        },
        key: 2,
        on: {
          "load": _m0 || ($ctx._m0 = api_bind($cmp.handleContentLoad))
        }
      }, [])];
    }

    var _tmpl$s = lwc.registerTemplate(tmpl$t);
    tmpl$t.stylesheets = [];
    tmpl$t.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIframe_primitiveIframe-host",
      shadowAttribute: "lightning-primitiveIframe_primitiveIframe"
    };

    // Closure to hold the APIs if and when available
    let DispatcherCount = 1;
    const Domains = [];

    function generateDispatchId() {
      return `lightningIframeMessage-${DispatcherCount++}`;
    }
    function registerDomain(domain) {
      if (!domain || domain === '') {
        return;
      }

      const found = Domains.find(item => item.domain === domain);

      if (found) {
        found.ref += 1;
      } else {
        Domains.push({
          domain,
          ref: 1
        });
      }
    }
    function unregisterDomain(domain) {
      if (!domain || domain === '') {
        return;
      }

      const index = Domains.findIndex(item => item.domain === domain);

      if (index >= 0) {
        const found = Domains[index];
        found.ref -= 1;

        if (found.ref === 0) {
          Domains.splice(index, 1);
        }
      }
    }
    function registerMessageHandler(handler) {
      const dispatchId = generateDispatchId();
      return dispatchId;
    }
    function createMessage(dispatcherId, event, params) {
      params.cmpId = dispatcherId;
      return {
        event,
        arguments: params
      };
    }
    function postMessage(handler, message, domain, useObject) {
      if (handler) {
        handler(useObject ? message : JSON.stringify(message || {}), domain);
      }
    }

    /**
     * Class representing primitive iframe.
     * @extends Element
     */

    class LightningPrimitiveIframe extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.src = void 0;
        this.domain = void 0;
        this.width = '100%';
        this.height = '100%';
        this.frameStyle = '';
        this.title = void 0;
      }

      connectedCallback() {
        registerDomain(this.src);
      }

      disconnectedCallback() {
        unregisterDomain(this.src);
      }

      handleContentLoad() {
        const iframeload = new CustomEvent('iframeload', {
          detail: {
            callbacks: {
              postToWindow: this.postToWindow.bind(this)
            }
          }
        });
        this.contentWindow = this.template.querySelector('iframe').contentWindow;
        this.dispatchEvent(iframeload);
      }

      postToWindow(message) {
        if (this.contentWindow) {
          this.contentWindow.postMessage(message, this.domain);
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveIframe, {
      publicProps: {
        src: {
          config: 0
        },
        domain: {
          config: 0
        },
        width: {
          config: 0
        },
        height: {
          config: 0
        },
        frameStyle: {
          config: 0
        },
        title: {
          config: 0
        }
      },
      publicMethods: ["postToWindow"]
    });

    var _lightningPrimitiveIframe = lwc.registerComponent(LightningPrimitiveIframe, {
      tmpl: _tmpl$s
    });

    function tmpl$u($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [$cmp._isLoaded ? api_element("label", {
        className: $cmp.computedLabelClass,
        key: 3
      }, [api_dynamic($cmp.label)]) : null, $cmp._isLoaded ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 4
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        className: $cmp.computedLookupComboboxClass,
        props: {
          "variant": "lookup",
          "items": $cmp._items,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto",
          "placeholder": $cmp.placeholder,
          "inputText": $cmp.inputText,
          "inputIconName": $cmp._inputIconName,
          "showInputActivityIndicator": $cmp.showActivityIndicator,
          "attributionLogoUrl": $cmp._googleLogoUrl,
          "attributionLogoAssistiveText": $cmp._googleLogoText
        },
        key: 5,
        on: {
          "textinput": _m0 || ($ctx._m0 = api_bind($cmp.handleTextInput)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleSelect)),
          "ready": _m2 || ($ctx._m2 = api_bind($cmp.handleComboboxReady))
        }
      }, [])]) : null, api_custom_element("lightning-primitive-iframe", _lightningPrimitiveIframe, {
        styleMap: {
          "display": "none"
        },
        props: {
          "src": $cmp.apiSrc,
          "domain": $cmp.apiDomain
        },
        key: 6,
        on: {
          "iframeload": _m3 || ($ctx._m3 = api_bind($cmp.handleIframeLoad))
        }
      }, [])];
    }

    var _tmpl$t = lwc.registerTemplate(tmpl$u);
    tmpl$u.stylesheets = [];
    tmpl$u.stylesheetTokens = {
      hostAttribute: "lightning-lookupAddress_lookupAddress-host",
      shadowAttribute: "lightning-lookupAddress_lookupAddress"
    };

    function toHighlightParts(text, matchedSubstrings) {
      text = text || '';
      matchedSubstrings = matchedSubstrings || [];
      const parts = [];
      let last = 0;
      let index = 0;

      while (last < text.length && index < matchedSubstrings.length) {
        const part = matchedSubstrings[index++];

        if (part.offset > last) {
          parts.push({
            text: text.substring(last, part.offset),
            highlight: false
          });
        }

        last = part.offset + part.length;
        parts.push({
          text: text.substring(part.offset, last),
          highlight: true
        });
      }

      if (last < text.length) {
        parts.push({
          text: text.substring(last),
          highlight: false
        });
      }

      return parts;
    }

    const INTERNAL_GOOGLE_LOGO = `/projRes/ui-force-components/img/powered_by_google.png`;
    const POWERED_BY_GOOGLE = 'powered by Google';

    const DEFAULT_LOCATION = {
      lat: 37.790091,
      lng: -122.396848
    };
    const getCurrentPosition = navigator && navigator.geolocation && navigator.geolocation.getCurrentPosition ? navigator.geolocation.getCurrentPosition.bind(navigator.geolocation) : (success, error) => error && error();
    function getLocation() {
      return new Promise(resolve => {
        getCurrentPosition(position => {
          resolve({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        }, () => resolve(DEFAULT_LOCATION));
      });
    }

    const DEFAULT_TYPES = ['geocode'];
    const DEBOUNCE_PERIOD = 250;
    const DOMAIN_PREFIX = guid();
    const EVENT_NAME = {
      INITIALIZE_PLACE_API: 'initialize',
      QUERY_PLACE_AUTOCOMPLETE: 'queryAddress',
      QUERY_PLACE_DETAIL: 'selectAddress',
      PLACE_AUTOCOMPLETE: 'force:showAddressSuggestions',
      PLACE_DETAIL: 'force:saveAddressLookup'
    };

    class LightningLookupAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.inputText = '';
        this.placeholder = void 0;
        this._inputIconName = 'utility:search';
        this._items = void 0;
        this._showActivityIndicator = void 0;
        this._variant = void 0;
        this._disabled = void 0;
        this._isLoaded = false;
        this._googleLogoUrl = void 0;
        this._googleLogoText = POWERED_BY_GOOGLE;
        this._labelForId = void 0;
        this.placeIconName = 'utility:checkin';
        this.secureDomain = `https://${DOMAIN_PREFIX}${configProvider$1.getCoreInfo().untrustedContentDomain}:${configProvider$1.getCoreInfo().securePort}`;
        this.apiDomain = `*`;
        this.apiSrc = `${this.secureDomain}/lightningmaps/mapsloader?resource=placeApi&locale=${configProvider$1.getLocale().userLocaleLang}`;
      }

      connectedCallback() {
        this._items = [];
        this._dispatchId = registerMessageHandler(event => {
          this.handleMessage(event);
        });
        this._debouncedTextInput = debounce(text => {
          this._requestSuggestions(text);
        }, DEBOUNCE_PERIOD);
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      renderedCallback() {
        const label = this.template.querySelector('label');

        if (label) {
          synchronizeAttrs(label, {
            for: this._labelForId
          });
          label.setAttribute('for', this._labelForId);
        }
      }

      handleComboboxReady(e) {
        this._labelForId = e.detail.id;
      }

      handleMessage(data) {
        this._showActivityIndicator = false;

        if (!this._googleLogoUrl) {
          this._googleLogoUrl = INTERNAL_GOOGLE_LOGO;
        }

        if (data.event === EVENT_NAME.PLACE_AUTOCOMPLETE) {
          this._processAutoComplete(data.arguments.addresses);
        } else if (data.event === EVENT_NAME.PLACE_DETAIL) {
          this.dispatchChangeEvent(data.arguments);
        }
      }

      _requestSuggestions(matchString) {
        if (matchString) {
          this._showActivityIndicator = true;
          this.sendMessage(EVENT_NAME.QUERY_PLACE_AUTOCOMPLETE, {
            matchString
          });
        } else {
          this._items = [];
        }
      }

      handleTextInput(evt) {
        this.inputText = evt.detail.text;

        this._debouncedTextInput(evt.detail.text);
      }

      handleIframeLoad(event) {
        this._handler = event.detail.callbacks.postToWindow;
        this._isLoaded = true;
        getLocation().then(location => {
          this.sendMessage(EVENT_NAME.INITIALIZE_PLACE_API, {
            types: DEFAULT_TYPES,
            location
          });
        });
      }

      sendMessage(event, params) {
        if (this._handler) {
          const message = createMessage(this._dispatchId, event, params || {});
          postMessage(this._handler, message, '*');
        }
      }

      handleSelect(evt) {
        if (evt.detail.value) {
          this._showActivityIndicator = true;
          this.sendMessage(EVENT_NAME.QUERY_PLACE_DETAIL, {
            addressCmpId: this._dispatchId,
            placeId: evt.detail.value
          });
        }
      }

      _processAutoComplete(suggestions) {
        this._showActivityIndicator = false;
        this._items = [];

        if (suggestions) {
          this._items = suggestions.map(suggestion => {
            const mainText = suggestion.structured_formatting.main_text;
            const secondaryText = suggestion.structured_formatting.secondary_text;
            const matchedSubstrings = suggestion.structured_formatting.main_text_matched_substrings;
            const parts = toHighlightParts(mainText, matchedSubstrings);
            return {
              type: 'option-card',
              text: parts,
              iconName: this.placeIconName,
              subText: secondaryText,
              value: suggestion.place_id
            };
          });
        }
      }

      dispatchChangeEvent(address) {
        this.dispatchEvent(new CustomEvent('change', {
          detail: {
            address
          }
        }));
      }

    }

    lwc.registerDecorators(LightningLookupAddress, {
      publicProps: {
        label: {
          config: 0
        },
        inputText: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      track: {
        _inputIconName: 1,
        _items: 1,
        _showActivityIndicator: 1,
        _variant: 1,
        _disabled: 1,
        _isLoaded: 1
      }
    });

    var _lightningLookupAddress = lwc.registerComponent(LightningLookupAddress, {
      tmpl: _tmpl$t
    });

    function stylesheet$d(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$d = [stylesheet$d];

    function tmpl$v($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-grow": true
        },
        key: 6
      }, [api_element("textarea", {
        classMap: {
          "slds-textarea": true
        },
        attrs: {
          "id": api_scoped_id("input"),
          "aria-describedby": api_scoped_id($cmp.computedUniqueHelpElementId),
          "name": $cmp.name,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "placeholder": $cmp.placeholder,
          "accesskey": $cmp.accessKey
        },
        props: {
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "required": $cmp.required
        },
        key: 7,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleFocus)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur))
        }
      }, [api_dynamic($cmp._defaultValue)])]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 9
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$u = lwc.registerTemplate(tmpl$v);
    tmpl$v.stylesheets = [];

    if (_implicitStylesheets$d) {
      tmpl$v.stylesheets.push.apply(tmpl$v.stylesheets, _implicitStylesheets$d);
    }
    tmpl$v.stylesheetTokens = {
      hostAttribute: "lightning-textarea_textarea-host",
      shadowAttribute: "lightning-textarea_textarea"
    };

    const i18n$f = {
      required: labelRequired
    };
    /**
     * Represents a multiline text input field.
     */

    class LightningTextarea extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.placeholder = void 0;
        this.name = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._defaultValue = '';
        this._disabled = false;
        this._required = false;
        this._readOnly = false;
        this._variant = void 0;
        this._helpMessage = void 0;
        this._fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this._connected = true;
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      synchronizeA11y() {
        const input = this.template.querySelector('textarea');
        synchronizeAttrs(input, {
          'aria-describedby': this.computedUniqueHelpElementId
        });
      }

      renderedCallback() {
        // IE11: This is needed to work-around IE11 issue where it would append default value to the place holder,
        // instead of actually setting the value on the textarea element.
        if (!this._rendered) {
          this._rendered = true;
          this.inputElement.value = this._defaultValue;
          this.synchronizeA11y();
        }

        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The maximum number of characters allowed in the textarea.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * The minimum number of characters allowed in the textarea.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      }
      /**
       * The value of the textarea input, also used as the default value during init.
       * @type {string}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        // W-5026729 - On IE11, set same value again, will trigger another input event.
        if (this._value !== value) {
          this._value = value || '';

          if (this._connected) {
            // We're connected, so no longer need to update the default value, change the actual value instead
            this.inputElement.value = this._value;
          } else {
            this._defaultValue = this._value;
          }
        }

        this._updateProxyInputAttributes('value');
      }
      /**
       * If present, the textarea field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the textarea field is read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the textarea field must be filled out before the form can be submitted.
       * @type {boolean}
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * The variant changes the appearance of the textarea.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and textarea.
       * Use label-stacked to place the label above the textarea.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * Represents the validity states of the textarea input, with respect to constraint validation.
       * @type {object}
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the textarea meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the textarea.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the textarea value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * The help text that appears in a popover.
       * Set field-level help to provide an informational tooltip on the textarea input field.
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the textarea field.
       */


      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes focus from the textarea field.
       */


      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get i18n() {
        return i18n$f;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleChange(event) {
        // we only fire change event oninput
        // so stop native event here
        event.stopPropagation();
      }

      handleInput(event) {
        event.stopPropagation(); // If the current value is the same as it was prior to last update, don't fire the event.
        // This allows us to fix an issue with IE11 which fires an 'input' event every time the placeholder
        // is changed, since the value isn't affected we're effectively ignoring such events.

        if (!this._connected || this._value === event.target.value) {
          return;
        }

        this.interactingState.interacting();
        this._value = this.inputElement.value;

        this._updateProxyInputAttributes('value');

        this.dispatchEvent(new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this._value
          }
        }));
      }

      get inputElement() {
        return this.template.querySelector('textarea');
      }

      get computedUniqueHelpElementId() {
        const helpMessage = this.template.querySelector('[data-help-message]');
        return getRealDOMId(helpMessage);
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApiWithProxyInput(() => this, {
            // Override validity.valueMissing, which was broken in Edge until May 2018.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/291588/
            valueMissing: () => this._required && isEmptyString(this._value),
            tooShort: () => this._connected && this.inputElement.validity.tooShort,
            tooLong: () => this._connected && this.inputElement.validity.tooLong
          }, 'textarea');
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            value: () => this.value,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            required: () => this.required
          });
        }

        return this._constraintApi;
      }

    }

    LightningTextarea.delegatesFocus = true;

    lwc.registerDecorators(LightningTextarea, {
      publicProps: {
        label: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        maxLength: {
          config: 3
        },
        minLength: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        },
        fieldLevelHelp: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid", "focus", "blur"],
      track: {
        _maxLength: 1,
        _minLength: 1,
        _defaultValue: 1,
        _disabled: 1,
        _required: 1,
        _readOnly: 1,
        _variant: 1,
        _helpMessage: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningTextarea = lwc.registerComponent(LightningTextarea, {
      tmpl: _tmpl$u
    });
    LightningTextarea.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$w($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 2
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.addressLabel)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 6
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 8
      }, api_flatten([$cmp.showAddressLookup ? api_element("div", {
        classMap: {
          "slds-form-element__row": true,
          "slds-grow": true
        },
        key: 10
      }, [api_custom_element("lightning-lookup-address", _lightningLookupAddress, {
        classMap: {
          "slds-form-element": true,
          "slds-show": true,
          "slds-size_6-of-6": true
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 11,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleAddress))
        }
      }, [])]) : null, api_iterator($cmp.domFieldsMeta, function (row, index) {
        return api_element("div", {
          classMap: {
            "slds-form-element__row": true
          },
          key: api_key(13, row.name)
        }, api_iterator(row, function (field) {
          return [field.isInput ? api_custom_element("lightning-input", _lightningInput, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "label": field.label,
              "name": field.name,
              "value": field.value,
              "maxLength": field.maxlength,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled,
              "readOnly": $cmp.readOnly
            },
            key: api_key(16, field.name),
            on: {
              "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
              "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
              "change": _m3 || ($ctx._m3 = api_bind($cmp.handleChange))
            }
          }, []) : null, field.isTextArea ? api_custom_element("lightning-textarea", _lightningTextarea, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "name": field.name,
              "label": field.label,
              "value": field.value,
              "maxLength": field.maxlength,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled,
              "readOnly": $cmp.readOnly
            },
            key: api_key(18, field.name),
            on: {
              "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
              "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
              "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange))
            }
          }, []) : null, field.isPicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "name": field.name,
              "label": field.label,
              "options": field.options,
              "value": field.value,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled
            },
            key: api_key(20, field.name),
            on: {
              "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
              "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
              "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
            }
          }, []) : null];
        }));
      })]))])])];
    }

    var _tmpl$v = lwc.registerTemplate(tmpl$w);
    tmpl$w.stylesheets = [];

    if (_implicitStylesheets$c) {
      tmpl$w.stylesheets.push.apply(tmpl$w.stylesheets, _implicitStylesheets$c);
    }
    tmpl$w.stylesheetTokens = {
      hostAttribute: "lightning-inputAddress_inputAddress-host",
      shadowAttribute: "lightning-inputAddress_inputAddress"
    };

    const FORMAT_CODE_MAP$1 = {
      A: 'street',
      C: 'city',
      S: 'province',
      Z: 'postalCode',
      K: 'country'
    };
    const parseLocaleFormat = function (format) {
      if (isValidFieldFormat(format)) {
        return format.toUpperCase().split(/(?=[A-Z])/).map(formatCode => FORMAT_CODE_MAP$1[formatCode]);
      }

      return [];
    };
    function getInputOrder(langCode, countryCode, hasCountryPicklist) {
      let inputOrder = address.getAddressInputOrderAllField(langCode, countryCode); // always show country picklist as the first field
      // to match aloha behavior

      if (hasCountryPicklist) {
        inputOrder = 'K' + inputOrder.replace('K', '');
      }

      return parseLocaleFormat(inputOrder);
    }
    function getRequiredFields(langCode, countryCode) {
      const requireFields = address.getAddressRequireFields(langCode, countryCode);
      return parseLocaleFormat(requireFields);
    }

    function isValidFieldFormat(value) {
      return typeof value === 'string' && /^[ACSZK]+$/i.test(value);
    }

    // diviisble by 2 and 3, easy for arranging rows with
    // [1/2 field + 1/2 field] and [1/3 field + 2/3 field]
    const MAX_ROW_WIDTH = 6;
    const FIELD_WIDTHS = {
      street: {
        width: 6
      },
      city: {
        width: 4
      },
      province: {
        width: 2
      },
      postalCode: {
        width: 4
      },
      country: {
        width: 2
      }
    };
    function getFieldWidth(fieldName) {
      return FIELD_WIDTHS[fieldName];
    }
    function getFieldWidthClass(field) {
      return `slds-size_${field.width}-of-${MAX_ROW_WIDTH}`;
    }
    function distributeFieldWidth(row) {
      if (row.length === 1) {
        row[0].width = MAX_ROW_WIDTH;
      } else if (row.length > 1) {
        const totalRowWidth = row.reduce((sum, field) => {
          return sum + field.width;
        }, 0);

        if (totalRowWidth < MAX_ROW_WIDTH) {
          row.forEach(field => {
            field.width = MAX_ROW_WIDTH / row.length;
          });
        }
      }
    }
    function getTransformedFieldsMetaForLayout(fieldsMeta, inputOrder) {
      const layoutMetadata = []; // distribute fields to different rows

      let row = [];
      let rowWidth = 0;
      inputOrder.forEach(name => {
        const field = fieldsMeta[name];
        rowWidth += field.width;

        if (rowWidth > MAX_ROW_WIDTH) {
          layoutMetadata.push(row);
          row = [];
          rowWidth = field.width;
        }

        row.push(field);
      });
      layoutMetadata.push(row); // distribute width evenly

      layoutMetadata.forEach(rowFields => {
        distributeFieldWidth(rowFields);
      });
      return layoutMetadata;
    }

    const FIELD_TYPE$1 = {
      TEXTAREA: 'textarea',
      INPUT: 'input',
      PICKLIST: 'combobox'
    };
    const i18n$g = {
      required: labelRequired
    };
    /**
     * Represents an address compound field.
     */

    class LightningInputAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.addressLabel = void 0;
        this.streetLabel = void 0;
        this.cityLabel = void 0;
        this.provinceLabel = void 0;
        this.countryLabel = void 0;
        this.postalCodeLabel = void 0;
        this.provinceOptions = void 0;
        this.countryOptions = void 0;
        this._showAddressLookup = void 0;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._street = '';
        this._city = '';
        this._province = '';
        this._country = '';
        this._postalCode = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element', 'slds-form_compound');
        this.updateClassList();
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The street field of the address.
       * @type {string}
       *
       */


      get street() {
        return this._street;
      }

      set street(value) {
        this._street = value;
      }
      /**
       * The city field of the address.
       * @type {string}
       *
       */


      get city() {
        return this._city;
      }

      set city(value) {
        this._city = value;
      }
      /**
       * The province field of the address. If province-options is provided, this province value is selected by default.
       * @type {string}
       *
       */


      get province() {
        return this._province;
      }

      set province(value) {
        this._province = value;
      }
      /**
       * The country field of the address. If country-options is provided, this country value is selected by default.
       * @type {string}
       *
       */


      get country() {
        return this._country;
      }

      set country(value) {
        this._country = value;
      }
      /**
       * The postal code field of the address.
       * @type {string}
       *
       */


      get postalCode() {
        return this._postalCode;
      }

      set postalCode(value) {
        this._postalCode = value;
      }
      /**
       * If present, the address fields are disabled and users cannot interact with them.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, address lookup using Google Maps is enabled.
       * @type {boolean}
       * @default false
       */


      get showAddressLookup() {
        return this._showAddressLookup;
      }

      set showAddressLookup(value) {
        this._showAddressLookup = normalizeBoolean(value);
      }
      /**
       * If present, the address fields are read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the address fields must be filled before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of an input address field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input address field.
       * Use label-stacked to place the label above the input address field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the address fields if the values are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the specified fieldName when
       * the input address value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - Name of the field, which must be one of the following: street, city, province, postalCode, country.
       */


      setCustomValidityForField(message, fieldName) {
        assert(this.fieldsMeta[fieldName] !== undefined, `Invalid 'fieldName': ${fieldName}`);

        this._fieldConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        this.inputOrder.forEach(field => {
          this._reportValidityForField(field);
        });
        return valid;
      }
      /**
       * Sets focus on the first input element.
       */


      focus() {
        this.template.querySelector('[data-field]').focus();
      }
      /**
       * Removes focus from all input fields.
       */


      blur() {
        Array.prototype.forEach.call(this.template.querySelectorAll('[data-field]'), field => field.blur());
      }

      get searchAddressButtonDisabled() {
        return this.disabled || this.readOnly;
      }

      get i18n() {
        return i18n$g;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get fieldsTypeMeta() {
        return {
          street: {
            name: 'street',
            maxlength: 255,
            type: FIELD_TYPE$1.TEXTAREA
          },
          city: {
            name: 'city',
            maxlength: 40,
            type: FIELD_TYPE$1.INPUT
          },
          province: {
            name: 'province',
            maxlength: 80,
            type: Array.isArray(this.provinceOptions) ? FIELD_TYPE$1.PICKLIST : FIELD_TYPE$1.INPUT
          },
          postalCode: {
            name: 'postalCode',
            maxlength: 20,
            type: FIELD_TYPE$1.INPUT
          },
          country: {
            name: 'country',
            maxlength: 80,
            type: Array.isArray(this.countryOptions) ? FIELD_TYPE$1.PICKLIST : FIELD_TYPE$1.INPUT
          }
        };
      }

      get inputOrder() {
        const hasCountryPicklist = this.fieldsTypeMeta.country.type === FIELD_TYPE$1.PICKLIST;
        const [langCode, countryCode] = getLocaleTag().split('-');
        return getInputOrder(langCode, countryCode, hasCountryPicklist);
      }

      get requiredFields() {
        const [langCode, countryCode] = getLocaleTag().split('-');
        return getRequiredFields(langCode, countryCode);
      }

      get fieldsMeta() {
        const fieldsMeta = {};
        this.inputOrder.forEach(name$$1 => {
          fieldsMeta[name$$1] = Object.assign({}, this.fieldsTypeMeta[name$$1], getFieldWidth(name$$1));
        });
        this.requiredFields.forEach(name$$1 => {
          fieldsMeta[name$$1].required = true;
        });
        return fieldsMeta;
      }

      get domFieldsMeta() {
        let rowKey = 0;
        const out = getTransformedFieldsMetaForLayout(this.fieldsMeta, this.inputOrder).map(row => {
          const rowList = row.map(field => {
            const {
              name: name$$1,
              type,
              required,
              maxlength
            } = field;
            const label = this.getFieldLabel(name$$1);
            const widthClass = getFieldWidthClass(field);
            return {
              isInput: type === FIELD_TYPE$1.INPUT,
              isPicklist: type === FIELD_TYPE$1.PICKLIST,
              isTextArea: type === FIELD_TYPE$1.TEXTAREA,
              value: this.getFieldValue(name$$1),
              options: this.getFieldOptions(name$$1),
              required: this.required && !!required,
              classnames: `slds-form-element slds-show ${widthClass}`,
              placeholder: label,
              label,
              maxlength,
              name: name$$1
            };
          });
          rowList.name = rowKey++;
          return rowList;
        });
        return out;
      }

      handleAddress(evt) {
        const address$$1 = evt.detail.address || {};
        this.street = address$$1.street || '';
        this.city = address$$1.city || '';
        this.province = address$$1.state || '';
        this.country = address$$1.country || '';
        this.postalCode = address$$1.postalCode || '';
        this.dispatchAddressChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleBlur(event) {
        this.interactingState.leave();
        const field = event.target.dataset.field;

        this._reportValidityForField(field);
      }

      handleChange(event) {
        event.stopPropagation();
        const fieldName = event.target.dataset.field;
        const value = event.detail.value;

        if (this.getFieldValue(fieldName) === value) {
          // Value didn't change. No need to dispatch.
          return;
        }

        this[fieldName] = value;
        this.dispatchAddressChangeEvent();
      }

      dispatchAddressChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            street: this.street,
            city: this.city,
            province: this.province,
            country: this.country,
            postalCode: this.postalCode,
            validity: this.validity
          }
        }));
      }

      getFieldValue(fieldName) {
        return this[fieldName];
      }

      getFieldOptions(fieldName) {
        return this[`${fieldName}Options`];
      }

      getFieldLabel(fieldName) {
        return this[`${fieldName}Label`];
      }

      getFieldElement(fieldName) {
        return this.template.querySelector(`[data-field="${fieldName}"]`);
      }

      get _fieldConstraints() {
        if (!this._fieldConstraintApis) {
          // For every field to display create an appropriate constraint
          this._fieldConstraintApis = ['street', 'city', 'province', 'country', 'postalCode'].reduce((constraints, field) => {
            constraints[field] = new FieldConstraintApi(() => this.getFieldElement(field), {
              valueMissing: () => !this.disabled && this.required && this.requiredFields.indexOf(field) >= 0 && isEmptyString(this[field])
            });
            return constraints;
          }, {});
        }

        return this._fieldConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.customError),
            valueMissing: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.valueMissing)
          });
        }

        return this._combinedConstraintApi;
      }

      _reportValidityForField(field) {
        if (this._fieldConstraints[field]) {
          this._fieldConstraints[field].reportValidity(helpMessage => {
            const fieldElement = this.getFieldElement(field);
            fieldElement.setCustomValidity(helpMessage);
            fieldElement.reportValidity();
          });
        }
      }

    }

    LightningInputAddress.delegatesFocus = true;

    lwc.registerDecorators(LightningInputAddress, {
      publicProps: {
        addressLabel: {
          config: 0
        },
        streetLabel: {
          config: 0
        },
        cityLabel: {
          config: 0
        },
        provinceLabel: {
          config: 0
        },
        countryLabel: {
          config: 0
        },
        postalCodeLabel: {
          config: 0
        },
        provinceOptions: {
          config: 0
        },
        countryOptions: {
          config: 0
        },
        street: {
          config: 3
        },
        city: {
          config: 3
        },
        province: {
          config: 3
        },
        country: {
          config: 3
        },
        postalCode: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showAddressLookup: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity", "focus", "blur"],
      track: {
        _showAddressLookup: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _street: 1,
        _city: 1,
        _province: 1,
        _country: 1,
        _postalCode: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1
      }
    });

    var _lightningInputAddress = lwc.registerComponent(LightningInputAddress, {
      tmpl: _tmpl$v
    });

    function stylesheet$e(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$e = [stylesheet$e];

    function stylesheet$f(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$f = [stylesheet$f];

    function tmpl$x($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("span", {
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [])];
    }

    var _tmpl$w = lwc.registerTemplate(tmpl$x);
    tmpl$x.stylesheets = [];
    tmpl$x.stylesheetTokens = {
      hostAttribute: "lightning-formattedRichText_formattedRichText-host",
      shadowAttribute: "lightning-formattedRichText_formattedRichText"
    };

    const linkRegex = new RegExp(`${tagRegexString}|${urlRegexString}|${emailRegexString}`, 'gi');

    const createHttpLink = function (match) {
      const href = createHttpHref(match);
      return `<a href="${href}" target="_blank" rel="noopener">${match}</a>`;
    };

    const createEmailLink = function (match) {
      const href = createEmailHref(match);
      return `<a href="${href}">${match}</a>`;
    };

    const linkify = function (text) {
      if (typeof text !== 'string') {
        return '';
      }

      return text.replace(linkRegex, (match, tagMatch, hrefMatch, emailMatch) => {
        if (tagMatch) {
          return tagMatch;
        } else if (hrefMatch) {
          const endsWithQuote = hrefMatch.endsWith('&quot');
          let href = hrefMatch;

          if (endsWithQuote) {
            href = hrefMatch.slice(0, hrefMatch.lastIndexOf('&quot'));
          }

          return createHttpLink(href) + (endsWithQuote ? '&quot' : '');
        } else if (emailMatch) {
          return createEmailLink(emailMatch);
        }

        return match;
      });
    };

    const tagsWhitelist = Object.freeze(['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'mark', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font']);
    const attrWhitelist = Object.freeze(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'data-fileid']);
    const richTextConfig = Object.freeze({
      ALLOWED_TAGS: tagsWhitelist,
      ALLOWED_ATTR: attrWhitelist,
      ALLOW_UNKNOWN_PROTOCOLS: false
    });

    const GET_LINK_INFO_EVENT = 'lightningroutingservicegetlinkinfo';
    const urlTypes = {
      standard: 'standard_webPage'
    };
    /*
     * Mock getLinkInfo
     *
     * @returns {Promise[LinkInfo]}
     */

    function getLinkInfo(element, stateRef) {
      return new Promise((resolve, reject) => {
        // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        const getLinkInfoEvent = new CustomEvent(GET_LINK_INFO_EVENT, {
          detail: {
            stateRef,
            callback: (err, linkInfo) => {
              if (err) {
                reject(err);
              } else {
                resolve(linkInfo);
              }
            }
          },
          bubbles: true,
          composed: true,
          cancelable: true
        });
        element.dispatchEvent(getLinkInfoEvent);
      });
    }
    /**
     * Determines the route for the given url and updates the element
     * state with the correct url and dispatcher.
     *
     * @param {HTMLElement} element Element from which to dispatch the routing event
     * @param {Object} url Link to route, target Target of the link
     * @param {function} callback on the returned LinkInfo
     *
     * @returns {Promise} Promise[LinkInfo]
     */

    function updateRawLinkInfo(element, {
      url,
      target
    }) {
      if (url === undefined || url === null) {
        // eslint-disable-next-line no-console
        console.error('url must be specified');
      }

      if (target === '_blank') {
        // Have a no-op dispatcher if target is blank
        return new Promise(resolve => {
          resolve({
            url,
            dispatcher: () => {}
          });
        });
      }

      return getLinkInfo(element, {
        stateType: urlTypes.standard,
        attributes: {
          url,
          target
        }
      });
    }

    function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(Object(source)); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } return target; }

    function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    /**
     * Displays rich text that's formatted with whitelisted tags and attributes.
     * Other tags and attributes are removed and only their text content is displayed.
     */

    class LightningFormattedRichText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.initialRender = true;
        this._value = '';
        this._disableLinkify = false;
        this.connected = false;
        this.clean = false;
      }

      /**
       * If present, the component does not create links in the rich text.
       * @type {boolean}
       * @default false
       */
      get disableLinkify() {
        return this._disableLinkify;
      }

      set disableLinkify(val) {
        this._disableLinkify = normalizeBoolean(val);
        this.renderRichText();
      }
      /**
       * Sets the rich text to display.
       * @type {string}
       *
       */


      get value() {
        return this._value;
      }

      set value(val) {
        this._value = val;
        this.renderRichText();
      }

      renderedCallback() {
        if (this.initialRender) {
          this.renderRichText();
          this.initialRender = false;
        }
      }

      connectedCallback() {
        this.classList.add('slds-rich-text-editor__output');
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      handleClick(event) {
        const eventTarget = event.target; // Don't do anything if it's not an anchor

        if (eventTarget.tagName !== 'A') {
          return;
        }

        const href = eventTarget.href; // Grab the link info onclick and dispatch

        updateRawLinkInfo(this, {
          url: href,
          target: eventTarget.target
        }).then(linkInfo => {
          eventTarget.href = linkInfo.url;
          linkInfo.dispatcher(event);
        });
      }

      sanitize(value) {
        this.clean = false;
        let displayValue;
        let computedRichTextConfig = richTextConfig;

        if (hasOnlyAllowedVideoIframes(value)) {
          // richTextConfig is shared across all formatted-rich-text components;
          // so create and modify copy of richTextConfig to whitelist iframes for each component
          computedRichTextConfig = _objectSpread$3({}, richTextConfig, {
            ALLOWED_TAGS: richTextConfig.ALLOWED_TAGS.concat(['iframe'])
          });
        }

        try {
          displayValue = configProvider$1.sanitizeDOM(value, computedRichTextConfig);
          this.clean = true;
        } catch (e) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-formatted-rich-text> Exception caught when attempting to sanitize: `, e);
          displayValue = value;
          this.clean = false;
        }

        return displayValue;
      }

      renderRichText() {
        if (this.connected) {
          const richText = this.sanitize(this.disableLinkify ? this.value : linkify(this.value));
          const container = this.getContainer();

          if (this.clean) {
            // eslint-disable-next-line lwc/no-inner-html
            container.innerHTML = richText;
          } else {
            const textNode = document.createTextNode(richText);

            while (container.hasChildNodes()) {
              container.removeChild(container.lastChild);
            }

            container.appendChild(textNode);
          }
        }
      }

      getContainer() {
        return this.template.querySelector('span');
      }

    }

    lwc.registerDecorators(LightningFormattedRichText, {
      publicProps: {
        disableLinkify: {
          config: 3
        },
        value: {
          config: 3
        }
      }
    });

    var _lightningFormattedRichText = lwc.registerComponent(LightningFormattedRichText, {
      tmpl: _tmpl$w
    });

    function tmpl$y($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "accesskey": $cmp.computedAccessKey,
          "title": $cmp.computedTitle,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-describedby": api_scoped_id($cmp.computedAriaDescribedBy),
          "aria-label": $cmp.computedAriaLabel,
          "aria-controls": api_scoped_id($cmp.computedAriaControls),
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonBlur))
        }
      }, [$cmp.showIconLeft ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 4
      }, []) : null, api_dynamic($cmp.label), $cmp.showIconRight ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 6
      }, []) : null])];
    }

    var _tmpl$x = lwc.registerTemplate(tmpl$y);
    tmpl$y.stylesheets = [];
    tmpl$y.stylesheetTokens = {
      hostAttribute: "lightning-button_button-host",
      shadowAttribute: "lightning-button_button"
    };

    /**
     * A clickable element used to perform an action.
     */

    class LightningButton extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.label = void 0;
        this.variant = 'neutral';
        this.iconName = void 0;
        this.iconPosition = 'left';
        this.type = 'button';
        this.title = null;
        this._order = null;
      }

      render() {
        return _tmpl$x;
      }

      get computedButtonClass() {
        return classSet('slds-button').add({
          'slds-button_neutral': this.normalizedVariant === 'neutral',
          'slds-button_brand': this.normalizedVariant === 'brand',
          'slds-button_outline-brand': this.normalizedVariant === 'brand-outline',
          'slds-button_destructive': this.normalizedVariant === 'destructive',
          'slds-button_text-destructive': this.normalizedVariant === 'destructive-text',
          'slds-button_inverse': this.normalizedVariant === 'inverse',
          'slds-button_success': this.normalizedVariant === 'success',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedTitle() {
        return this.title;
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'neutral',
          validValues: ['base', 'neutral', 'brand', 'destructive', 'inverse', 'success']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: 'button',
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedIconPosition() {
        return normalizeString(this.iconPosition, {
          fallbackValue: 'left',
          validValues: ['left', 'right']
        });
      }

      get showIconLeft() {
        return this.iconName && this.normalizedIconPosition === 'left';
      }

      get showIconRight() {
        return this.iconName && this.normalizedIconPosition === 'right';
      }

      get computedIconClass() {
        return classSet('slds-button__icon').add({
          'slds-button__icon_left': this.normalizedIconPosition === 'left',
          'slds-button__icon_right': this.normalizedIconPosition === 'right'
        }).toString();
      }

      handleButtonFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleButtonBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        this.template.querySelector('button').focus();
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      disconnectedCallback() {
        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButton.delegatesFocus = true;

    lwc.registerDecorators(LightningButton, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        type: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        title: 1,
        _order: 1
      }
    });

    var _lightningButton = lwc.registerComponent(LightningButton, {
      tmpl: _tmpl$x
    });
    LightningButton.interopMap = {
      exposeNativeEvent: {
        click: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$z($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11
      } = $ctx;
      return [$cmp.renderLabel ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("label"),
          "data-label": true
        },
        key: 3
      }, [api_dynamic($cmp.computedLabel)]) : null, api_element("div", {
        classMap: {
          "slds-rich-text-editor": true,
          "slds-grid": true,
          "slds-grid_vertical": true,
          "slds-nowrap": true
        },
        key: 4,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.activateEditor))
        }
      }, [$cmp.isBottomToolbar ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true,
          "editor": true
        },
        key: 6
      }, []) : null, $cmp.isBottomToolbar ? $cmp.quillNotReady ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-rich-text-area__content": true,
          "slds-grow": true,
          "slds-text-color-weak": true,
          "standin": true
        },
        key: 8
      }, [api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        props: {
          "value": $cmp.value,
          "disableLinkify": true
        },
        key: 9
      }, [])])]) : null : null, $cmp.isBottomToolbar ? !$cmp.valid ? api_element("div", {
        classMap: {
          "slds-form-element__help": true,
          "slds-p-around_small": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true
        },
        key: 11
      }, [api_dynamic($cmp.errorMessage)]) : null : null, api_element("div", {
        classMap: {
          "slds-rich-text-editor__toolbar": true,
          "slds-shrink-none": true
        },
        attrs: {
          "role": "toolbar",
          "aria-label": $cmp.toolbarAriaLabel
        },
        key: 12,
        on: {
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.navigateToolbar))
        }
      }, api_flatten([$cmp.isFontMenusVisible ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-wrap": true
        },
        attrs: {
          "role": "group",
          "aria-label": $cmp.i18n.formatFont
        },
        key: 14
      }, [$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true
        },
        key: 16
      }, [api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "value": $cmp.selectedFontValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.font,
          "options": $cmp.fontMenus.fontList,
          "disabled": $cmp.disabled,
          "dropdownAlignment": $cmp.menuDropdownAlignment
        },
        key: 17,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.activateEditor)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.selectFont))
        }
      }, [])]) : null, $cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_xx-small": true
        },
        key: 18
      }, [api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "value": $cmp.selectedSizeValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.fontSize,
          "options": $cmp.fontMenus.sizeList,
          "disabled": $cmp.disabled,
          "dropdownAlignment": $cmp.menuDropdownAlignment
        },
        key: 19,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.selectSize))
        }
      }, [])]) : null, !$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_x-small": true
        },
        key: 21
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.selectedFontValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.font,
          "options": $cmp.fontMenus.fontList,
          "disabled": $cmp.disabled
        },
        key: 22,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.selectFont))
        }
      }, [])]) : null, !$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_xx-small": true
        },
        key: 23
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.selectedSizeValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.fontSize,
          "options": $cmp.fontMenus.sizeList,
          "disabled": $cmp.disabled
        },
        key: 24,
        on: {
          "change": _m4 || ($ctx._m4 = api_bind($cmp.selectSize))
        }
      }, [])]) : null]) : null, $cmp.isColorpickerVisible ? api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "disabled": $cmp.disabled,
          "value": $cmp.selectedTextColorValue
        },
        key: 26,
        on: {
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleColorUpdate))
        }
      }, []) : null, api_iterator($cmp.computedCategories, function (category) {
        return api_element("ul", {
          classMap: {
            "slds-button-group-list": true
          },
          attrs: {
            "aria-label": category.label
          },
          key: api_key(28, category.label)
        }, api_iterator(category.buttons, function (button) {
          return api_element("li", {
            key: api_key(30, button.key)
          }, [api_element("button", {
            className: button.computedClass,
            attrs: {
              "value": button.value,
              "title": button.label,
              "data-format": button.format,
              "aria-pressed": "false"
            },
            key: 31
          }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
            props: {
              "iconName": button.iconName,
              "svgClass": "slds-button__icon",
              "variant": "bare"
            },
            key: 32
          }, []), api_element("span", {
            classMap: {
              "slds-assistive-text": true
            },
            key: 33
          }, [api_dynamic(button.label)])])]);
        }));
      })])), !$cmp.isBottomToolbar ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true,
          "editor": true
        },
        key: 35
      }, []) : null, !$cmp.isBottomToolbar ? $cmp.quillNotReady ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true
        },
        key: 36
      }, [api_element("div", {
        classMap: {
          "slds-rich-text-area__content": true,
          "slds-grow": true,
          "slds-text-color-weak": true,
          "standin": true
        },
        key: 37
      }, [api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        props: {
          "value": $cmp.value,
          "disableLinkify": true
        },
        key: 38
      }, [])])]) : null : null, !$cmp.isBottomToolbar ? !$cmp.valid ? api_element("div", {
        classMap: {
          "slds-form-element__help": true,
          "slds-p-around_small": true
        },
        attrs: {
          "id": api_scoped_id("error-message-bottom"),
          "data-error-message": true
        },
        key: 40
      }, [api_dynamic($cmp.errorMessage)]) : null : null]), $cmp.linkPanelOpen ? api_element("div", {
        classMap: {
          "slds-popover": true,
          "slds-popover__body": true
        },
        key: 42
      }, [api_custom_element("lightning-input", _lightningInput, {
        classMap: {
          "link-input": true
        },
        props: {
          "name": "link-input",
          "value": $cmp.showLinkValue,
          "label": $cmp.i18n.linkInput
        },
        key: 43,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleLinkValueChange)),
          "keydown": _m9 || ($ctx._m9 = api_bind($cmp.linkKeyboardPress))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-m-top_small": true
        },
        key: 44
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "variant": "brand",
          "label": $cmp.i18n.linkSave
        },
        key: 45,
        on: {
          "click": _m10 || ($ctx._m10 = api_bind($cmp.saveLink))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        styleMap: {
          "marginLeft": ".25rem"
        },
        props: {
          "variant": "bare",
          "label": $cmp.i18n.linkCancel
        },
        key: 46,
        on: {
          "click": _m11 || ($ctx._m11 = api_bind($cmp.cancelLink))
        }
      }, [])])]) : null];
    }

    var _tmpl$y = lwc.registerTemplate(tmpl$z);
    tmpl$z.stylesheets = [];

    if (_implicitStylesheets$f) {
      tmpl$z.stylesheets.push.apply(tmpl$z.stylesheets, _implicitStylesheets$f);
    }
    tmpl$z.stylesheetTokens = {
      hostAttribute: "lightning-inputRichText_inputRichText-host",
      shadowAttribute: "lightning-inputRichText_inputRichText"
    };

    var labelAlignText = 'Align text';

    var labelBold = 'Bold';

    var labelBullet = 'Bulleted list';

    var labelCenterAlign = 'Center align text';

    var labelComposeText = 'Compose text';

    var labelFont = 'Font';

    var labelFontSize = 'Font Size';

    var labelFormatBackground = 'Format background and text color';

    var labelFormatBody = 'Format body';

    var labelFormatFont = 'Format font family and size';

    var labelFormatText = 'Format text';

    var labelIndent = 'Indent';

    var labelInsertContent = 'Insert content';

    var labelItalic = 'Italic';

    var labelLeftAlign = 'Left align text';

    var labelLink = 'Link';

    var labelImage = 'Image';

    var labelLinkCancel = 'Cancel';

    var labelLinkInput = 'Link URL';

    var labelLinkSave = 'Save';

    var labelNumber = 'Numbered list';

    var labelOutdent = 'Outdent';

    var labelRemoveFormatting = 'Remove formatting';

    var labelRightAlign = 'Right align text';

    var labelStrike = 'Strikethrough';

    var labelUnderline = 'Underline';

    /*
     * Copyright (C) 2016 salesforce.com, inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */ /*
    Quill

    Copyright (c) 2014, Jason Chen
    Copyright (c) 2013, salesforce.com
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */var commonjsGlobal=typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function unwrapExports(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}var quill=createCommonjsModule(function(module,exports){(function webpackUniversalModuleDefinition(root,factory){module.exports=factory();})(typeof self!=='undefined'?self:commonjsGlobal,function(){return function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId]){return installedModules[moduleId].exports;}var module=installedModules[moduleId]={i:moduleId,l:false,exports:{}};modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.l=true;return module.exports;}__webpack_require__.m=modules;__webpack_require__.c=installedModules;__webpack_require__.d=function(exports,name,getter){if(!__webpack_require__.o(exports,name)){Object.defineProperty(exports,name,{configurable:false,enumerable:true,get:getter});}};__webpack_require__.n=function(module){var getter=module&&module.__esModule?function getDefault(){return module['default'];}:function getModuleExports(){return module;};__webpack_require__.d(getter,'a',getter);return getter;};__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};__webpack_require__.p="";return __webpack_require__(__webpack_require__.s=109);}([function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var container_1=__webpack_require__(17);var format_1=__webpack_require__(18);var leaf_1=__webpack_require__(19);var scroll_1=__webpack_require__(45);var inline_1=__webpack_require__(46);var block_1=__webpack_require__(47);var embed_1=__webpack_require__(48);var text_1=__webpack_require__(49);var attributor_1=__webpack_require__(12);var class_1=__webpack_require__(32);var style_1=__webpack_require__(33);var store_1=__webpack_require__(31);var Registry=__webpack_require__(1);var Parchment={Scope:Registry.Scope,create:Registry.create,find:Registry.find,query:Registry.query,register:Registry.register,Container:container_1.default,Format:format_1.default,Leaf:leaf_1.default,Embed:embed_1.default,Scroll:scroll_1.default,Block:block_1.default,Inline:inline_1.default,Text:text_1.default,Attributor:{Attribute:attributor_1.default,Class:class_1.default,Style:style_1.default,Store:store_1.default}};exports.default=Parchment;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ParchmentError=function(_super){__extends(ParchmentError,_super);function ParchmentError(message){var _this=this;message='[Parchment] '+message;_this=_super.call(this,message)||this;_this.message=message;_this.name=_this.constructor.name;return _this;}return ParchmentError;}(Error);exports.ParchmentError=ParchmentError;var attributes={};var classes={};var tags={};var types={};exports.DATA_KEY='__blot';var Scope;(function(Scope){Scope[Scope["TYPE"]=3]="TYPE";Scope[Scope["LEVEL"]=12]="LEVEL";Scope[Scope["ATTRIBUTE"]=13]="ATTRIBUTE";Scope[Scope["BLOT"]=14]="BLOT";Scope[Scope["INLINE"]=7]="INLINE";Scope[Scope["BLOCK"]=11]="BLOCK";Scope[Scope["BLOCK_BLOT"]=10]="BLOCK_BLOT";Scope[Scope["INLINE_BLOT"]=6]="INLINE_BLOT";Scope[Scope["BLOCK_ATTRIBUTE"]=9]="BLOCK_ATTRIBUTE";Scope[Scope["INLINE_ATTRIBUTE"]=5]="INLINE_ATTRIBUTE";Scope[Scope["ANY"]=15]="ANY";})(Scope=exports.Scope||(exports.Scope={}));function create(input,value){var match=query(input);if(match==null){throw new ParchmentError("Unable to create "+input+" blot");}var BlotClass=match;var node=input instanceof Node||input['nodeType']===Node.TEXT_NODE?input:BlotClass.create(value);return new BlotClass(node,value);}exports.create=create;function find(node,bubble){if(bubble===void 0){bubble=false;}if(node==null)return null;if(node[exports.DATA_KEY]!=null)return node[exports.DATA_KEY].blot;if(bubble)return find(node.parentNode,bubble);return null;}exports.find=find;function query(query,scope){if(scope===void 0){scope=Scope.ANY;}var match;if(typeof query==='string'){match=types[query]||attributes[query];}else if(query instanceof Text||query['nodeType']===Node.TEXT_NODE){match=types['text'];}else if(typeof query==='number'){if(query&Scope.LEVEL&Scope.BLOCK){match=types['block'];}else if(query&Scope.LEVEL&Scope.INLINE){match=types['inline'];}}else if(query instanceof HTMLElement){var names=(query.getAttribute('class')||'').split(/\s+/);for(var i in names){match=classes[names[i]];if(match)break;}match=match||tags[query.tagName];}if(match==null)return null;if(scope&Scope.LEVEL&match.scope&&scope&Scope.TYPE&match.scope)return match;return null;}exports.query=query;function register(){var Definitions=[];for(var _i=0;_i<arguments.length;_i++){Definitions[_i]=arguments[_i];}if(Definitions.length>1){return Definitions.map(function(d){return register(d);});}var Definition=Definitions[0];if(typeof Definition.blotName!=='string'&&typeof Definition.attrName!=='string'){throw new ParchmentError('Invalid definition');}else if(Definition.blotName==='abstract'){throw new ParchmentError('Cannot register abstract class');}types[Definition.blotName||Definition.attrName]=Definition;if(typeof Definition.keyName==='string'){attributes[Definition.keyName]=Definition;}else{if(Definition.className!=null){classes[Definition.className]=Definition;}if(Definition.tagName!=null){if(Array.isArray(Definition.tagName)){Definition.tagName=Definition.tagName.map(function(tagName){return tagName.toUpperCase();});}else{Definition.tagName=Definition.tagName.toUpperCase();}var tagNames=Array.isArray(Definition.tagName)?Definition.tagName:[Definition.tagName];tagNames.forEach(function(tag){if(tags[tag]==null||Definition.className==null){tags[tag]=Definition;}});}}return Definition;}exports.register=register;},function(module,exports,__webpack_require__){var diff=__webpack_require__(51);var equal=__webpack_require__(11);var extend=__webpack_require__(3);var op=__webpack_require__(20);var NULL_CHARACTER=String.fromCharCode(0);var Delta=function(ops){if(Array.isArray(ops)){this.ops=ops;}else if(ops!=null&&Array.isArray(ops.ops)){this.ops=ops.ops;}else{this.ops=[];}};Delta.prototype.insert=function(text,attributes){var newOp={};if(text.length===0)return this;newOp.insert=text;if(attributes!=null&&typeof attributes==='object'&&Object.keys(attributes).length>0){newOp.attributes=attributes;}return this.push(newOp);};Delta.prototype['delete']=function(length){if(length<=0)return this;return this.push({'delete':length});};Delta.prototype.retain=function(length,attributes){if(length<=0)return this;var newOp={retain:length};if(attributes!=null&&typeof attributes==='object'&&Object.keys(attributes).length>0){newOp.attributes=attributes;}return this.push(newOp);};Delta.prototype.push=function(newOp){var index=this.ops.length;var lastOp=this.ops[index-1];newOp=extend(true,{},newOp);if(typeof lastOp==='object'){if(typeof newOp['delete']==='number'&&typeof lastOp['delete']==='number'){this.ops[index-1]={'delete':lastOp['delete']+newOp['delete']};return this;}if(typeof lastOp['delete']==='number'&&newOp.insert!=null){index-=1;lastOp=this.ops[index-1];if(typeof lastOp!=='object'){this.ops.unshift(newOp);return this;}}if(equal(newOp.attributes,lastOp.attributes)){if(typeof newOp.insert==='string'&&typeof lastOp.insert==='string'){this.ops[index-1]={insert:lastOp.insert+newOp.insert};if(typeof newOp.attributes==='object')this.ops[index-1].attributes=newOp.attributes;return this;}else if(typeof newOp.retain==='number'&&typeof lastOp.retain==='number'){this.ops[index-1]={retain:lastOp.retain+newOp.retain};if(typeof newOp.attributes==='object')this.ops[index-1].attributes=newOp.attributes;return this;}}}if(index===this.ops.length){this.ops.push(newOp);}else{this.ops.splice(index,0,newOp);}return this;};Delta.prototype.chop=function(){var lastOp=this.ops[this.ops.length-1];if(lastOp&&lastOp.retain&&!lastOp.attributes){this.ops.pop();}return this;};Delta.prototype.filter=function(predicate){return this.ops.filter(predicate);};Delta.prototype.forEach=function(predicate){this.ops.forEach(predicate);};Delta.prototype.map=function(predicate){return this.ops.map(predicate);};Delta.prototype.partition=function(predicate){var passed=[],failed=[];this.forEach(function(op){var target=predicate(op)?passed:failed;target.push(op);});return [passed,failed];};Delta.prototype.reduce=function(predicate,initial){return this.ops.reduce(predicate,initial);};Delta.prototype.changeLength=function(){return this.reduce(function(length,elem){if(elem.insert){return length+op.length(elem);}else if(elem.delete){return length-elem.delete;}return length;},0);};Delta.prototype.length=function(){return this.reduce(function(length,elem){return length+op.length(elem);},0);};Delta.prototype.slice=function(start,end){start=start||0;if(typeof end!=='number')end=Infinity;var ops=[];var iter=op.iterator(this.ops);var index=0;while(index<end&&iter.hasNext()){var nextOp;if(index<start){nextOp=iter.next(start-index);}else{nextOp=iter.next(end-index);ops.push(nextOp);}index+=op.length(nextOp);}return new Delta(ops);};Delta.prototype.compose=function(other){var thisIter=op.iterator(this.ops);var otherIter=op.iterator(other.ops);var delta=new Delta();while(thisIter.hasNext()||otherIter.hasNext()){if(otherIter.peekType()==='insert'){delta.push(otherIter.next());}else if(thisIter.peekType()==='delete'){delta.push(thisIter.next());}else{var length=Math.min(thisIter.peekLength(),otherIter.peekLength());var thisOp=thisIter.next(length);var otherOp=otherIter.next(length);if(typeof otherOp.retain==='number'){var newOp={};if(typeof thisOp.retain==='number'){newOp.retain=length;}else{newOp.insert=thisOp.insert;}var attributes=op.attributes.compose(thisOp.attributes,otherOp.attributes,typeof thisOp.retain==='number');if(attributes)newOp.attributes=attributes;delta.push(newOp);}else if(typeof otherOp['delete']==='number'&&typeof thisOp.retain==='number'){delta.push(otherOp);}}}return delta.chop();};Delta.prototype.concat=function(other){var delta=new Delta(this.ops.slice());if(other.ops.length>0){delta.push(other.ops[0]);delta.ops=delta.ops.concat(other.ops.slice(1));}return delta;};Delta.prototype.diff=function(other,index){if(this.ops===other.ops){return new Delta();}var strings=[this,other].map(function(delta){return delta.map(function(op){if(op.insert!=null){return typeof op.insert==='string'?op.insert:NULL_CHARACTER;}var prep=delta===other?'on':'with';throw new Error('diff() called '+prep+' non-document');}).join('');});var delta=new Delta();var diffResult=diff(strings[0],strings[1],index);var thisIter=op.iterator(this.ops);var otherIter=op.iterator(other.ops);diffResult.forEach(function(component){var length=component[1].length;while(length>0){var opLength=0;switch(component[0]){case diff.INSERT:opLength=Math.min(otherIter.peekLength(),length);delta.push(otherIter.next(opLength));break;case diff.DELETE:opLength=Math.min(length,thisIter.peekLength());thisIter.next(opLength);delta['delete'](opLength);break;case diff.EQUAL:opLength=Math.min(thisIter.peekLength(),otherIter.peekLength(),length);var thisOp=thisIter.next(opLength);var otherOp=otherIter.next(opLength);if(equal(thisOp.insert,otherOp.insert)){delta.retain(opLength,op.attributes.diff(thisOp.attributes,otherOp.attributes));}else{delta.push(otherOp)['delete'](opLength);}break;}length-=opLength;}});return delta.chop();};Delta.prototype.eachLine=function(predicate,newline){newline=newline||'\n';var iter=op.iterator(this.ops);var line=new Delta();var i=0;while(iter.hasNext()){if(iter.peekType()!=='insert')return;var thisOp=iter.peek();var start=op.length(thisOp)-iter.peekLength();var index=typeof thisOp.insert==='string'?thisOp.insert.indexOf(newline,start)-start:-1;if(index<0){line.push(iter.next());}else if(index>0){line.push(iter.next(index));}else{if(predicate(line,iter.next(1).attributes||{},i)===false){return;}i+=1;line=new Delta();}}if(line.length()>0){predicate(line,{},i);}};Delta.prototype.transform=function(other,priority){priority=!!priority;if(typeof other==='number'){return this.transformPosition(other,priority);}var thisIter=op.iterator(this.ops);var otherIter=op.iterator(other.ops);var delta=new Delta();while(thisIter.hasNext()||otherIter.hasNext()){if(thisIter.peekType()==='insert'&&(priority||otherIter.peekType()!=='insert')){delta.retain(op.length(thisIter.next()));}else if(otherIter.peekType()==='insert'){delta.push(otherIter.next());}else{var length=Math.min(thisIter.peekLength(),otherIter.peekLength());var thisOp=thisIter.next(length);var otherOp=otherIter.next(length);if(thisOp['delete']){continue;}else if(otherOp['delete']){delta.push(otherOp);}else{delta.retain(length,op.attributes.transform(thisOp.attributes,otherOp.attributes,priority));}}}return delta.chop();};Delta.prototype.transformPosition=function(index,priority){priority=!!priority;var thisIter=op.iterator(this.ops);var offset=0;while(thisIter.hasNext()&&offset<=index){var length=thisIter.peekLength();var nextType=thisIter.peekType();thisIter.next();if(nextType==='delete'){index-=Math.min(length,index-offset);continue;}else if(nextType==='insert'&&(offset<index||!priority)){index+=length;}offset+=length;}return index;};module.exports=Delta;},function(module,exports){var hasOwn=Object.prototype.hasOwnProperty;var toStr=Object.prototype.toString;var isArray=function isArray(arr){if(typeof Array.isArray==='function'){return Array.isArray(arr);}return toStr.call(arr)==='[object Array]';};var isPlainObject=function isPlainObject(obj){if(!obj||toStr.call(obj)!=='[object Object]'){return false;}var hasOwnConstructor=hasOwn.call(obj,'constructor');var hasIsPrototypeOf=obj.constructor&&obj.constructor.prototype&&hasOwn.call(obj.constructor.prototype,'isPrototypeOf');if(obj.constructor&&!hasOwnConstructor&&!hasIsPrototypeOf){return false;}var key;for(key in obj){}return typeof key==='undefined'||hasOwn.call(obj,key);};module.exports=function extend(){var options,name,src,copy,copyIsArray,clone;var target=arguments[0];var i=1;var length=arguments.length;var deep=false;if(typeof target==='boolean'){deep=target;target=arguments[1]||{};i=2;}if(target==null||typeof target!=='object'&&typeof target!=='function'){target={};}for(;i<length;++i){options=arguments[i];if(options!=null){for(name in options){src=target[name];copy=options[name];if(target!==copy){if(deep&&copy&&(isPlainObject(copy)||(copyIsArray=isArray(copy)))){if(copyIsArray){copyIsArray=false;clone=src&&isArray(src)?src:[];}else{clone=src&&isPlainObject(src)?src:{};}target[name]=extend(deep,clone,copy);}else if(typeof copy!=='undefined'){target[name]=copy;}}}}}return target;};},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.BlockEmbed=exports.bubbleFormats=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var NEWLINE_LENGTH=1;var BlockEmbed=function(_Parchment$Embed){_inherits(BlockEmbed,_Parchment$Embed);function BlockEmbed(){_classCallCheck(this,BlockEmbed);return _possibleConstructorReturn(this,(BlockEmbed.__proto__||Object.getPrototypeOf(BlockEmbed)).apply(this,arguments));}_createClass(BlockEmbed,[{key:'attach',value:function attach(){_get(BlockEmbed.prototype.__proto__||Object.getPrototypeOf(BlockEmbed.prototype),'attach',this).call(this);this.attributes=new _parchment2.default.Attributor.Store(this.domNode);}},{key:'delta',value:function delta(){return new _quillDelta2.default().insert(this.value(),_extend2.default(this.formats(),this.attributes.values()));}},{key:'format',value:function format(name,value){var attribute=_parchment2.default.query(name,_parchment2.default.Scope.BLOCK_ATTRIBUTE);if(attribute!=null){this.attributes.attribute(attribute,value);}}},{key:'formatAt',value:function formatAt(index,length,name,value){this.format(name,value);}},{key:'insertAt',value:function insertAt(index,value,def){if(typeof value==='string'&&value.endsWith('\n')){var block=_parchment2.default.create(Block.blotName);this.parent.insertBefore(block,index===0?this:this.next);block.insertAt(0,value.slice(0,-1));}else{_get(BlockEmbed.prototype.__proto__||Object.getPrototypeOf(BlockEmbed.prototype),'insertAt',this).call(this,index,value,def);}}}]);return BlockEmbed;}(_parchment2.default.Embed);BlockEmbed.scope=_parchment2.default.Scope.BLOCK_BLOT;var Block=function(_Parchment$Block){_inherits(Block,_Parchment$Block);function Block(domNode){_classCallCheck(this,Block);var _this2=_possibleConstructorReturn(this,(Block.__proto__||Object.getPrototypeOf(Block)).call(this,domNode));_this2.cache={};return _this2;}_createClass(Block,[{key:'delta',value:function delta(){if(this.cache.delta==null){this.cache.delta=this.descendants(_parchment2.default.Leaf).reduce(function(delta,leaf){if(leaf.length()===0){return delta;}else{return delta.insert(leaf.value(),bubbleFormats(leaf));}},new _quillDelta2.default()).insert('\n',bubbleFormats(this));}return this.cache.delta;}},{key:'deleteAt',value:function deleteAt(index,length){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'deleteAt',this).call(this,index,length);this.cache={};}},{key:'formatAt',value:function formatAt(index,length,name,value){if(length<=0)return;if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)){if(index+length===this.length()){this.format(name,value);}}else{_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'formatAt',this).call(this,index,Math.min(length,this.length()-index-1),name,value);}this.cache={};}},{key:'insertAt',value:function insertAt(index,value,def){if(def!=null)return _get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'insertAt',this).call(this,index,value,def);if(value.length===0)return;var lines=value.split('\n');var text=lines.shift();if(text.length>0){if(index<this.length()-1||this.children.tail==null){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'insertAt',this).call(this,Math.min(index,this.length()-1),text);}else{this.children.tail.insertAt(this.children.tail.length(),text);}this.cache={};}var block=this;lines.reduce(function(index,line){block=block.split(index,true);block.insertAt(0,line);return line.length;},index+text.length);}},{key:'insertBefore',value:function insertBefore(blot,ref){var head=this.children.head;_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'insertBefore',this).call(this,blot,ref);if(head instanceof _break2.default){head.remove();}this.cache={};}},{key:'length',value:function length(){if(this.cache.length==null){this.cache.length=_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'length',this).call(this)+NEWLINE_LENGTH;}return this.cache.length;}},{key:'moveChildren',value:function moveChildren(target,ref){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'moveChildren',this).call(this,target,ref);this.cache={};}},{key:'optimize',value:function optimize(context){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'optimize',this).call(this,context);this.cache={};}},{key:'path',value:function path(index){return _get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'path',this).call(this,index,true);}},{key:'removeChild',value:function removeChild(child){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'removeChild',this).call(this,child);this.cache={};}},{key:'split',value:function split(index){var force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(force&&(index===0||index>=this.length()-NEWLINE_LENGTH)){var clone=this.clone();if(index===0){this.parent.insertBefore(clone,this);return this;}else{this.parent.insertBefore(clone,this.next);return clone;}}else{var next=_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'split',this).call(this,index,force);this.cache={};return next;}}}]);return Block;}(_parchment2.default.Block);Block.blotName='block';Block.tagName='P';Block.defaultChild='break';Block.allowedChildren=[_inline2.default,_parchment2.default.Embed,_text2.default];function bubbleFormats(blot){var formats=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(blot==null)return formats;if(typeof blot.formats==='function'){formats=_extend2.default(formats,blot.formats());}if(blot.parent==null||blot.parent.blotName=='scroll'||blot.parent.statics.scope!==blot.statics.scope){return formats;}return bubbleFormats(blot.parent,formats);}exports.bubbleFormats=bubbleFormats;exports.BlockEmbed=BlockEmbed;exports.default=Block;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.overload=exports.expandConfig=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();__webpack_require__(50);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _editor=__webpack_require__(14);var _editor2=_interopRequireDefault(_editor);var _emitter3=__webpack_require__(8);var _emitter4=_interopRequireDefault(_emitter3);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _selection=__webpack_require__(15);var _selection2=_interopRequireDefault(_selection);var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _theme=__webpack_require__(34);var _theme2=_interopRequireDefault(_theme);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var debug=_logger2.default('quill');var Quill=function(){_createClass(Quill,null,[{key:'debug',value:function debug(limit){if(limit===true){limit='log';}_logger2.default.level(limit);}},{key:'find',value:function find(node){return node.__quill||_parchment2.default.find(node);}},{key:'import',value:function _import(name){if(this.imports[name]==null){debug.error('Cannot import '+name+'. Are you sure it was registered?');}return this.imports[name];}},{key:'register',value:function register(path,target){var _this=this;var overwrite=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(typeof path!=='string'){var name=path.attrName||path.blotName;if(typeof name==='string'){this.register('formats/'+name,path,target);}else{Object.keys(path).forEach(function(key){_this.register(key,path[key],target);});}}else{if(this.imports[path]!=null&&!overwrite){debug.warn('Overwriting '+path+' with',target);}this.imports[path]=target;if((path.startsWith('blots/')||path.startsWith('formats/'))&&target.blotName!=='abstract'){_parchment2.default.register(target);}else if(path.startsWith('modules')&&typeof target.register==='function'){target.register();}}}}]);function Quill(container){var _this2=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Quill);this.options=expandConfig(container,options);this.container=this.options.container;if(this.container==null){return debug.error('Invalid Quill container',container);}if(this.options.debug){Quill.debug(this.options.debug);}var html=this.container.innerHTML.trim();this.container.classList.add('ql-container');this.container.innerHTML='';this.container.__quill=this;this.root=this.addContainer('ql-editor');this.root.classList.add('ql-blank');this.root.setAttribute('data-gramm',false);this.scrollingContainer=this.options.scrollingContainer||this.root;this.emitter=new _emitter4.default();this.scroll=_parchment2.default.create(this.root,{emitter:this.emitter,whitelist:this.options.formats});this.editor=new _editor2.default(this.scroll);this.selection=new _selection2.default(this.scroll,this.emitter);this.theme=new this.options.theme(this,this.options);this.keyboard=this.theme.addModule('keyboard');this.clipboard=this.theme.addModule('clipboard');this.history=this.theme.addModule('history');this.theme.init();this.emitter.on(_emitter4.default.events.EDITOR_CHANGE,function(type){if(type===_emitter4.default.events.TEXT_CHANGE){_this2.root.classList.toggle('ql-blank',_this2.editor.isBlank());}});this.emitter.on(_emitter4.default.events.SCROLL_UPDATE,function(source,mutations){var range=_this2.selection.lastRange;var index=range&&range.length===0?range.index:undefined;modify.call(_this2,function(){return _this2.editor.update(null,mutations,index);},source);});var contents=this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">'+html+'<p><br></p></div>');this.setContents(contents);this.history.clear();if(this.options.placeholder){this.root.setAttribute('data-placeholder',this.options.placeholder);}if(this.options.readOnly){this.disable();}}_createClass(Quill,[{key:'addContainer',value:function addContainer(container){var refNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(typeof container==='string'){var className=container;container=document.createElement('div');container.classList.add(className);}this.container.insertBefore(container,refNode);return container;}},{key:'blur',value:function blur(){this.selection.setRange(null);}},{key:'deleteText',value:function deleteText(index,length,source){var _this3=this;var _overload=overload(index,length,source);var _overload2=_slicedToArray(_overload,4);index=_overload2[0];length=_overload2[1];source=_overload2[3];return modify.call(this,function(){return _this3.editor.deleteText(index,length);},source,index,-1*length);}},{key:'disable',value:function disable(){this.enable(false);}},{key:'enable',value:function enable(){var enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.scroll.enable(enabled);this.container.classList.toggle('ql-disabled',!enabled);}},{key:'focus',value:function focus(){var scrollTop=this.scrollingContainer.scrollTop;this.selection.focus();this.scrollingContainer.scrollTop=scrollTop;this.scrollIntoView();}},{key:'format',value:function format(name,value){var _this4=this;var source=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_emitter4.default.sources.API;return modify.call(this,function(){var range=_this4.getSelection(true);var change=new _quillDelta2.default();if(range==null){return change;}else if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)){change=_this4.editor.formatLine(range.index,range.length,_defineProperty({},name,value));}else if(range.length===0){_this4.selection.format(name,value);return change;}else{change=_this4.editor.formatText(range.index,range.length,_defineProperty({},name,value));}_this4.setSelection(range,_emitter4.default.sources.SILENT);return change;},source);}},{key:'formatLine',value:function formatLine(index,length,name,value,source){var _this5=this;var formats=void 0;var _overload3=overload(index,length,name,value,source);var _overload4=_slicedToArray(_overload3,4);index=_overload4[0];length=_overload4[1];formats=_overload4[2];source=_overload4[3];return modify.call(this,function(){return _this5.editor.formatLine(index,length,formats);},source,index,0);}},{key:'formatText',value:function formatText(index,length,name,value,source){var _this6=this;var formats=void 0;var _overload5=overload(index,length,name,value,source);var _overload6=_slicedToArray(_overload5,4);index=_overload6[0];length=_overload6[1];formats=_overload6[2];source=_overload6[3];return modify.call(this,function(){return _this6.editor.formatText(index,length,formats);},source,index,0);}},{key:'getBounds',value:function getBounds(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var bounds=void 0;if(typeof index==='number'){bounds=this.selection.getBounds(index,length);}else{bounds=this.selection.getBounds(index.index,index.length);}var containerBounds=this.container.getBoundingClientRect();return {bottom:bounds.bottom-containerBounds.top,height:bounds.height,left:bounds.left-containerBounds.left,right:bounds.right-containerBounds.left,top:bounds.top-containerBounds.top,width:bounds.width};}},{key:'getContents',value:function getContents(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.getLength()-index;var _overload7=overload(index,length);var _overload8=_slicedToArray(_overload7,2);index=_overload8[0];length=_overload8[1];return this.editor.getContents(index,length);}},{key:'getFormat',value:function getFormat(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.getSelection(true);var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(typeof index==='number'){return this.editor.getFormat(index,length);}else{return this.editor.getFormat(index.index,index.length);}}},{key:'getIndex',value:function getIndex(blot){return blot.offset(this.scroll);}},{key:'getLength',value:function getLength(){return this.scroll.length();}},{key:'getLeaf',value:function getLeaf(index){return this.scroll.leaf(index);}},{key:'getLine',value:function getLine(index){return this.scroll.line(index);}},{key:'getLines',value:function getLines(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Number.MAX_VALUE;if(typeof index!=='number'){return this.scroll.lines(index.index,index.length);}else{return this.scroll.lines(index,length);}}},{key:'getModule',value:function getModule(name){return this.theme.modules[name];}},{key:'getSelection',value:function getSelection(){var focus=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(focus)this.focus();this.update();return this.selection.getRange()[0];}},{key:'getText',value:function getText(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.getLength()-index;var _overload9=overload(index,length);var _overload10=_slicedToArray(_overload9,2);index=_overload10[0];length=_overload10[1];return this.editor.getText(index,length);}},{key:'hasFocus',value:function hasFocus(){return this.selection.hasFocus();}},{key:'insertEmbed',value:function insertEmbed(index,embed,value){var _this7=this;var source=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Quill.sources.API;return modify.call(this,function(){return _this7.editor.insertEmbed(index,embed,value);},source,index);}},{key:'insertText',value:function insertText(index,text,name,value,source){var _this8=this;var formats=void 0;var _overload11=overload(index,0,name,value,source);var _overload12=_slicedToArray(_overload11,4);index=_overload12[0];formats=_overload12[2];source=_overload12[3];return modify.call(this,function(){return _this8.editor.insertText(index,text,formats);},source,index,text.length);}},{key:'isEnabled',value:function isEnabled(){return !this.container.classList.contains('ql-disabled');}},{key:'off',value:function off(){return this.emitter.off.apply(this.emitter,arguments);}},{key:'on',value:function on(){return this.emitter.on.apply(this.emitter,arguments);}},{key:'once',value:function once(){return this.emitter.once.apply(this.emitter,arguments);}},{key:'pasteHTML',value:function pasteHTML(index,html,source){this.clipboard.dangerouslyPasteHTML(index,html,source);}},{key:'removeFormat',value:function removeFormat(index,length,source){var _this9=this;var _overload13=overload(index,length,source);var _overload14=_slicedToArray(_overload13,4);index=_overload14[0];length=_overload14[1];source=_overload14[3];return modify.call(this,function(){return _this9.editor.removeFormat(index,length);},source,index);}},{key:'scrollIntoView',value:function scrollIntoView(){this.selection.scrollIntoView(this.scrollingContainer);}},{key:'setContents',value:function setContents(delta){var _this10=this;var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_emitter4.default.sources.API;return modify.call(this,function(){delta=new _quillDelta2.default(delta);var length=_this10.getLength();var deleted=_this10.editor.deleteText(0,length);var applied=_this10.editor.applyDelta(delta);var lastOp=applied.ops[applied.ops.length-1];if(lastOp!=null&&typeof lastOp.insert==='string'&&lastOp.insert[lastOp.insert.length-1]==='\n'){_this10.editor.deleteText(_this10.getLength()-1,1);applied.delete(1);}var ret=deleted.compose(applied);return ret;},source);}},{key:'setSelection',value:function setSelection(index,length,source){if(index==null){this.selection.setRange(null,length||Quill.sources.API);}else{var _overload15=overload(index,length,source);var _overload16=_slicedToArray(_overload15,4);index=_overload16[0];length=_overload16[1];source=_overload16[3];this.selection.setRange(new _selection.Range(index,length),source);if(source!==_emitter4.default.sources.SILENT){this.selection.scrollIntoView(this.scrollingContainer);}}}},{key:'setText',value:function setText(text){var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_emitter4.default.sources.API;var delta=new _quillDelta2.default().insert(text);return this.setContents(delta,source);}},{key:'update',value:function update(){var source=arguments.length>0&&arguments[0]!==undefined?arguments[0]:_emitter4.default.sources.USER;var change=this.scroll.update(source);this.selection.update(source);return change;}},{key:'updateContents',value:function updateContents(delta){var _this11=this;var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_emitter4.default.sources.API;return modify.call(this,function(){delta=new _quillDelta2.default(delta);return _this11.editor.applyDelta(delta,source);},source,true);}}]);return Quill;}();Quill.DEFAULTS={bounds:null,formats:null,modules:{},placeholder:'',readOnly:false,scrollingContainer:null,strict:true,theme:'default'};Quill.events=_emitter4.default.events;Quill.sources=_emitter4.default.sources;Quill.version="1.3.4";Quill.imports={'delta':_quillDelta2.default,'parchment':_parchment2.default,'core/module':_module2.default,'core/theme':_theme2.default};function expandConfig(container,userConfig){userConfig=_extend2.default(true,{container:container,modules:{clipboard:true,keyboard:true,history:true}},userConfig);if(!userConfig.theme||userConfig.theme===Quill.DEFAULTS.theme){userConfig.theme=_theme2.default;}else{userConfig.theme=Quill.import('themes/'+userConfig.theme);if(userConfig.theme==null){throw new Error('Invalid theme '+userConfig.theme+'. Did you register it?');}}var themeConfig=_extend2.default(true,{},userConfig.theme.DEFAULTS);[themeConfig,userConfig].forEach(function(config){config.modules=config.modules||{};Object.keys(config.modules).forEach(function(module){if(config.modules[module]===true){config.modules[module]={};}});});var moduleNames=Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));var moduleConfig=moduleNames.reduce(function(config,name){var moduleClass=Quill.import('modules/'+name);if(moduleClass==null){debug.error('Cannot load '+name+' module. Are you sure you registered it?');}else{config[name]=moduleClass.DEFAULTS||{};}return config;},{});if(userConfig.modules!=null&&userConfig.modules.toolbar&&userConfig.modules.toolbar.constructor!==Object){userConfig.modules.toolbar={container:userConfig.modules.toolbar};}userConfig=_extend2.default(true,{},Quill.DEFAULTS,{modules:moduleConfig},themeConfig,userConfig);['bounds','container','scrollingContainer'].forEach(function(key){if(typeof userConfig[key]==='string'){userConfig[key]=document.querySelector(userConfig[key]);}});userConfig.modules=Object.keys(userConfig.modules).reduce(function(config,name){if(userConfig.modules[name]){config[name]=userConfig.modules[name];}return config;},{});return userConfig;}function modify(modifier,source,index,shift){if(this.options.strict&&!this.isEnabled()&&source===_emitter4.default.sources.USER){return new _quillDelta2.default();}var range=index==null?null:this.getSelection();var oldDelta=this.editor.delta;var change=modifier();if(range!=null){if(index===true)index=range.index;if(shift==null){range=shiftRange(range,change,source);}else if(shift!==0){range=shiftRange(range,index,shift,source);}this.setSelection(range,_emitter4.default.sources.SILENT);}if(change.length()>0){var _emitter;var args=[_emitter4.default.events.TEXT_CHANGE,change,oldDelta,source];(_emitter=this.emitter).emit.apply(_emitter,[_emitter4.default.events.EDITOR_CHANGE].concat(args));if(source!==_emitter4.default.sources.SILENT){var _emitter2;(_emitter2=this.emitter).emit.apply(_emitter2,args);}}return change;}function overload(index,length,name,value,source){var formats={};if(typeof index.index==='number'&&typeof index.length==='number'){if(typeof length!=='number'){source=value,value=name,name=length,length=index.length,index=index.index;}else{length=index.length,index=index.index;}}else if(typeof length!=='number'){source=value,value=name,name=length,length=0;}if((typeof name==='undefined'?'undefined':_typeof(name))==='object'){formats=name;source=value;}else if(typeof name==='string'){if(value!=null){formats[name]=value;}else{source=name;}}source=source||_emitter4.default.sources.API;return [index,length,formats,source];}function shiftRange(range,index,length,source){if(range==null)return null;var start=void 0,end=void 0;if(index instanceof _quillDelta2.default){var _map=[range.index,range.index+range.length].map(function(pos){return index.transformPosition(pos,source!==_emitter4.default.sources.USER);});var _map2=_slicedToArray(_map,2);start=_map2[0];end=_map2[1];}else{var _map3=[range.index,range.index+range.length].map(function(pos){if(pos<index||pos===index&&source===_emitter4.default.sources.USER)return pos;if(length>=0){return pos+length;}else{return Math.max(index,pos+length);}});var _map4=_slicedToArray(_map3,2);start=_map4[0];end=_map4[1];}return new _selection.Range(start,end-start);}exports.expandConfig=expandConfig;exports.overload=overload;exports.default=Quill;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Inline=function(_Parchment$Inline){_inherits(Inline,_Parchment$Inline);function Inline(){_classCallCheck(this,Inline);return _possibleConstructorReturn(this,(Inline.__proto__||Object.getPrototypeOf(Inline)).apply(this,arguments));}_createClass(Inline,[{key:'formatAt',value:function formatAt(index,length,name,value){if(Inline.compare(this.statics.blotName,name)<0&&_parchment2.default.query(name,_parchment2.default.Scope.BLOT)){var blot=this.isolate(index,length);if(value){blot.wrap(name,value);}}else{_get(Inline.prototype.__proto__||Object.getPrototypeOf(Inline.prototype),'formatAt',this).call(this,index,length,name,value);}}},{key:'optimize',value:function optimize(context){_get(Inline.prototype.__proto__||Object.getPrototypeOf(Inline.prototype),'optimize',this).call(this,context);if(this.parent instanceof Inline&&Inline.compare(this.statics.blotName,this.parent.statics.blotName)>0){var parent=this.parent.isolate(this.offset(),this.length());this.moveChildren(parent);parent.wrap(this);}}}],[{key:'compare',value:function compare(self,other){var selfIndex=Inline.order.indexOf(self);var otherIndex=Inline.order.indexOf(other);if(selfIndex>=0||otherIndex>=0){return selfIndex-otherIndex;}else if(self===other){return 0;}else if(self<other){return -1;}else{return 1;}}}]);return Inline;}(_parchment2.default.Inline);Inline.allowedChildren=[Inline,_parchment2.default.Embed,_text2.default];Inline.order=['cursor','inline','underline','strike','italic','bold','script','link','code'];exports.default=Inline;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var TextBlot=function(_Parchment$Text){_inherits(TextBlot,_Parchment$Text);function TextBlot(){_classCallCheck(this,TextBlot);return _possibleConstructorReturn(this,(TextBlot.__proto__||Object.getPrototypeOf(TextBlot)).apply(this,arguments));}return TextBlot;}(_parchment2.default.Text);exports.default=TextBlot;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _eventemitter=__webpack_require__(54);var _eventemitter2=_interopRequireDefault(_eventemitter);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:events');var EVENTS=['selectionchange','mousedown','mouseup','click'];EVENTS.forEach(function(eventName){document.addEventListener(eventName,function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}[].slice.call(document.querySelectorAll('.ql-container')).forEach(function(node){if(node.__quill&&node.__quill.emitter){var _node$__quill$emitter;(_node$__quill$emitter=node.__quill.emitter).handleDOM.apply(_node$__quill$emitter,args);}});});});var Emitter=function(_EventEmitter){_inherits(Emitter,_EventEmitter);function Emitter(){_classCallCheck(this,Emitter);var _this=_possibleConstructorReturn(this,(Emitter.__proto__||Object.getPrototypeOf(Emitter)).call(this));_this.listeners={};_this.on('error',debug.error);return _this;}_createClass(Emitter,[{key:'emit',value:function emit(){debug.log.apply(debug,arguments);_get(Emitter.prototype.__proto__||Object.getPrototypeOf(Emitter.prototype),'emit',this).apply(this,arguments);}},{key:'handleDOM',value:function handleDOM(event){for(var _len2=arguments.length,args=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}(this.listeners[event.type]||[]).forEach(function(_ref){var node=_ref.node,handler=_ref.handler;if(event.target===node||node.contains(event.target)){handler.apply(undefined,[event].concat(args));}});}},{key:'listenDOM',value:function listenDOM(eventName,node,handler){if(!this.listeners[eventName]){this.listeners[eventName]=[];}this.listeners[eventName].push({node:node,handler:handler});}}]);return Emitter;}(_eventemitter2.default);Emitter.events={EDITOR_CHANGE:'editor-change',SCROLL_BEFORE_UPDATE:'scroll-before-update',SCROLL_OPTIMIZE:'scroll-optimize',SCROLL_UPDATE:'scroll-update',SELECTION_CHANGE:'selection-change',TEXT_CHANGE:'text-change'};Emitter.sources={API:'api',SILENT:'silent',USER:'user'};exports.default=Emitter;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Module=function Module(quill){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Module);this.quill=quill;this.options=options;};Module.DEFAULTS={};exports.default=Module;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var levels=['error','warn','log','info'];var level='warn';function debug(method){if(levels.indexOf(method)<=levels.indexOf(level)){var _console;for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}(_console=console)[method].apply(_console,args);}}function namespace(ns){return levels.reduce(function(logger,method){logger[method]=debug.bind(console,method,ns);return logger;},{});}debug.level=namespace.level=function(newLevel){level=newLevel;};exports.default=namespace;},function(module,exports,__webpack_require__){var pSlice=Array.prototype.slice;var objectKeys=__webpack_require__(52);var isArguments=__webpack_require__(53);var deepEqual=module.exports=function(actual,expected,opts){if(!opts)opts={};if(actual===expected){return true;}else if(actual instanceof Date&&expected instanceof Date){return actual.getTime()===expected.getTime();}else if(!actual||!expected||typeof actual!='object'&&typeof expected!='object'){return opts.strict?actual===expected:actual==expected;}else{return objEquiv(actual,expected,opts);}};function isUndefinedOrNull(value){return value===null||value===undefined;}function isBuffer(x){if(!x||typeof x!=='object'||typeof x.length!=='number')return false;if(typeof x.copy!=='function'||typeof x.slice!=='function'){return false;}if(x.length>0&&typeof x[0]!=='number')return false;return true;}function objEquiv(a,b,opts){var i,key;if(isUndefinedOrNull(a)||isUndefinedOrNull(b))return false;if(a.prototype!==b.prototype)return false;if(isArguments(a)){if(!isArguments(b)){return false;}a=pSlice.call(a);b=pSlice.call(b);return deepEqual(a,b,opts);}if(isBuffer(a)){if(!isBuffer(b)){return false;}if(a.length!==b.length)return false;for(i=0;i<a.length;i++){if(a[i]!==b[i])return false;}return true;}try{var ka=objectKeys(a),kb=objectKeys(b);}catch(e){return false;}if(ka.length!=kb.length)return false;ka.sort();kb.sort();for(i=ka.length-1;i>=0;i--){if(ka[i]!=kb[i])return false;}for(i=ka.length-1;i>=0;i--){key=ka[i];if(!deepEqual(a[key],b[key],opts))return false;}return typeof a===typeof b;}},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var Registry=__webpack_require__(1);var Attributor=function(){function Attributor(attrName,keyName,options){if(options===void 0){options={};}this.attrName=attrName;this.keyName=keyName;var attributeBit=Registry.Scope.TYPE&Registry.Scope.ATTRIBUTE;if(options.scope!=null){this.scope=options.scope&Registry.Scope.LEVEL|attributeBit;}else{this.scope=Registry.Scope.ATTRIBUTE;}if(options.whitelist!=null)this.whitelist=options.whitelist;}Attributor.keys=function(node){return [].map.call(node.attributes,function(item){return item.name;});};Attributor.prototype.add=function(node,value){if(!this.canAdd(node,value))return false;node.setAttribute(this.keyName,value);return true;};Attributor.prototype.canAdd=function(node,value){var match=Registry.query(node,Registry.Scope.BLOT&(this.scope|Registry.Scope.TYPE));if(match==null)return false;if(this.whitelist==null)return true;if(typeof value==='string'){return this.whitelist.indexOf(value.replace(/["']/g,''))>-1;}else{return this.whitelist.indexOf(value)>-1;}};Attributor.prototype.remove=function(node){node.removeAttribute(this.keyName);};Attributor.prototype.value=function(node){var value=node.getAttribute(this.keyName);return this.canAdd(node,value)?value:'';};return Attributor;}();exports.default=Attributor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.Code=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Code=function(_Inline){_inherits(Code,_Inline);function Code(){_classCallCheck(this,Code);return _possibleConstructorReturn(this,(Code.__proto__||Object.getPrototypeOf(Code)).apply(this,arguments));}return Code;}(_inline2.default);Code.blotName='code';Code.tagName='CODE';var CodeBlock=function(_Block){_inherits(CodeBlock,_Block);function CodeBlock(){_classCallCheck(this,CodeBlock);return _possibleConstructorReturn(this,(CodeBlock.__proto__||Object.getPrototypeOf(CodeBlock)).apply(this,arguments));}_createClass(CodeBlock,[{key:'delta',value:function delta(){var _this3=this;var text=this.domNode.textContent;if(text.endsWith('\n')){text=text.slice(0,-1);}return text.split('\n').reduce(function(delta,frag){return delta.insert(frag).insert('\n',_this3.formats());},new _quillDelta2.default());}},{key:'format',value:function format(name,value){if(name===this.statics.blotName&&value)return;var _descendant=this.descendant(_text2.default,this.length()-1),_descendant2=_slicedToArray(_descendant,1),text=_descendant2[0];if(text!=null){text.deleteAt(text.length()-1,1);}_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),'format',this).call(this,name,value);}},{key:'formatAt',value:function formatAt(index,length,name,value){if(length===0)return;if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)==null||name===this.statics.blotName&&value===this.statics.formats(this.domNode)){return;}var nextNewline=this.newlineIndex(index);if(nextNewline<0||nextNewline>=index+length)return;var prevNewline=this.newlineIndex(index,true)+1;var isolateLength=nextNewline-prevNewline+1;var blot=this.isolate(prevNewline,isolateLength);var next=blot.next;blot.format(name,value);if(next instanceof CodeBlock){next.formatAt(0,index-prevNewline+length-isolateLength,name,value);}}},{key:'insertAt',value:function insertAt(index,value,def){if(def!=null)return;var _descendant3=this.descendant(_text2.default,index),_descendant4=_slicedToArray(_descendant3,2),text=_descendant4[0],offset=_descendant4[1];text.insertAt(offset,value);}},{key:'length',value:function length(){var length=this.domNode.textContent.length;if(!this.domNode.textContent.endsWith('\n')){return length+1;}return length;}},{key:'newlineIndex',value:function newlineIndex(searchIndex){var reverse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!reverse){var offset=this.domNode.textContent.slice(searchIndex).indexOf('\n');return offset>-1?searchIndex+offset:-1;}else{return this.domNode.textContent.slice(0,searchIndex).lastIndexOf('\n');}}},{key:'optimize',value:function optimize(context){if(!this.domNode.textContent.endsWith('\n')){this.appendChild(_parchment2.default.create('text','\n'));}_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),'optimize',this).call(this,context);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&this.statics.formats(this.domNode)===next.statics.formats(next.domNode)){next.optimize(context);next.moveChildren(this);next.remove();}}},{key:'replace',value:function replace(target){_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),'replace',this).call(this,target);[].slice.call(this.domNode.querySelectorAll('*')).forEach(function(node){var blot=_parchment2.default.find(node);if(blot==null){node.parentNode.removeChild(node);}else if(blot instanceof _parchment2.default.Embed){blot.remove();}else{blot.unwrap();}});}}],[{key:'create',value:function create(value){var domNode=_get(CodeBlock.__proto__||Object.getPrototypeOf(CodeBlock),'create',this).call(this,value);domNode.setAttribute('spellcheck',false);return domNode;}},{key:'formats',value:function formats(){return true;}}]);return CodeBlock;}(_block2.default);CodeBlock.blotName='code-block';CodeBlock.tagName='PRE';CodeBlock.TAB='  ';exports.Code=Code;exports.default=CodeBlock;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _op=__webpack_require__(20);var _op2=_interopRequireDefault(_op);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _cursor=__webpack_require__(23);var _cursor2=_interopRequireDefault(_cursor);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _clone=__webpack_require__(21);var _clone2=_interopRequireDefault(_clone);var _deepEqual=__webpack_require__(11);var _deepEqual2=_interopRequireDefault(_deepEqual);var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var ASCII=/^[ -~]*$/;var Editor=function(){function Editor(scroll){_classCallCheck(this,Editor);this.scroll=scroll;this.delta=this.getDelta();}_createClass(Editor,[{key:'applyDelta',value:function applyDelta(delta){var _this=this;var consumeNextNewline=false;this.scroll.update();var scrollLength=this.scroll.length();this.scroll.batchStart();delta=normalizeDelta(delta);delta.reduce(function(index,op){var length=op.retain||op.delete||op.insert.length||1;var attributes=op.attributes||{};if(op.insert!=null){if(typeof op.insert==='string'){var text=op.insert;if(text.endsWith('\n')&&consumeNextNewline){consumeNextNewline=false;text=text.slice(0,-1);}if(index>=scrollLength&&!text.endsWith('\n')){consumeNextNewline=true;}_this.scroll.insertAt(index,text);var _scroll$line=_this.scroll.line(index),_scroll$line2=_slicedToArray(_scroll$line,2),line=_scroll$line2[0],offset=_scroll$line2[1];var formats=_extend2.default({},_block.bubbleFormats(line));if(line instanceof _block2.default){var _line$descendant=line.descendant(_parchment2.default.Leaf,offset),_line$descendant2=_slicedToArray(_line$descendant,1),leaf=_line$descendant2[0];formats=_extend2.default(formats,_block.bubbleFormats(leaf));}attributes=_op2.default.attributes.diff(formats,attributes)||{};}else if(_typeof(op.insert)==='object'){var key=Object.keys(op.insert)[0];if(key==null)return index;_this.scroll.insertAt(index,key,op.insert[key]);}scrollLength+=length;}Object.keys(attributes).forEach(function(name){_this.scroll.formatAt(index,length,name,attributes[name]);});return index+length;},0);delta.reduce(function(index,op){if(typeof op.delete==='number'){_this.scroll.deleteAt(index,op.delete);return index;}return index+(op.retain||op.insert.length||1);},0);this.scroll.batchEnd();return this.update(delta);}},{key:'deleteText',value:function deleteText(index,length){this.scroll.deleteAt(index,length);return this.update(new _quillDelta2.default().retain(index).delete(length));}},{key:'formatLine',value:function formatLine(index,length){var _this2=this;var formats=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.scroll.update();Object.keys(formats).forEach(function(format){if(_this2.scroll.whitelist!=null&&!_this2.scroll.whitelist[format])return;var lines=_this2.scroll.lines(index,Math.max(length,1));var lengthRemaining=length;lines.forEach(function(line){var lineLength=line.length();if(!(line instanceof _code2.default)){line.format(format,formats[format]);}else{var codeIndex=index-line.offset(_this2.scroll);var codeLength=line.newlineIndex(codeIndex+lengthRemaining)-codeIndex+1;line.formatAt(codeIndex,codeLength,format,formats[format]);}lengthRemaining-=lineLength;});});this.scroll.optimize();return this.update(new _quillDelta2.default().retain(index).retain(length,_clone2.default(formats)));}},{key:'formatText',value:function formatText(index,length){var _this3=this;var formats=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};Object.keys(formats).forEach(function(format){_this3.scroll.formatAt(index,length,format,formats[format]);});return this.update(new _quillDelta2.default().retain(index).retain(length,_clone2.default(formats)));}},{key:'getContents',value:function getContents(index,length){return this.delta.slice(index,index+length);}},{key:'getDelta',value:function getDelta(){return this.scroll.lines().reduce(function(delta,line){return delta.concat(line.delta());},new _quillDelta2.default());}},{key:'getFormat',value:function getFormat(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var lines=[],leaves=[];if(length===0){this.scroll.path(index).forEach(function(path){var _path=_slicedToArray(path,1),blot=_path[0];if(blot instanceof _block2.default){lines.push(blot);}else if(blot instanceof _parchment2.default.Leaf){leaves.push(blot);}});}else{lines=this.scroll.lines(index,length);leaves=this.scroll.descendants(_parchment2.default.Leaf,index,length);}var formatsArr=[lines,leaves].map(function(blots){if(blots.length===0)return {};var formats=_block.bubbleFormats(blots.shift());while(Object.keys(formats).length>0){var blot=blots.shift();if(blot==null)return formats;formats=combineFormats(_block.bubbleFormats(blot),formats);}return formats;});return _extend2.default.apply(_extend2.default,formatsArr);}},{key:'getText',value:function getText(index,length){return this.getContents(index,length).filter(function(op){return typeof op.insert==='string';}).map(function(op){return op.insert;}).join('');}},{key:'insertEmbed',value:function insertEmbed(index,embed,value){this.scroll.insertAt(index,embed,value);return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({},embed,value)));}},{key:'insertText',value:function insertText(index,text){var _this4=this;var formats=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};text=text.replace(/\r\n/g,'\n').replace(/\r/g,'\n');this.scroll.insertAt(index,text);Object.keys(formats).forEach(function(format){_this4.scroll.formatAt(index,text.length,format,formats[format]);});return this.update(new _quillDelta2.default().retain(index).insert(text,_clone2.default(formats)));}},{key:'isBlank',value:function isBlank(){if(this.scroll.children.length==0)return true;if(this.scroll.children.length>1)return false;var block=this.scroll.children.head;if(block.statics.blotName!==_block2.default.blotName)return false;if(block.children.length>1)return false;return block.children.head instanceof _break2.default;}},{key:'removeFormat',value:function removeFormat(index,length){var text=this.getText(index,length);var _scroll$line3=this.scroll.line(index+length),_scroll$line4=_slicedToArray(_scroll$line3,2),line=_scroll$line4[0],offset=_scroll$line4[1];var suffixLength=0,suffix=new _quillDelta2.default();if(line!=null){if(!(line instanceof _code2.default)){suffixLength=line.length()-offset;}else{suffixLength=line.newlineIndex(offset)-offset+1;}suffix=line.delta().slice(offset,offset+suffixLength-1).insert('\n');}var contents=this.getContents(index,length+suffixLength);var diff=contents.diff(new _quillDelta2.default().insert(text).concat(suffix));var delta=new _quillDelta2.default().retain(index).concat(diff);return this.applyDelta(delta);}},{key:'update',value:function update(change){var mutations=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var cursorIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;var oldDelta=this.delta;if(mutations.length===1&&mutations[0].type==='characterData'&&mutations[0].target.data.match(ASCII)&&_parchment2.default.find(mutations[0].target)){var textBlot=_parchment2.default.find(mutations[0].target);var formats=_block.bubbleFormats(textBlot);var index=textBlot.offset(this.scroll);var oldValue=mutations[0].oldValue.replace(_cursor2.default.CONTENTS,'');var oldText=new _quillDelta2.default().insert(oldValue);var newText=new _quillDelta2.default().insert(textBlot.value());var diffDelta=new _quillDelta2.default().retain(index).concat(oldText.diff(newText,cursorIndex));change=diffDelta.reduce(function(delta,op){if(op.insert){return delta.insert(op.insert,formats);}else{return delta.push(op);}},new _quillDelta2.default());this.delta=oldDelta.compose(change);}else{this.delta=this.getDelta();if(!change||!_deepEqual2.default(oldDelta.compose(change),this.delta)){change=oldDelta.diff(this.delta,cursorIndex);}}return change;}}]);return Editor;}();function combineFormats(formats,combined){return Object.keys(combined).reduce(function(merged,name){if(formats[name]==null)return merged;if(combined[name]===formats[name]){merged[name]=combined[name];}else if(Array.isArray(combined[name])){if(combined[name].indexOf(formats[name])<0){merged[name]=combined[name].concat([formats[name]]);}}else{merged[name]=[combined[name],formats[name]];}return merged;},{});}function normalizeDelta(delta){return delta.reduce(function(delta,op){if(op.insert===1){var attributes=_clone2.default(op.attributes);delete attributes['image'];return delta.insert({image:op.attributes.image},attributes);}if(op.attributes!=null&&(op.attributes.list===true||op.attributes.bullet===true)){op=_clone2.default(op);if(op.attributes.list){op.attributes.list='ordered';}else{op.attributes.list='bullet';delete op.attributes.bullet;}}if(typeof op.insert==='string'){var text=op.insert.replace(/\r\n/g,'\n').replace(/\r/g,'\n');return delta.insert(text,op.attributes);}return delta.push(op);},new _quillDelta2.default());}exports.default=Editor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.Range=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _clone=__webpack_require__(21);var _clone2=_interopRequireDefault(_clone);var _deepEqual=__webpack_require__(11);var _deepEqual2=_interopRequireDefault(_deepEqual);var _emitter3=__webpack_require__(8);var _emitter4=_interopRequireDefault(_emitter3);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var debug=_logger2.default('quill:selection');var Range=function Range(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,Range);this.index=index;this.length=length;};var Selection=function(){function Selection(scroll,emitter){var _this=this;_classCallCheck(this,Selection);this.emitter=emitter;this.scroll=scroll;this.composing=false;this.mouseDown=false;this.root=this.scroll.domNode;this.cursor=_parchment2.default.create('cursor',this);this.lastRange=this.savedRange=new Range(0,0);this.handleComposition();this.handleDragging();this.emitter.listenDOM('selectionchange',document,function(){if(!_this.mouseDown){setTimeout(_this.update.bind(_this,_emitter4.default.sources.USER),1);}});this.emitter.on(_emitter4.default.events.EDITOR_CHANGE,function(type,delta){if(type===_emitter4.default.events.TEXT_CHANGE&&delta.length()>0){_this.update(_emitter4.default.sources.SILENT);}});this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE,function(){if(!_this.hasFocus())return;var native=_this.getNativeRange();if(native==null)return;if(native.start.node===_this.cursor.textNode)return;_this.emitter.once(_emitter4.default.events.SCROLL_UPDATE,function(){try{_this.setNativeRange(native.start.node,native.start.offset,native.end.node,native.end.offset);}catch(ignored){}});});this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE,function(mutations,context){if(context.range){var _context$range=context.range,startNode=_context$range.startNode,startOffset=_context$range.startOffset,endNode=_context$range.endNode,endOffset=_context$range.endOffset;_this.setNativeRange(startNode,startOffset,endNode,endOffset);}});this.update(_emitter4.default.sources.SILENT);}_createClass(Selection,[{key:'handleComposition',value:function handleComposition(){var _this2=this;this.root.addEventListener('compositionstart',function(){_this2.composing=true;});this.root.addEventListener('compositionend',function(){_this2.composing=false;if(_this2.cursor.parent){var range=_this2.cursor.restore();if(!range)return;setTimeout(function(){_this2.setNativeRange(range.startNode,range.startOffset,range.endNode,range.endOffset);},1);}});}},{key:'handleDragging',value:function handleDragging(){var _this3=this;this.emitter.listenDOM('mousedown',document.body,function(){_this3.mouseDown=true;});this.emitter.listenDOM('mouseup',document.body,function(){_this3.mouseDown=false;_this3.update(_emitter4.default.sources.USER);});}},{key:'focus',value:function focus(){if(this.hasFocus())return;this.root.focus();this.setRange(this.savedRange);}},{key:'format',value:function format(_format,value){if(this.scroll.whitelist!=null&&!this.scroll.whitelist[_format])return;this.scroll.update();var nativeRange=this.getNativeRange();if(nativeRange==null||!nativeRange.native.collapsed||_parchment2.default.query(_format,_parchment2.default.Scope.BLOCK))return;if(nativeRange.start.node!==this.cursor.textNode){var blot=_parchment2.default.find(nativeRange.start.node,false);if(blot==null)return;if(blot instanceof _parchment2.default.Leaf){var after=blot.split(nativeRange.start.offset);blot.parent.insertBefore(this.cursor,after);}else{blot.insertBefore(this.cursor,nativeRange.start.node);}this.cursor.attach();}this.cursor.format(_format,value);this.scroll.optimize();this.setNativeRange(this.cursor.textNode,this.cursor.textNode.data.length);this.update();}},{key:'getBounds',value:function getBounds(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var scrollLength=this.scroll.length();index=Math.min(index,scrollLength-1);length=Math.min(index+length,scrollLength-1)-index;var node=void 0,_scroll$leaf=this.scroll.leaf(index),_scroll$leaf2=_slicedToArray(_scroll$leaf,2),leaf=_scroll$leaf2[0],offset=_scroll$leaf2[1];if(leaf==null)return null;var _leaf$position=leaf.position(offset,true);var _leaf$position2=_slicedToArray(_leaf$position,2);node=_leaf$position2[0];offset=_leaf$position2[1];var range=document.createRange();if(length>0){range.setStart(node,offset);var _scroll$leaf3=this.scroll.leaf(index+length);var _scroll$leaf4=_slicedToArray(_scroll$leaf3,2);leaf=_scroll$leaf4[0];offset=_scroll$leaf4[1];if(leaf==null)return null;var _leaf$position3=leaf.position(offset,true);var _leaf$position4=_slicedToArray(_leaf$position3,2);node=_leaf$position4[0];offset=_leaf$position4[1];range.setEnd(node,offset);return range.getBoundingClientRect();}else{var side='left';var rect=void 0;if(node instanceof Text){if(offset<node.data.length){range.setStart(node,offset);range.setEnd(node,offset+1);}else{range.setStart(node,offset-1);range.setEnd(node,offset);side='right';}rect=range.getBoundingClientRect();}else{rect=leaf.domNode.getBoundingClientRect();if(offset>0)side='right';}return {bottom:rect.top+rect.height,height:rect.height,left:rect[side],right:rect[side],top:rect.top,width:0};}}},{key:'getNativeRange',value:function getNativeRange(){var selection=document.getSelection();if(selection==null||selection.rangeCount<=0)return null;var nativeRange=selection.getRangeAt(0);if(nativeRange==null)return null;var range=this.normalizeNative(nativeRange);debug.info('getNativeRange',range);return range;}},{key:'getRange',value:function getRange(){var normalized=this.getNativeRange();if(normalized==null)return [null,null];var range=this.normalizedToRange(normalized);return [range,normalized];}},{key:'hasFocus',value:function hasFocus(){return document.activeElement===this.root;}},{key:'normalizedToRange',value:function normalizedToRange(range){var _this4=this;var positions=[[range.start.node,range.start.offset]];if(!range.native.collapsed){positions.push([range.end.node,range.end.offset]);}var indexes=positions.map(function(position){var _position=_slicedToArray(position,2),node=_position[0],offset=_position[1];var blot=_parchment2.default.find(node,true);var index=blot.offset(_this4.scroll);if(offset===0){return index;}else if(blot instanceof _parchment2.default.Container){return index+blot.length();}else{return index+blot.index(node,offset);}});var end=Math.min(Math.max.apply(Math,_toConsumableArray(indexes)),this.scroll.length()-1);var start=Math.min.apply(Math,[end].concat(_toConsumableArray(indexes)));return new Range(start,end-start);}},{key:'normalizeNative',value:function normalizeNative(nativeRange){if(!contains(this.root,nativeRange.startContainer)||!nativeRange.collapsed&&!contains(this.root,nativeRange.endContainer)){return null;}var range={start:{node:nativeRange.startContainer,offset:nativeRange.startOffset},end:{node:nativeRange.endContainer,offset:nativeRange.endOffset},native:nativeRange};[range.start,range.end].forEach(function(position){var node=position.node,offset=position.offset;while(!(node instanceof Text)&&node.childNodes.length>0){if(node.childNodes.length>offset){node=node.childNodes[offset];offset=0;}else if(node.childNodes.length===offset){node=node.lastChild;offset=node instanceof Text?node.data.length:node.childNodes.length+1;}else{break;}}position.node=node,position.offset=offset;});return range;}},{key:'rangeToNative',value:function rangeToNative(range){var _this5=this;var indexes=range.collapsed?[range.index]:[range.index,range.index+range.length];var args=[];var scrollLength=this.scroll.length();indexes.forEach(function(index,i){index=Math.min(scrollLength-1,index);var node=void 0,_scroll$leaf5=_this5.scroll.leaf(index),_scroll$leaf6=_slicedToArray(_scroll$leaf5,2),leaf=_scroll$leaf6[0],offset=_scroll$leaf6[1];var _leaf$position5=leaf.position(offset,i!==0);var _leaf$position6=_slicedToArray(_leaf$position5,2);node=_leaf$position6[0];offset=_leaf$position6[1];args.push(node,offset);});if(args.length<2){args=args.concat(args);}return args;}},{key:'scrollIntoView',value:function scrollIntoView(scrollingContainer){var range=this.lastRange;if(range==null)return;var bounds=this.getBounds(range.index,range.length);if(bounds==null)return;var limit=this.scroll.length()-1;var _scroll$line=this.scroll.line(Math.min(range.index,limit)),_scroll$line2=_slicedToArray(_scroll$line,1),first=_scroll$line2[0];var last=first;if(range.length>0){var _scroll$line3=this.scroll.line(Math.min(range.index+range.length,limit));var _scroll$line4=_slicedToArray(_scroll$line3,1);last=_scroll$line4[0];}if(first==null||last==null)return;var scrollBounds=scrollingContainer.getBoundingClientRect();if(bounds.top<scrollBounds.top){scrollingContainer.scrollTop-=scrollBounds.top-bounds.top;}else if(bounds.bottom>scrollBounds.bottom){scrollingContainer.scrollTop+=bounds.bottom-scrollBounds.bottom;}}},{key:'setNativeRange',value:function setNativeRange(startNode,startOffset){var endNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:startNode;var endOffset=arguments.length>3&&arguments[3]!==undefined?arguments[3]:startOffset;var force=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;debug.info('setNativeRange',startNode,startOffset,endNode,endOffset);if(startNode!=null&&(this.root.parentNode==null||startNode.parentNode==null||endNode.parentNode==null)){return;}var selection=document.getSelection();if(selection==null)return;if(startNode!=null){if(!this.hasFocus())this.root.focus();var native=(this.getNativeRange()||{}).native;if(native==null||force||startNode!==native.startContainer||startOffset!==native.startOffset||endNode!==native.endContainer||endOffset!==native.endOffset){if(startNode.tagName=="BR"){startOffset=[].indexOf.call(startNode.parentNode.childNodes,startNode);startNode=startNode.parentNode;}if(endNode.tagName=="BR"){endOffset=[].indexOf.call(endNode.parentNode.childNodes,endNode);endNode=endNode.parentNode;}var range=document.createRange();range.setStart(startNode,startOffset);range.setEnd(endNode,endOffset);selection.removeAllRanges();selection.addRange(range);}}else{selection.removeAllRanges();this.root.blur();document.body.focus();}}},{key:'setRange',value:function setRange(range){var force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var source=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_emitter4.default.sources.API;if(typeof force==='string'){source=force;force=false;}debug.info('setRange',range);if(range!=null){var args=this.rangeToNative(range);this.setNativeRange.apply(this,_toConsumableArray(args).concat([force]));}else{this.setNativeRange(null);}this.update(source);}},{key:'update',value:function update(){var source=arguments.length>0&&arguments[0]!==undefined?arguments[0]:_emitter4.default.sources.USER;var oldRange=this.lastRange;var _getRange=this.getRange(),_getRange2=_slicedToArray(_getRange,2),lastRange=_getRange2[0],nativeRange=_getRange2[1];this.lastRange=lastRange;if(this.lastRange!=null){this.savedRange=this.lastRange;}if(!_deepEqual2.default(oldRange,this.lastRange)){var _emitter;if(!this.composing&&nativeRange!=null&&nativeRange.native.collapsed&&nativeRange.start.node!==this.cursor.textNode){this.cursor.restore();}var args=[_emitter4.default.events.SELECTION_CHANGE,_clone2.default(this.lastRange),_clone2.default(oldRange),source];(_emitter=this.emitter).emit.apply(_emitter,[_emitter4.default.events.EDITOR_CHANGE].concat(args));if(source!==_emitter4.default.sources.SILENT){var _emitter2;(_emitter2=this.emitter).emit.apply(_emitter2,args);}}}}]);return Selection;}();function contains(parent,descendant){try{descendant.parentNode;}catch(e){return false;}if(descendant instanceof Text){descendant=descendant.parentNode;}return parent.contains(descendant);}exports.Range=Range;exports.default=Selection;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Break=function(_Parchment$Embed){_inherits(Break,_Parchment$Embed);function Break(){_classCallCheck(this,Break);return _possibleConstructorReturn(this,(Break.__proto__||Object.getPrototypeOf(Break)).apply(this,arguments));}_createClass(Break,[{key:'insertInto',value:function insertInto(parent,ref){if(parent.children.length===0){_get(Break.prototype.__proto__||Object.getPrototypeOf(Break.prototype),'insertInto',this).call(this,parent,ref);}else{this.remove();}}},{key:'length',value:function length(){return 0;}},{key:'value',value:function value(){return '';}}],[{key:'value',value:function value(){return undefined;}}]);return Break;}(_parchment2.default.Embed);Break.blotName='break';Break.tagName='BR';exports.default=Break;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var linked_list_1=__webpack_require__(44);var shadow_1=__webpack_require__(30);var Registry=__webpack_require__(1);var ContainerBlot=function(_super){__extends(ContainerBlot,_super);function ContainerBlot(domNode){var _this=_super.call(this,domNode)||this;_this.build();return _this;}ContainerBlot.prototype.appendChild=function(other){this.insertBefore(other);};ContainerBlot.prototype.attach=function(){_super.prototype.attach.call(this);this.children.forEach(function(child){child.attach();});};ContainerBlot.prototype.build=function(){var _this=this;this.children=new linked_list_1.default();[].slice.call(this.domNode.childNodes).reverse().forEach(function(node){try{var child=makeBlot(node);_this.insertBefore(child,_this.children.head);}catch(err){if(err instanceof Registry.ParchmentError)return;else throw err;}});};ContainerBlot.prototype.deleteAt=function(index,length){if(index===0&&length===this.length()){return this.remove();}this.children.forEachAt(index,length,function(child,offset,length){child.deleteAt(offset,length);});};ContainerBlot.prototype.descendant=function(criteria,index){var _a=this.children.find(index),child=_a[0],offset=_a[1];if(criteria.blotName==null&&criteria(child)||criteria.blotName!=null&&child instanceof criteria){return [child,offset];}else if(child instanceof ContainerBlot){return child.descendant(criteria,offset);}else{return [null,-1];}};ContainerBlot.prototype.descendants=function(criteria,index,length){if(index===void 0){index=0;}if(length===void 0){length=Number.MAX_VALUE;}var descendants=[],lengthLeft=length;this.children.forEachAt(index,length,function(child,index,length){if(criteria.blotName==null&&criteria(child)||criteria.blotName!=null&&child instanceof criteria){descendants.push(child);}if(child instanceof ContainerBlot){descendants=descendants.concat(child.descendants(criteria,index,lengthLeft));}lengthLeft-=length;});return descendants;};ContainerBlot.prototype.detach=function(){this.children.forEach(function(child){child.detach();});_super.prototype.detach.call(this);};ContainerBlot.prototype.formatAt=function(index,length,name,value){this.children.forEachAt(index,length,function(child,offset,length){child.formatAt(offset,length,name,value);});};ContainerBlot.prototype.insertAt=function(index,value,def){var _a=this.children.find(index),child=_a[0],offset=_a[1];if(child){child.insertAt(offset,value,def);}else{var blot=def==null?Registry.create('text',value):Registry.create(value,def);this.appendChild(blot);}};ContainerBlot.prototype.insertBefore=function(childBlot,refBlot){if(this.statics.allowedChildren!=null&&!this.statics.allowedChildren.some(function(child){return childBlot instanceof child;})){throw new Registry.ParchmentError("Cannot insert "+childBlot.statics.blotName+" into "+this.statics.blotName);}childBlot.insertInto(this,refBlot);};ContainerBlot.prototype.length=function(){return this.children.reduce(function(memo,child){return memo+child.length();},0);};ContainerBlot.prototype.moveChildren=function(targetParent,refNode){this.children.forEach(function(child){targetParent.insertBefore(child,refNode);});};ContainerBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);if(this.children.length===0){if(this.statics.defaultChild!=null){var child=Registry.create(this.statics.defaultChild);this.appendChild(child);child.optimize(context);}else{this.remove();}}};ContainerBlot.prototype.path=function(index,inclusive){if(inclusive===void 0){inclusive=false;}var _a=this.children.find(index,inclusive),child=_a[0],offset=_a[1];var position=[[this,index]];if(child instanceof ContainerBlot){return position.concat(child.path(offset,inclusive));}else if(child!=null){position.push([child,offset]);}return position;};ContainerBlot.prototype.removeChild=function(child){this.children.remove(child);};ContainerBlot.prototype.replace=function(target){if(target instanceof ContainerBlot){target.moveChildren(this);}_super.prototype.replace.call(this,target);};ContainerBlot.prototype.split=function(index,force){if(force===void 0){force=false;}if(!force){if(index===0)return this;if(index===this.length())return this.next;}var after=this.clone();this.parent.insertBefore(after,this.next);this.children.forEachAt(index,this.length(),function(child,offset,length){child=child.split(offset,force);after.appendChild(child);});return after;};ContainerBlot.prototype.unwrap=function(){this.moveChildren(this.parent,this.next);this.remove();};ContainerBlot.prototype.update=function(mutations,context){var _this=this;var addedNodes=[],removedNodes=[];mutations.forEach(function(mutation){if(mutation.target===_this.domNode&&mutation.type==='childList'){addedNodes.push.apply(addedNodes,mutation.addedNodes);removedNodes.push.apply(removedNodes,mutation.removedNodes);}});removedNodes.forEach(function(node){if(node.parentNode!=null&&node.tagName!=='IFRAME'&&document.body.compareDocumentPosition(node)&Node.DOCUMENT_POSITION_CONTAINED_BY){return;}var blot=Registry.find(node);if(blot==null)return;if(blot.domNode.parentNode==null||blot.domNode.parentNode===_this.domNode){blot.detach();}});addedNodes.filter(function(node){return node.parentNode==_this.domNode;}).sort(function(a,b){if(a===b)return 0;if(a.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_FOLLOWING){return 1;}return -1;}).forEach(function(node){var refBlot=null;if(node.nextSibling!=null){refBlot=Registry.find(node.nextSibling);}var blot=makeBlot(node);if(blot.next!=refBlot||blot.next==null){if(blot.parent!=null){blot.parent.removeChild(_this);}_this.insertBefore(blot,refBlot);}});};return ContainerBlot;}(shadow_1.default);function makeBlot(node){var blot=Registry.find(node);if(blot==null){try{blot=Registry.create(node);}catch(e){blot=Registry.create(Registry.Scope.INLINE);[].slice.call(node.childNodes).forEach(function(child){blot.domNode.appendChild(child);});node.parentNode.replaceChild(blot.domNode,node);blot.attach();}}return blot;}exports.default=ContainerBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);var store_1=__webpack_require__(31);var container_1=__webpack_require__(17);var Registry=__webpack_require__(1);var FormatBlot=function(_super){__extends(FormatBlot,_super);function FormatBlot(domNode){var _this=_super.call(this,domNode)||this;_this.attributes=new store_1.default(_this.domNode);return _this;}FormatBlot.formats=function(domNode){if(typeof this.tagName==='string'){return true;}else if(Array.isArray(this.tagName)){return domNode.tagName.toLowerCase();}return undefined;};FormatBlot.prototype.format=function(name,value){var format=Registry.query(name);if(format instanceof attributor_1.default){this.attributes.attribute(format,value);}else if(value){if(format!=null&&(name!==this.statics.blotName||this.formats()[name]!==value)){this.replaceWith(name,value);}}};FormatBlot.prototype.formats=function(){var formats=this.attributes.values();var format=this.statics.formats(this.domNode);if(format!=null){formats[this.statics.blotName]=format;}return formats;};FormatBlot.prototype.replaceWith=function(name,value){var replacement=_super.prototype.replaceWith.call(this,name,value);this.attributes.copy(replacement);return replacement;};FormatBlot.prototype.update=function(mutations,context){var _this=this;_super.prototype.update.call(this,mutations,context);if(mutations.some(function(mutation){return mutation.target===_this.domNode&&mutation.type==='attributes';})){this.attributes.build();}};FormatBlot.prototype.wrap=function(name,value){var wrapper=_super.prototype.wrap.call(this,name,value);if(wrapper instanceof FormatBlot&&wrapper.statics.scope===this.statics.scope){this.attributes.move(wrapper);}return wrapper;};return FormatBlot;}(container_1.default);exports.default=FormatBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var shadow_1=__webpack_require__(30);var Registry=__webpack_require__(1);var LeafBlot=function(_super){__extends(LeafBlot,_super);function LeafBlot(){return _super!==null&&_super.apply(this,arguments)||this;}LeafBlot.value=function(domNode){return true;};LeafBlot.prototype.index=function(node,offset){if(this.domNode===node||this.domNode.compareDocumentPosition(node)&Node.DOCUMENT_POSITION_CONTAINED_BY){return Math.min(offset,1);}return -1;};LeafBlot.prototype.position=function(index,inclusive){var offset=[].indexOf.call(this.parent.domNode.childNodes,this.domNode);if(index>0)offset+=1;return [this.parent.domNode,offset];};LeafBlot.prototype.value=function(){return _a={},_a[this.statics.blotName]=this.statics.value(this.domNode)||true,_a;var _a;};LeafBlot.scope=Registry.Scope.INLINE_BLOT;return LeafBlot;}(shadow_1.default);exports.default=LeafBlot;},function(module,exports,__webpack_require__){var equal=__webpack_require__(11);var extend=__webpack_require__(3);var lib={attributes:{compose:function(a,b,keepNull){if(typeof a!=='object')a={};if(typeof b!=='object')b={};var attributes=extend(true,{},b);if(!keepNull){attributes=Object.keys(attributes).reduce(function(copy,key){if(attributes[key]!=null){copy[key]=attributes[key];}return copy;},{});}for(var key in a){if(a[key]!==undefined&&b[key]===undefined){attributes[key]=a[key];}}return Object.keys(attributes).length>0?attributes:undefined;},diff:function(a,b){if(typeof a!=='object')a={};if(typeof b!=='object')b={};var attributes=Object.keys(a).concat(Object.keys(b)).reduce(function(attributes,key){if(!equal(a[key],b[key])){attributes[key]=b[key]===undefined?null:b[key];}return attributes;},{});return Object.keys(attributes).length>0?attributes:undefined;},transform:function(a,b,priority){if(typeof a!=='object')return b;if(typeof b!=='object')return undefined;if(!priority)return b;var attributes=Object.keys(b).reduce(function(attributes,key){if(a[key]===undefined)attributes[key]=b[key];return attributes;},{});return Object.keys(attributes).length>0?attributes:undefined;}},iterator:function(ops){return new Iterator(ops);},length:function(op){if(typeof op['delete']==='number'){return op['delete'];}else if(typeof op.retain==='number'){return op.retain;}else{return typeof op.insert==='string'?op.insert.length:1;}}};function Iterator(ops){this.ops=ops;this.index=0;this.offset=0;}Iterator.prototype.hasNext=function(){return this.peekLength()<Infinity;};Iterator.prototype.next=function(length){if(!length)length=Infinity;var nextOp=this.ops[this.index];if(nextOp){var offset=this.offset;var opLength=lib.length(nextOp);if(length>=opLength-offset){length=opLength-offset;this.index+=1;this.offset=0;}else{this.offset+=length;}if(typeof nextOp['delete']==='number'){return {'delete':length};}else{var retOp={};if(nextOp.attributes){retOp.attributes=nextOp.attributes;}if(typeof nextOp.retain==='number'){retOp.retain=length;}else if(typeof nextOp.insert==='string'){retOp.insert=nextOp.insert.substr(offset,length);}else{retOp.insert=nextOp.insert;}return retOp;}}else{return {retain:Infinity};}};Iterator.prototype.peek=function(){return this.ops[this.index];};Iterator.prototype.peekLength=function(){if(this.ops[this.index]){return lib.length(this.ops[this.index])-this.offset;}else{return Infinity;}};Iterator.prototype.peekType=function(){if(this.ops[this.index]){if(typeof this.ops[this.index]['delete']==='number'){return 'delete';}else if(typeof this.ops[this.index].retain==='number'){return 'retain';}else{return 'insert';}}return 'retain';};module.exports=lib;},function(module,exports){var clone=function(){function _instanceof(obj,type){return type!=null&&obj instanceof type;}var nativeMap;try{nativeMap=Map;}catch(_){nativeMap=function(){};}var nativeSet;try{nativeSet=Set;}catch(_){nativeSet=function(){};}var nativePromise;try{nativePromise=Promise;}catch(_){nativePromise=function(){};}function clone(parent,circular,depth,prototype,includeNonEnumerable){if(typeof circular==='object'){depth=circular.depth;prototype=circular.prototype;includeNonEnumerable=circular.includeNonEnumerable;circular=circular.circular;}var allParents=[];var allChildren=[];var useBuffer=typeof Buffer!='undefined';if(typeof circular=='undefined')circular=true;if(typeof depth=='undefined')depth=Infinity;function _clone(parent,depth){if(parent===null)return null;if(depth===0)return parent;var child;var proto;if(typeof parent!='object'){return parent;}if(_instanceof(parent,nativeMap)){child=new nativeMap();}else if(_instanceof(parent,nativeSet)){child=new nativeSet();}else if(_instanceof(parent,nativePromise)){child=new nativePromise(function(resolve,reject){parent.then(function(value){resolve(_clone(value,depth-1));},function(err){reject(_clone(err,depth-1));});});}else if(clone.__isArray(parent)){child=[];}else if(clone.__isRegExp(parent)){child=new RegExp(parent.source,__getRegExpFlags(parent));if(parent.lastIndex)child.lastIndex=parent.lastIndex;}else if(clone.__isDate(parent)){child=new Date(parent.getTime());}else if(useBuffer&&Buffer.isBuffer(parent)){child=new Buffer(parent.length);parent.copy(child);return child;}else if(_instanceof(parent,Error)){child=Object.create(parent);}else{if(typeof prototype=='undefined'){proto=Object.getPrototypeOf(parent);child=Object.create(proto);}else{child=Object.create(prototype);proto=prototype;}}if(circular){var index=allParents.indexOf(parent);if(index!=-1){return allChildren[index];}allParents.push(parent);allChildren.push(child);}if(_instanceof(parent,nativeMap)){parent.forEach(function(value,key){var keyChild=_clone(key,depth-1);var valueChild=_clone(value,depth-1);child.set(keyChild,valueChild);});}if(_instanceof(parent,nativeSet)){parent.forEach(function(value){var entryChild=_clone(value,depth-1);child.add(entryChild);});}for(var i in parent){var attrs;if(proto){attrs=Object.getOwnPropertyDescriptor(proto,i);}if(attrs&&attrs.set==null){continue;}child[i]=_clone(parent[i],depth-1);}if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(parent);for(var i=0;i<symbols.length;i++){var symbol=symbols[i];var descriptor=Object.getOwnPropertyDescriptor(parent,symbol);if(descriptor&&!descriptor.enumerable&&!includeNonEnumerable){continue;}child[symbol]=_clone(parent[symbol],depth-1);if(!descriptor.enumerable){Object.defineProperty(child,symbol,{enumerable:false});}}}if(includeNonEnumerable){var allPropertyNames=Object.getOwnPropertyNames(parent);for(var i=0;i<allPropertyNames.length;i++){var propertyName=allPropertyNames[i];var descriptor=Object.getOwnPropertyDescriptor(parent,propertyName);if(descriptor&&descriptor.enumerable){continue;}child[propertyName]=_clone(parent[propertyName],depth-1);Object.defineProperty(child,propertyName,{enumerable:false});}}return child;}return _clone(parent,depth);}clone.clonePrototype=function clonePrototype(parent){if(parent===null)return null;var c=function(){};c.prototype=parent;return new c();};function __objToStr(o){return Object.prototype.toString.call(o);}clone.__objToStr=__objToStr;function __isDate(o){return typeof o==='object'&&__objToStr(o)==='[object Date]';}clone.__isDate=__isDate;function __isArray(o){return typeof o==='object'&&__objToStr(o)==='[object Array]';}clone.__isArray=__isArray;function __isRegExp(o){return typeof o==='object'&&__objToStr(o)==='[object RegExp]';}clone.__isRegExp=__isRegExp;function __getRegExpFlags(re){var flags='';if(re.global)flags+='g';if(re.ignoreCase)flags+='i';if(re.multiline)flags+='m';return flags;}clone.__getRegExpFlags=__getRegExpFlags;return clone;}();if(typeof module==='object'&&module.exports){module.exports=clone;}},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _container=__webpack_require__(24);var _container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}function isLine(blot){return blot instanceof _block2.default||blot instanceof _block.BlockEmbed;}var Scroll=function(_Parchment$Scroll){_inherits(Scroll,_Parchment$Scroll);function Scroll(domNode,config){_classCallCheck(this,Scroll);var _this=_possibleConstructorReturn(this,(Scroll.__proto__||Object.getPrototypeOf(Scroll)).call(this,domNode));_this.emitter=config.emitter;_this.IMEMode=false;if(Array.isArray(config.whitelist)){_this.whitelist=config.whitelist.reduce(function(whitelist,format){whitelist[format]=true;return whitelist;},{});}_this.domNode.addEventListener('compositionstart',function(){if(!_this.IMEMode){_this.domNode.addEventListener('DOMNodeInserted',function(){});_this.IMEMode=true;}});_this.optimize();_this.enable();return _this;}_createClass(Scroll,[{key:'batchStart',value:function batchStart(){this.batch=true;}},{key:'batchEnd',value:function batchEnd(){this.batch=false;this.optimize();}},{key:'deleteAt',value:function deleteAt(index,length){var _line=this.line(index),_line2=_slicedToArray(_line,2),first=_line2[0],offset=_line2[1];var _line3=this.line(index+length),_line4=_slicedToArray(_line3,1),last=_line4[0];_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'deleteAt',this).call(this,index,length);if(last!=null&&first!==last&&offset>0){if(first instanceof _block.BlockEmbed||last instanceof _block.BlockEmbed){this.optimize();return;}if(first instanceof _code2.default){var newlineIndex=first.newlineIndex(first.length(),true);if(newlineIndex>-1){first=first.split(newlineIndex+1);if(first===last){this.optimize();return;}}}else if(last instanceof _code2.default){var _newlineIndex=last.newlineIndex(0);if(_newlineIndex>-1){last.split(_newlineIndex+1);}}var ref=last.children.head instanceof _break2.default?null:last.children.head;first.moveChildren(last,ref);first.remove();}this.optimize();}},{key:'enable',value:function enable(){var enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.domNode.setAttribute('contenteditable',enabled);}},{key:'formatAt',value:function formatAt(index,length,format,value){if(this.whitelist!=null&&!this.whitelist[format])return;_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'formatAt',this).call(this,index,length,format,value);this.optimize();}},{key:'insertAt',value:function insertAt(index,value,def){if(def!=null&&this.whitelist!=null&&!this.whitelist[value])return;if(index>=this.length()){if(def==null||_parchment2.default.query(value,_parchment2.default.Scope.BLOCK)==null){var blot=_parchment2.default.create(this.statics.defaultChild);this.appendChild(blot);if(def==null&&value.endsWith('\n')){value=value.slice(0,-1);}blot.insertAt(0,value,def);}else{var embed=_parchment2.default.create(value,def);this.appendChild(embed);}}else{_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'insertAt',this).call(this,index,value,def);}this.optimize();}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot.statics.scope===_parchment2.default.Scope.INLINE_BLOT){var wrapper=_parchment2.default.create(this.statics.defaultChild);wrapper.appendChild(blot);blot=wrapper;}_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'insertBefore',this).call(this,blot,ref);}},{key:'leaf',value:function leaf(index){return this.path(index).pop()||[null,-1];}},{key:'line',value:function line(index){if(index===this.length()){return this.line(index-1);}return this.descendant(isLine,index);}},{key:'lines',value:function lines(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Number.MAX_VALUE;var getLines=function getLines(blot,index,length){var lines=[],lengthLeft=length;blot.children.forEachAt(index,length,function(child,index,length){if(isLine(child)){lines.push(child);}else if(child instanceof _parchment2.default.Container){lines=lines.concat(getLines(child,index,lengthLeft));}lengthLeft-=length;});return lines;};return getLines(this,index,length);}},{key:'optimize',value:function optimize(){var mutations=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this.batch===true)return;_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'optimize',this).call(this,mutations,context);if(mutations.length>0){this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE,mutations,context);}}},{key:'path',value:function path(index){return _get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'path',this).call(this,index).slice(1);}},{key:'update',value:function update(mutations){if(this.batch===true)return;var source=_emitter2.default.sources.USER;if(typeof mutations==='string'){source=mutations;}if(!Array.isArray(mutations)){mutations=this.observer.takeRecords();}if(mutations.length>0){this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE,source,mutations);}_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'update',this).call(this,mutations.concat([]));if(mutations.length>0){this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE,source,mutations);}}}]);return Scroll;}(_parchment2.default.Scroll);Scroll.blotName='scroll';Scroll.className='ql-editor';Scroll.tagName='DIV';Scroll.defaultChild='block';Scroll.allowedChildren=[_block2.default,_block.BlockEmbed,_container2.default];exports.default=Scroll;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Cursor=function(_Parchment$Embed){_inherits(Cursor,_Parchment$Embed);_createClass(Cursor,null,[{key:'value',value:function value(){return undefined;}}]);function Cursor(domNode,selection){_classCallCheck(this,Cursor);var _this=_possibleConstructorReturn(this,(Cursor.__proto__||Object.getPrototypeOf(Cursor)).call(this,domNode));_this.selection=selection;_this.textNode=document.createTextNode(Cursor.CONTENTS);_this.domNode.appendChild(_this.textNode);_this._length=0;return _this;}_createClass(Cursor,[{key:'detach',value:function detach(){if(this.parent!=null)this.parent.removeChild(this);}},{key:'format',value:function format(name,value){if(this._length!==0){return _get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),'format',this).call(this,name,value);}var target=this,index=0;while(target!=null&&target.statics.scope!==_parchment2.default.Scope.BLOCK_BLOT){index+=target.offset(target.parent);target=target.parent;}if(target!=null){this._length=Cursor.CONTENTS.length;target.optimize();target.formatAt(index,Cursor.CONTENTS.length,name,value);this._length=0;}}},{key:'index',value:function index(node,offset){if(node===this.textNode)return 0;return _get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),'index',this).call(this,node,offset);}},{key:'length',value:function length(){return this._length;}},{key:'position',value:function position(){return [this.textNode,this.textNode.data.length];}},{key:'remove',value:function remove(){_get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),'remove',this).call(this);this.parent=null;}},{key:'restore',value:function restore(){if(this.selection.composing||this.parent==null)return;var textNode=this.textNode;var range=this.selection.getNativeRange();var restoreText=void 0,start=void 0,end=void 0;if(range!=null&&range.start.node===textNode&&range.end.node===textNode){var _ref=[textNode,range.start.offset,range.end.offset];restoreText=_ref[0];start=_ref[1];end=_ref[2];}while(this.domNode.lastChild!=null&&this.domNode.lastChild!==this.textNode){this.domNode.parentNode.insertBefore(this.domNode.lastChild,this.domNode);}if(this.textNode.data!==Cursor.CONTENTS){var text=this.textNode.data.split(Cursor.CONTENTS).join('');if(this.next instanceof _text2.default){restoreText=this.next.domNode;this.next.insertAt(0,text);this.textNode.data=Cursor.CONTENTS;}else{this.textNode.data=text;this.parent.insertBefore(_parchment2.default.create(this.textNode),this);this.textNode=document.createTextNode(Cursor.CONTENTS);this.domNode.appendChild(this.textNode);}}this.remove();if(start!=null){var _map=[start,end].map(function(offset){return Math.max(0,Math.min(restoreText.data.length,offset-1));});var _map2=_slicedToArray(_map,2);start=_map2[0];end=_map2[1];return {startNode:restoreText,startOffset:start,endNode:restoreText,endOffset:end};}}},{key:'update',value:function update(mutations,context){var _this2=this;if(mutations.some(function(mutation){return mutation.type==='characterData'&&mutation.target===_this2.textNode;})){var range=this.restore();if(range)context.range=range;}}},{key:'value',value:function value(){return '';}}]);return Cursor;}(_parchment2.default.Embed);Cursor.blotName='cursor';Cursor.className='ql-cursor';Cursor.tagName='span';Cursor.CONTENTS='\uFEFF';exports.default=Cursor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Container=function(_Parchment$Container){_inherits(Container,_Parchment$Container);function Container(){_classCallCheck(this,Container);return _possibleConstructorReturn(this,(Container.__proto__||Object.getPrototypeOf(Container)).apply(this,arguments));}return Container;}(_parchment2.default.Container);Container.allowedChildren=[_block2.default,_block.BlockEmbed,Container];exports.default=Container;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var GUARD_TEXT='\uFEFF';var Embed=function(_Parchment$Embed){_inherits(Embed,_Parchment$Embed);function Embed(node){_classCallCheck(this,Embed);var _this=_possibleConstructorReturn(this,(Embed.__proto__||Object.getPrototypeOf(Embed)).call(this,node));_this.contentNode=document.createElement('span');_this.contentNode.setAttribute('contenteditable',false);[].slice.call(_this.domNode.childNodes).forEach(function(childNode){_this.contentNode.appendChild(childNode);});_this.leftGuard=document.createTextNode(GUARD_TEXT);_this.rightGuard=document.createTextNode(GUARD_TEXT);_this.domNode.appendChild(_this.leftGuard);_this.domNode.appendChild(_this.contentNode);_this.domNode.appendChild(_this.rightGuard);return _this;}_createClass(Embed,[{key:'index',value:function index(node,offset){if(node===this.leftGuard)return 0;if(node===this.rightGuard)return 1;return _get(Embed.prototype.__proto__||Object.getPrototypeOf(Embed.prototype),'index',this).call(this,node,offset);}},{key:'restore',value:function restore(node){var range=void 0,textNode=void 0;var text=node.data.split(GUARD_TEXT).join('');if(node===this.leftGuard){if(this.prev instanceof _text2.default){var prevLength=this.prev.length();this.prev.insertAt(prevLength,text);range={startNode:this.prev.domNode,startOffset:prevLength+text.length};}else{textNode=document.createTextNode(text);this.parent.insertBefore(_parchment2.default.create(textNode),this);range={startNode:textNode,startOffset:text.length};}}else if(node===this.rightGuard){if(this.next instanceof _text2.default){this.next.insertAt(0,text);range={startNode:this.next.domNode,startOffset:text.length};}else{textNode=document.createTextNode(text);this.parent.insertBefore(_parchment2.default.create(textNode),this.next);range={startNode:textNode,startOffset:text.length};}}node.data=GUARD_TEXT;return range;}},{key:'update',value:function update(mutations,context){var _this2=this;mutations.forEach(function(mutation){if(mutation.type==='characterData'&&(mutation.target===_this2.leftGuard||mutation.target===_this2.rightGuard)){var range=_this2.restore(mutation.target);if(range)context.range=range;}});}}]);return Embed;}(_parchment2.default.Embed);exports.default=Embed;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.ColorStyle=exports.ColorClass=exports.ColorAttributor=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ColorAttributor=function(_Parchment$Attributor){_inherits(ColorAttributor,_Parchment$Attributor);function ColorAttributor(){_classCallCheck(this,ColorAttributor);return _possibleConstructorReturn(this,(ColorAttributor.__proto__||Object.getPrototypeOf(ColorAttributor)).apply(this,arguments));}_createClass(ColorAttributor,[{key:'value',value:function value(domNode){var value=_get(ColorAttributor.prototype.__proto__||Object.getPrototypeOf(ColorAttributor.prototype),'value',this).call(this,domNode);if(!value.startsWith('rgb('))return value;value=value.replace(/^[^\d]+/,'').replace(/[^\d]+$/,'');return '#'+value.split(',').map(function(component){return ('00'+parseInt(component).toString(16)).slice(-2);}).join('');}}]);return ColorAttributor;}(_parchment2.default.Attributor.Style);var ColorClass=new _parchment2.default.Attributor.Class('color','ql-color',{scope:_parchment2.default.Scope.INLINE});var ColorStyle=new ColorAttributor('color','color',{scope:_parchment2.default.Scope.INLINE});exports.ColorAttributor=ColorAttributor;exports.ColorClass=ColorClass;exports.ColorStyle=ColorStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.sanitize=exports.default=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Link=function(_Inline){_inherits(Link,_Inline);function Link(){_classCallCheck(this,Link);return _possibleConstructorReturn(this,(Link.__proto__||Object.getPrototypeOf(Link)).apply(this,arguments));}_createClass(Link,[{key:'format',value:function format(name,value){if(name!==this.statics.blotName||!value)return _get(Link.prototype.__proto__||Object.getPrototypeOf(Link.prototype),'format',this).call(this,name,value);value=this.constructor.sanitize(value);this.domNode.setAttribute('href',value);}}],[{key:'create',value:function create(value){var node=_get(Link.__proto__||Object.getPrototypeOf(Link),'create',this).call(this,value);value=this.sanitize(value);node.setAttribute('href',value);node.setAttribute('target','_blank');return node;}},{key:'formats',value:function formats(domNode){return domNode.getAttribute('href');}},{key:'sanitize',value:function sanitize(url){return _sanitize(url,this.PROTOCOL_WHITELIST)?url:this.SANITIZED_URL;}}]);return Link;}(_inline2.default);Link.blotName='link';Link.tagName='A';Link.SANITIZED_URL='about:blank';Link.PROTOCOL_WHITELIST=['http','https','mailto','tel'];function _sanitize(url,protocols){var anchor=document.createElement('a');anchor.href=url;var protocol=anchor.href.slice(0,anchor.href.indexOf(':'));return protocols.indexOf(protocol)>-1;}exports.default=Link;exports.sanitize=_sanitize;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dropdown=__webpack_require__(107);var _dropdown2=_interopRequireDefault(_dropdown);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Picker=function(){function Picker(select){var _this=this;_classCallCheck(this,Picker);this.select=select;this.container=document.createElement('span');this.buildPicker();this.select.style.display='none';this.select.parentNode.insertBefore(this.container,this.select);this.label.addEventListener('mousedown',function(){_this.container.classList.toggle('ql-expanded');});this.select.addEventListener('change',this.update.bind(this));}_createClass(Picker,[{key:'buildItem',value:function buildItem(option){var _this2=this;var item=document.createElement('span');item.classList.add('ql-picker-item');if(option.hasAttribute('value')){item.setAttribute('data-value',option.getAttribute('value'));}if(option.textContent){item.setAttribute('data-label',option.textContent);}item.addEventListener('click',function(){_this2.selectItem(item,true);});return item;}},{key:'buildLabel',value:function buildLabel(){var label=document.createElement('span');label.classList.add('ql-picker-label');label.innerHTML=_dropdown2.default;this.container.appendChild(label);return label;}},{key:'buildOptions',value:function buildOptions(){var _this3=this;var options=document.createElement('span');options.classList.add('ql-picker-options');[].slice.call(this.select.options).forEach(function(option){var item=_this3.buildItem(option);options.appendChild(item);if(option.selected===true){_this3.selectItem(item);}});this.container.appendChild(options);}},{key:'buildPicker',value:function buildPicker(){var _this4=this;[].slice.call(this.select.attributes).forEach(function(item){_this4.container.setAttribute(item.name,item.value);});this.container.classList.add('ql-picker');this.label=this.buildLabel();this.buildOptions();}},{key:'close',value:function close(){this.container.classList.remove('ql-expanded');}},{key:'selectItem',value:function selectItem(item){var trigger=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var selected=this.container.querySelector('.ql-selected');if(item===selected)return;if(selected!=null){selected.classList.remove('ql-selected');}if(item==null)return;item.classList.add('ql-selected');this.select.selectedIndex=[].indexOf.call(item.parentNode.children,item);if(item.hasAttribute('data-value')){this.label.setAttribute('data-value',item.getAttribute('data-value'));}else{this.label.removeAttribute('data-value');}if(item.hasAttribute('data-label')){this.label.setAttribute('data-label',item.getAttribute('data-label'));}else{this.label.removeAttribute('data-label');}if(trigger){if(typeof Event==='function'){this.select.dispatchEvent(new Event('change'));}else if((typeof Event==='undefined'?'undefined':_typeof(Event))==='object'){var event=document.createEvent('Event');event.initEvent('change',true,true);this.select.dispatchEvent(event);}this.close();}}},{key:'update',value:function update(){var option=void 0;if(this.select.selectedIndex>-1){var item=this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];option=this.select.options[this.select.selectedIndex];this.selectItem(item);}else{this.selectItem(null);}var isActive=option!=null&&option!==this.select.querySelector('option[selected]');this.label.classList.toggle('ql-active',isActive);}}]);return Picker;}();exports.default=Picker;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _container=__webpack_require__(24);var _container2=_interopRequireDefault(_container);var _cursor=__webpack_require__(23);var _cursor2=_interopRequireDefault(_cursor);var _embed=__webpack_require__(25);var _embed2=_interopRequireDefault(_embed);var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);var _scroll=__webpack_require__(22);var _scroll2=_interopRequireDefault(_scroll);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);var _clipboard=__webpack_require__(55);var _clipboard2=_interopRequireDefault(_clipboard);var _history=__webpack_require__(42);var _history2=_interopRequireDefault(_history);var _keyboard=__webpack_require__(35);var _keyboard2=_interopRequireDefault(_keyboard);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}_quill2.default.register({'blots/block':_block2.default,'blots/block/embed':_block.BlockEmbed,'blots/break':_break2.default,'blots/container':_container2.default,'blots/cursor':_cursor2.default,'blots/embed':_embed2.default,'blots/inline':_inline2.default,'blots/scroll':_scroll2.default,'blots/text':_text2.default,'modules/clipboard':_clipboard2.default,'modules/history':_history2.default,'modules/keyboard':_keyboard2.default});_parchment2.default.register(_block2.default,_break2.default,_cursor2.default,_inline2.default,_scroll2.default,_text2.default);exports.default=_quill2.default;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var Registry=__webpack_require__(1);var ShadowBlot=function(){function ShadowBlot(domNode){this.domNode=domNode;this.domNode[Registry.DATA_KEY]={blot:this};}Object.defineProperty(ShadowBlot.prototype,"statics",{get:function(){return this.constructor;},enumerable:true,configurable:true});ShadowBlot.create=function(value){if(this.tagName==null){throw new Registry.ParchmentError('Blot definition missing tagName');}var node;if(Array.isArray(this.tagName)){if(typeof value==='string'){value=value.toUpperCase();if(parseInt(value).toString()===value){value=parseInt(value);}}if(typeof value==='number'){node=document.createElement(this.tagName[value-1]);}else if(this.tagName.indexOf(value)>-1){node=document.createElement(value);}else{node=document.createElement(this.tagName[0]);}}else{node=document.createElement(this.tagName);}if(this.className){node.classList.add(this.className);}return node;};ShadowBlot.prototype.attach=function(){if(this.parent!=null){this.scroll=this.parent.scroll;}};ShadowBlot.prototype.clone=function(){var domNode=this.domNode.cloneNode(false);return Registry.create(domNode);};ShadowBlot.prototype.detach=function(){if(this.parent!=null)this.parent.removeChild(this);delete this.domNode[Registry.DATA_KEY];};ShadowBlot.prototype.deleteAt=function(index,length){var blot=this.isolate(index,length);blot.remove();};ShadowBlot.prototype.formatAt=function(index,length,name,value){var blot=this.isolate(index,length);if(Registry.query(name,Registry.Scope.BLOT)!=null&&value){blot.wrap(name,value);}else if(Registry.query(name,Registry.Scope.ATTRIBUTE)!=null){var parent=Registry.create(this.statics.scope);blot.wrap(parent);parent.format(name,value);}};ShadowBlot.prototype.insertAt=function(index,value,def){var blot=def==null?Registry.create('text',value):Registry.create(value,def);var ref=this.split(index);this.parent.insertBefore(blot,ref);};ShadowBlot.prototype.insertInto=function(parentBlot,refBlot){if(this.parent!=null){this.parent.children.remove(this);}parentBlot.children.insertBefore(this,refBlot);if(refBlot!=null){var refDomNode=refBlot.domNode;}if(this.next==null||this.domNode.nextSibling!=refDomNode){parentBlot.domNode.insertBefore(this.domNode,typeof refDomNode!=='undefined'?refDomNode:null);}this.parent=parentBlot;this.attach();};ShadowBlot.prototype.isolate=function(index,length){var target=this.split(index);target.split(length);return target;};ShadowBlot.prototype.length=function(){return 1;};ShadowBlot.prototype.offset=function(root){if(root===void 0){root=this.parent;}if(this.parent==null||this==root)return 0;return this.parent.children.offset(this)+this.parent.offset(root);};ShadowBlot.prototype.optimize=function(context){if(this.domNode[Registry.DATA_KEY]!=null){delete this.domNode[Registry.DATA_KEY].mutations;}};ShadowBlot.prototype.remove=function(){if(this.domNode.parentNode!=null){this.domNode.parentNode.removeChild(this.domNode);}this.detach();};ShadowBlot.prototype.replace=function(target){if(target.parent==null)return;target.parent.insertBefore(this,target.next);target.remove();};ShadowBlot.prototype.replaceWith=function(name,value){var replacement=typeof name==='string'?Registry.create(name,value):name;replacement.replace(this);return replacement;};ShadowBlot.prototype.split=function(index,force){return index===0?this:this.next;};ShadowBlot.prototype.update=function(mutations,context){};ShadowBlot.prototype.wrap=function(name,value){var wrapper=typeof name==='string'?Registry.create(name,value):name;if(this.parent!=null){this.parent.insertBefore(wrapper,this.next);}wrapper.appendChild(this);return wrapper;};ShadowBlot.blotName='abstract';return ShadowBlot;}();exports.default=ShadowBlot;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);var class_1=__webpack_require__(32);var style_1=__webpack_require__(33);var Registry=__webpack_require__(1);var AttributorStore=function(){function AttributorStore(domNode){this.attributes={};this.domNode=domNode;this.build();}AttributorStore.prototype.attribute=function(attribute,value){if(value){if(attribute.add(this.domNode,value)){if(attribute.value(this.domNode)!=null){this.attributes[attribute.attrName]=attribute;}else{delete this.attributes[attribute.attrName];}}}else{attribute.remove(this.domNode);delete this.attributes[attribute.attrName];}};AttributorStore.prototype.build=function(){var _this=this;this.attributes={};var attributes=attributor_1.default.keys(this.domNode);var classes=class_1.default.keys(this.domNode);var styles=style_1.default.keys(this.domNode);attributes.concat(classes).concat(styles).forEach(function(name){var attr=Registry.query(name,Registry.Scope.ATTRIBUTE);if(attr instanceof attributor_1.default){_this.attributes[attr.attrName]=attr;}});};AttributorStore.prototype.copy=function(target){var _this=this;Object.keys(this.attributes).forEach(function(key){var value=_this.attributes[key].value(_this.domNode);target.format(key,value);});};AttributorStore.prototype.move=function(target){var _this=this;this.copy(target);Object.keys(this.attributes).forEach(function(key){_this.attributes[key].remove(_this.domNode);});this.attributes={};};AttributorStore.prototype.values=function(){var _this=this;return Object.keys(this.attributes).reduce(function(attributes,name){attributes[name]=_this.attributes[name].value(_this.domNode);return attributes;},{});};return AttributorStore;}();exports.default=AttributorStore;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);function match(node,prefix){var className=node.getAttribute('class')||'';return className.split(/\s+/).filter(function(name){return name.indexOf(prefix+"-")===0;});}var ClassAttributor=function(_super){__extends(ClassAttributor,_super);function ClassAttributor(){return _super!==null&&_super.apply(this,arguments)||this;}ClassAttributor.keys=function(node){return (node.getAttribute('class')||'').split(/\s+/).map(function(name){return name.split('-').slice(0,-1).join('-');});};ClassAttributor.prototype.add=function(node,value){if(!this.canAdd(node,value))return false;this.remove(node);node.classList.add(this.keyName+"-"+value);return true;};ClassAttributor.prototype.remove=function(node){var matches=match(node,this.keyName);matches.forEach(function(name){node.classList.remove(name);});if(node.classList.length===0){node.removeAttribute('class');}};ClassAttributor.prototype.value=function(node){var result=match(node,this.keyName)[0]||'';var value=result.slice(this.keyName.length+1);return this.canAdd(node,value)?value:'';};return ClassAttributor;}(attributor_1.default);exports.default=ClassAttributor;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);function camelize(name){var parts=name.split('-');var rest=parts.slice(1).map(function(part){return part[0].toUpperCase()+part.slice(1);}).join('');return parts[0]+rest;}var StyleAttributor=function(_super){__extends(StyleAttributor,_super);function StyleAttributor(){return _super!==null&&_super.apply(this,arguments)||this;}StyleAttributor.keys=function(node){return (node.getAttribute('style')||'').split(';').map(function(value){var arr=value.split(':');return arr[0].trim();});};StyleAttributor.prototype.add=function(node,value){if(!this.canAdd(node,value))return false;node.style[camelize(this.keyName)]=value;return true;};StyleAttributor.prototype.remove=function(node){node.style[camelize(this.keyName)]='';if(!node.getAttribute('style')){node.removeAttribute('style');}};StyleAttributor.prototype.value=function(node){var value=node.style[camelize(this.keyName)];return this.canAdd(node,value)?value:'';};return StyleAttributor;}(attributor_1.default);exports.default=StyleAttributor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Theme=function(){function Theme(quill,options){_classCallCheck(this,Theme);this.quill=quill;this.options=options;this.modules={};}_createClass(Theme,[{key:'init',value:function init(){var _this=this;Object.keys(this.options.modules).forEach(function(name){if(_this.modules[name]==null){_this.addModule(name);}});}},{key:'addModule',value:function addModule(name){var moduleClass=this.quill.constructor.import('modules/'+name);this.modules[name]=new moduleClass(this.quill,this.options.modules[name]||{});return this.modules[name];}}]);return Theme;}();Theme.DEFAULTS={modules:{}};Theme.themes={'default':Theme};exports.default=Theme;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.SHORTKEY=exports.default=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _clone=__webpack_require__(21);var _clone2=_interopRequireDefault(_clone);var _deepEqual=__webpack_require__(11);var _deepEqual2=_interopRequireDefault(_deepEqual);var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _op=__webpack_require__(20);var _op2=_interopRequireDefault(_op);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _embed=__webpack_require__(25);var _embed2=_interopRequireDefault(_embed);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:keyboard');var SHORTKEY=/Mac/i.test(navigator.platform)?'metaKey':'ctrlKey';var Keyboard=function(_Module){_inherits(Keyboard,_Module);_createClass(Keyboard,null,[{key:'match',value:function match(evt,binding){binding=normalize(binding);if(['altKey','ctrlKey','metaKey','shiftKey'].some(function(key){return !!binding[key]!==evt[key]&&binding[key]!==null;})){return false;}return binding.key===(evt.which||evt.keyCode);}}]);function Keyboard(quill,options){_classCallCheck(this,Keyboard);var _this=_possibleConstructorReturn(this,(Keyboard.__proto__||Object.getPrototypeOf(Keyboard)).call(this,quill,options));_this.bindings={};Object.keys(_this.options.bindings).forEach(function(name){if(name==='list autofill'&&quill.scroll.whitelist!=null&&!quill.scroll.whitelist['list']){return;}if(_this.options.bindings[name]){_this.addBinding(_this.options.bindings[name]);}});_this.addBinding({key:Keyboard.keys.ENTER,shiftKey:null},handleEnter);_this.addBinding({key:Keyboard.keys.ENTER,metaKey:null,ctrlKey:null,altKey:null},function(){});if(/Firefox/i.test(navigator.userAgent)){_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:true},handleBackspace);_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:true},handleDelete);}else{_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:true,prefix:/^.?$/},handleBackspace);_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:true,suffix:/^.?$/},handleDelete);}_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:false},handleDeleteRange);_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:false},handleDeleteRange);_this.addBinding({key:Keyboard.keys.BACKSPACE,altKey:null,ctrlKey:null,metaKey:null,shiftKey:null},{collapsed:true,offset:0},handleBackspace);_this.listen();return _this;}_createClass(Keyboard,[{key:'addBinding',value:function addBinding(key){var context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var handler=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var binding=normalize(key);if(binding==null||binding.key==null){return debug.warn('Attempted to add invalid keyboard binding',binding);}if(typeof context==='function'){context={handler:context};}if(typeof handler==='function'){handler={handler:handler};}binding=_extend2.default(binding,context,handler);this.bindings[binding.key]=this.bindings[binding.key]||[];this.bindings[binding.key].push(binding);}},{key:'listen',value:function listen(){var _this2=this;this.quill.root.addEventListener('keydown',function(evt){if(evt.defaultPrevented)return;var which=evt.which||evt.keyCode;var bindings=(_this2.bindings[which]||[]).filter(function(binding){return Keyboard.match(evt,binding);});if(bindings.length===0)return;var range=_this2.quill.getSelection();if(range==null||!_this2.quill.hasFocus())return;var _quill$getLine=_this2.quill.getLine(range.index),_quill$getLine2=_slicedToArray(_quill$getLine,2),line=_quill$getLine2[0],offset=_quill$getLine2[1];var _quill$getLeaf=_this2.quill.getLeaf(range.index),_quill$getLeaf2=_slicedToArray(_quill$getLeaf,2),leafStart=_quill$getLeaf2[0],offsetStart=_quill$getLeaf2[1];var _ref=range.length===0?[leafStart,offsetStart]:_this2.quill.getLeaf(range.index+range.length),_ref2=_slicedToArray(_ref,2),leafEnd=_ref2[0],offsetEnd=_ref2[1];var prefixText=leafStart instanceof _parchment2.default.Text?leafStart.value().slice(0,offsetStart):'';var suffixText=leafEnd instanceof _parchment2.default.Text?leafEnd.value().slice(offsetEnd):'';var curContext={collapsed:range.length===0,empty:range.length===0&&line.length()<=1,format:_this2.quill.getFormat(range),offset:offset,prefix:prefixText,suffix:suffixText};var prevented=bindings.some(function(binding){if(binding.collapsed!=null&&binding.collapsed!==curContext.collapsed)return false;if(binding.empty!=null&&binding.empty!==curContext.empty)return false;if(binding.offset!=null&&binding.offset!==curContext.offset)return false;if(Array.isArray(binding.format)){if(binding.format.every(function(name){return curContext.format[name]==null;})){return false;}}else if(_typeof(binding.format)==='object'){if(!Object.keys(binding.format).every(function(name){if(binding.format[name]===true)return curContext.format[name]!=null;if(binding.format[name]===false)return curContext.format[name]==null;return _deepEqual2.default(binding.format[name],curContext.format[name]);})){return false;}}if(binding.prefix!=null&&!binding.prefix.test(curContext.prefix))return false;if(binding.suffix!=null&&!binding.suffix.test(curContext.suffix))return false;return binding.handler.call(_this2,range,curContext)!==true;});if(prevented){evt.preventDefault();}});}}]);return Keyboard;}(_module2.default);Keyboard.keys={BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46};Keyboard.DEFAULTS={bindings:{'bold':makeFormatHandler('bold'),'italic':makeFormatHandler('italic'),'underline':makeFormatHandler('underline'),'indent':{key:Keyboard.keys.TAB,format:['blockquote','indent','list'],handler:function handler(range,context){if(context.collapsed&&context.offset!==0)return true;this.quill.format('indent','+1',_quill2.default.sources.USER);}},'outdent':{key:Keyboard.keys.TAB,shiftKey:true,format:['blockquote','indent','list'],handler:function handler(range,context){if(context.collapsed&&context.offset!==0)return true;this.quill.format('indent','-1',_quill2.default.sources.USER);}},'outdent backspace':{key:Keyboard.keys.BACKSPACE,collapsed:true,shiftKey:null,metaKey:null,ctrlKey:null,altKey:null,format:['indent','list'],offset:0,handler:function handler(range,context){if(context.format.indent!=null){this.quill.format('indent','-1',_quill2.default.sources.USER);}else if(context.format.list!=null){this.quill.format('list',false,_quill2.default.sources.USER);}}},'indent code-block':makeCodeBlockHandler(true),'outdent code-block':makeCodeBlockHandler(false),'remove tab':{key:Keyboard.keys.TAB,shiftKey:true,collapsed:true,prefix:/\t$/,handler:function handler(range){this.quill.deleteText(range.index-1,1,_quill2.default.sources.USER);}},'tab':{key:Keyboard.keys.TAB,handler:function handler(range){this.quill.history.cutoff();var delta=new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.history.cutoff();this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);}},'list empty enter':{key:Keyboard.keys.ENTER,collapsed:true,format:['list'],empty:true,handler:function handler(range,context){this.quill.format('list',false,_quill2.default.sources.USER);if(context.format.indent){this.quill.format('indent',false,_quill2.default.sources.USER);}}},'checklist enter':{key:Keyboard.keys.ENTER,collapsed:true,format:{list:'checked'},handler:function handler(range){var _quill$getLine3=this.quill.getLine(range.index),_quill$getLine4=_slicedToArray(_quill$getLine3,2),line=_quill$getLine4[0],offset=_quill$getLine4[1];var delta=new _quillDelta2.default().retain(range.index).insert('\n',{list:'checked'}).retain(line.length()-offset-1).retain(1,{list:'unchecked'});this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);this.quill.scrollIntoView();}},'header enter':{key:Keyboard.keys.ENTER,collapsed:true,format:['header'],suffix:/^$/,handler:function handler(range,context){var _quill$getLine5=this.quill.getLine(range.index),_quill$getLine6=_slicedToArray(_quill$getLine5,2),line=_quill$getLine6[0],offset=_quill$getLine6[1];var delta=new _quillDelta2.default().retain(range.index).insert('\n',context.format).retain(line.length()-offset-1).retain(1,{header:null});this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);this.quill.scrollIntoView();}},'list autofill':{key:' ',collapsed:true,format:{list:false},prefix:/^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,handler:function handler(range,context){var length=context.prefix.length;var _quill$getLine7=this.quill.getLine(range.index),_quill$getLine8=_slicedToArray(_quill$getLine7,2),line=_quill$getLine8[0],offset=_quill$getLine8[1];if(offset>length)return true;var value=void 0;switch(context.prefix.trim()){case'[]':case'[ ]':value='unchecked';break;case'[x]':value='checked';break;case'-':case'*':value='bullet';break;default:value='ordered';}this.quill.insertText(range.index,' ',_quill2.default.sources.USER);this.quill.history.cutoff();var delta=new _quillDelta2.default().retain(range.index-offset).delete(length+1).retain(line.length()-2-offset).retain(1,{list:value});this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.history.cutoff();this.quill.setSelection(range.index-length,_quill2.default.sources.SILENT);}},'code exit':{key:Keyboard.keys.ENTER,collapsed:true,format:['code-block'],prefix:/\n\n$/,suffix:/^\s+$/,handler:function handler(range){var _quill$getLine9=this.quill.getLine(range.index),_quill$getLine10=_slicedToArray(_quill$getLine9,2),line=_quill$getLine10[0],offset=_quill$getLine10[1];var delta=new _quillDelta2.default().retain(range.index+line.length()-offset-2).retain(1,{'code-block':null}).delete(1);this.quill.updateContents(delta,_quill2.default.sources.USER);}},'embed left':makeEmbedArrowHandler(Keyboard.keys.LEFT,false),'embed left shift':makeEmbedArrowHandler(Keyboard.keys.LEFT,true),'embed right':makeEmbedArrowHandler(Keyboard.keys.RIGHT,false),'embed right shift':makeEmbedArrowHandler(Keyboard.keys.RIGHT,true)}};function makeEmbedArrowHandler(key,shiftKey){var _ref3;var where=key===Keyboard.keys.LEFT?'prefix':'suffix';return _ref3={key:key,shiftKey:shiftKey},_defineProperty(_ref3,where,/^$/),_defineProperty(_ref3,'handler',function handler(range){var index=range.index;if(key===Keyboard.keys.RIGHT){index+=range.length+1;}var _quill$getLeaf3=this.quill.getLeaf(index),_quill$getLeaf4=_slicedToArray(_quill$getLeaf3,1),leaf=_quill$getLeaf4[0];if(!(leaf instanceof _embed2.default))return true;if(key===Keyboard.keys.LEFT){if(shiftKey){this.quill.setSelection(range.index-1,range.length+1,_quill2.default.sources.USER);}else{this.quill.setSelection(range.index-1,_quill2.default.sources.USER);}}else{if(shiftKey){this.quill.setSelection(range.index,range.length+1,_quill2.default.sources.USER);}else{this.quill.setSelection(range.index+range.length+1,_quill2.default.sources.USER);}}return false;}),_ref3;}function handleBackspace(range,context){if(range.index===0||this.quill.getLength()<=1)return;var _quill$getLine11=this.quill.getLine(range.index),_quill$getLine12=_slicedToArray(_quill$getLine11,1),line=_quill$getLine12[0];var formats={};if(context.offset===0){var _quill$getLine13=this.quill.getLine(range.index-1),_quill$getLine14=_slicedToArray(_quill$getLine13,1),prev=_quill$getLine14[0];if(prev!=null&&prev.length()>1){var curFormats=line.formats();var prevFormats=this.quill.getFormat(range.index-1,1);formats=_op2.default.attributes.diff(curFormats,prevFormats)||{};}}var length=/[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix)?2:1;this.quill.deleteText(range.index-length,length,_quill2.default.sources.USER);if(Object.keys(formats).length>0){this.quill.formatLine(range.index-length,length,formats,_quill2.default.sources.USER);}this.quill.focus();}function handleDelete(range,context){var length=/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix)?2:1;if(range.index>=this.quill.getLength()-length)return;var formats={},nextLength=0;var _quill$getLine15=this.quill.getLine(range.index),_quill$getLine16=_slicedToArray(_quill$getLine15,1),line=_quill$getLine16[0];if(context.offset>=line.length()-1){var _quill$getLine17=this.quill.getLine(range.index+1),_quill$getLine18=_slicedToArray(_quill$getLine17,1),next=_quill$getLine18[0];if(next){var curFormats=line.formats();var nextFormats=this.quill.getFormat(range.index,1);formats=_op2.default.attributes.diff(curFormats,nextFormats)||{};nextLength=next.length();}}this.quill.deleteText(range.index,length,_quill2.default.sources.USER);if(Object.keys(formats).length>0){this.quill.formatLine(range.index+nextLength-1,length,formats,_quill2.default.sources.USER);}}function handleDeleteRange(range){var lines=this.quill.getLines(range);var formats={};if(lines.length>1){var firstFormats=lines[0].formats();var lastFormats=lines[lines.length-1].formats();formats=_op2.default.attributes.diff(lastFormats,firstFormats)||{};}this.quill.deleteText(range,_quill2.default.sources.USER);if(Object.keys(formats).length>0){this.quill.formatLine(range.index,1,formats,_quill2.default.sources.USER);}this.quill.setSelection(range.index,_quill2.default.sources.SILENT);this.quill.focus();}function handleEnter(range,context){var _this3=this;if(range.length>0){this.quill.scroll.deleteAt(range.index,range.length);}var lineFormats=Object.keys(context.format).reduce(function(lineFormats,format){if(_parchment2.default.query(format,_parchment2.default.Scope.BLOCK)&&!Array.isArray(context.format[format])){lineFormats[format]=context.format[format];}return lineFormats;},{});this.quill.insertText(range.index,'\n',lineFormats,_quill2.default.sources.USER);this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);this.quill.focus();Object.keys(context.format).forEach(function(name){if(lineFormats[name]!=null)return;if(Array.isArray(context.format[name]))return;if(name==='link')return;_this3.quill.format(name,context.format[name],_quill2.default.sources.USER);});}function makeCodeBlockHandler(indent){return {key:Keyboard.keys.TAB,shiftKey:!indent,format:{'code-block':true},handler:function handler(range){var CodeBlock=_parchment2.default.query('code-block');var index=range.index,length=range.length;var _quill$scroll$descend=this.quill.scroll.descendant(CodeBlock,index),_quill$scroll$descend2=_slicedToArray(_quill$scroll$descend,2),block=_quill$scroll$descend2[0],offset=_quill$scroll$descend2[1];if(block==null)return;var scrollIndex=this.quill.getIndex(block);var start=block.newlineIndex(offset,true)+1;var end=block.newlineIndex(scrollIndex+offset+length);var lines=block.domNode.textContent.slice(start,end).split('\n');offset=0;lines.forEach(function(line,i){if(indent){block.insertAt(start+offset,CodeBlock.TAB);offset+=CodeBlock.TAB.length;if(i===0){index+=CodeBlock.TAB.length;}else{length+=CodeBlock.TAB.length;}}else if(line.startsWith(CodeBlock.TAB)){block.deleteAt(start+offset,CodeBlock.TAB.length);offset-=CodeBlock.TAB.length;if(i===0){index-=CodeBlock.TAB.length;}else{length-=CodeBlock.TAB.length;}}offset+=line.length+1;});this.quill.update(_quill2.default.sources.USER);this.quill.setSelection(index,length,_quill2.default.sources.SILENT);}};}function makeFormatHandler(format){return {key:format[0].toUpperCase(),shortKey:true,handler:function handler(range,context){this.quill.format(format,!context.format[format],_quill2.default.sources.USER);}};}function normalize(binding){if(typeof binding==='string'||typeof binding==='number'){return normalize({key:binding});}if((typeof binding==='undefined'?'undefined':_typeof(binding))==='object'){binding=_clone2.default(binding,false);}if(typeof binding.key==='string'){if(Keyboard.keys[binding.key.toUpperCase()]!=null){binding.key=Keyboard.keys[binding.key.toUpperCase()];}else if(binding.key.length===1){binding.key=binding.key.toUpperCase().charCodeAt(0);}else{return null;}}if(binding.shortKey){binding[SHORTKEY]=binding.shortKey;delete binding.shortKey;}return binding;}exports.default=Keyboard;exports.SHORTKEY=SHORTKEY;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.AlignStyle=exports.AlignClass=exports.AlignAttribute=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var config={scope:_parchment2.default.Scope.BLOCK,whitelist:['right','center','justify']};var AlignAttribute=new _parchment2.default.Attributor.Attribute('align','align',config);var AlignClass=new _parchment2.default.Attributor.Class('align','ql-align',config);var AlignStyle=new _parchment2.default.Attributor.Style('align','text-align',config);exports.AlignAttribute=AlignAttribute;exports.AlignClass=AlignClass;exports.AlignStyle=AlignStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.BackgroundStyle=exports.BackgroundClass=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _color=__webpack_require__(26);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var BackgroundClass=new _parchment2.default.Attributor.Class('background','ql-bg',{scope:_parchment2.default.Scope.INLINE});var BackgroundStyle=new _color.ColorAttributor('background','background-color',{scope:_parchment2.default.Scope.INLINE});exports.BackgroundClass=BackgroundClass;exports.BackgroundStyle=BackgroundStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.DirectionStyle=exports.DirectionClass=exports.DirectionAttribute=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var config={scope:_parchment2.default.Scope.BLOCK,whitelist:['rtl']};var DirectionAttribute=new _parchment2.default.Attributor.Attribute('direction','dir',config);var DirectionClass=new _parchment2.default.Attributor.Class('direction','ql-direction',config);var DirectionStyle=new _parchment2.default.Attributor.Style('direction','direction',config);exports.DirectionAttribute=DirectionAttribute;exports.DirectionClass=DirectionClass;exports.DirectionStyle=DirectionStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.FontClass=exports.FontStyle=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var config={scope:_parchment2.default.Scope.INLINE,whitelist:['serif','monospace']};var FontClass=new _parchment2.default.Attributor.Class('font','ql-font',config);var FontStyleAttributor=function(_Parchment$Attributor){_inherits(FontStyleAttributor,_Parchment$Attributor);function FontStyleAttributor(){_classCallCheck(this,FontStyleAttributor);return _possibleConstructorReturn(this,(FontStyleAttributor.__proto__||Object.getPrototypeOf(FontStyleAttributor)).apply(this,arguments));}_createClass(FontStyleAttributor,[{key:'value',value:function value(node){return _get(FontStyleAttributor.prototype.__proto__||Object.getPrototypeOf(FontStyleAttributor.prototype),'value',this).call(this,node).replace(/["']/g,'');}}]);return FontStyleAttributor;}(_parchment2.default.Attributor.Style);var FontStyle=new FontStyleAttributor('font','font-family',config);exports.FontStyle=FontStyle;exports.FontClass=FontClass;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.SizeStyle=exports.SizeClass=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var SizeClass=new _parchment2.default.Attributor.Class('size','ql-size',{scope:_parchment2.default.Scope.INLINE,whitelist:['small','large','huge']});var SizeStyle=new _parchment2.default.Attributor.Style('size','font-size',{scope:_parchment2.default.Scope.INLINE,whitelist:['10px','18px','32px']});exports.SizeClass=SizeClass;exports.SizeStyle=SizeStyle;},function(module,exports,__webpack_require__){module.exports={'align':{'':__webpack_require__(76),'center':__webpack_require__(77),'right':__webpack_require__(78),'justify':__webpack_require__(79)},'background':__webpack_require__(80),'blockquote':__webpack_require__(81),'bold':__webpack_require__(82),'clean':__webpack_require__(83),'code':__webpack_require__(58),'code-block':__webpack_require__(58),'color':__webpack_require__(84),'direction':{'':__webpack_require__(85),'rtl':__webpack_require__(86)},'float':{'center':__webpack_require__(87),'full':__webpack_require__(88),'left':__webpack_require__(89),'right':__webpack_require__(90)},'formula':__webpack_require__(91),'header':{'1':__webpack_require__(92),'2':__webpack_require__(93)},'italic':__webpack_require__(94),'image':__webpack_require__(95),'indent':{'+1':__webpack_require__(96),'-1':__webpack_require__(97)},'link':__webpack_require__(98),'list':{'ordered':__webpack_require__(99),'bullet':__webpack_require__(100),'check':__webpack_require__(101)},'script':{'sub':__webpack_require__(102),'super':__webpack_require__(103)},'strike':__webpack_require__(104),'underline':__webpack_require__(105),'video':__webpack_require__(106)};},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.getLastChangeIndex=exports.default=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var History=function(_Module){_inherits(History,_Module);function History(quill,options){_classCallCheck(this,History);var _this=_possibleConstructorReturn(this,(History.__proto__||Object.getPrototypeOf(History)).call(this,quill,options));_this.lastRecorded=0;_this.ignoreChange=false;_this.clear();_this.quill.on(_quill2.default.events.EDITOR_CHANGE,function(eventName,delta,oldDelta,source){if(eventName!==_quill2.default.events.TEXT_CHANGE||_this.ignoreChange)return;if(!_this.options.userOnly||source===_quill2.default.sources.USER){_this.record(delta,oldDelta);}else{_this.transform(delta);}});_this.quill.keyboard.addBinding({key:'Z',shortKey:true},_this.undo.bind(_this));_this.quill.keyboard.addBinding({key:'Z',shortKey:true,shiftKey:true},_this.redo.bind(_this));if(/Win/i.test(navigator.platform)){_this.quill.keyboard.addBinding({key:'Y',shortKey:true},_this.redo.bind(_this));}return _this;}_createClass(History,[{key:'change',value:function change(source,dest){if(this.stack[source].length===0)return;var delta=this.stack[source].pop();this.lastRecorded=0;this.ignoreChange=true;this.quill.updateContents(delta[source],_quill2.default.sources.USER);this.ignoreChange=false;var index=getLastChangeIndex(delta[source]);this.quill.setSelection(index);this.stack[dest].push(delta);}},{key:'clear',value:function clear(){this.stack={undo:[],redo:[]};}},{key:'cutoff',value:function cutoff(){this.lastRecorded=0;}},{key:'record',value:function record(changeDelta,oldDelta){if(changeDelta.ops.length===0)return;this.stack.redo=[];var undoDelta=this.quill.getContents().diff(oldDelta);var timestamp=Date.now();if(this.lastRecorded+this.options.delay>timestamp&&this.stack.undo.length>0){var delta=this.stack.undo.pop();undoDelta=undoDelta.compose(delta.undo);changeDelta=delta.redo.compose(changeDelta);}else{this.lastRecorded=timestamp;}this.stack.undo.push({redo:changeDelta,undo:undoDelta});if(this.stack.undo.length>this.options.maxStack){this.stack.undo.shift();}}},{key:'redo',value:function redo(){this.change('redo','undo');}},{key:'transform',value:function transform(delta){this.stack.undo.forEach(function(change){change.undo=delta.transform(change.undo,true);change.redo=delta.transform(change.redo,true);});this.stack.redo.forEach(function(change){change.undo=delta.transform(change.undo,true);change.redo=delta.transform(change.redo,true);});}},{key:'undo',value:function undo(){this.change('undo','redo');}}]);return History;}(_module2.default);History.DEFAULTS={delay:1000,maxStack:100,userOnly:false};function endsWithNewlineChange(delta){var lastOp=delta.ops[delta.ops.length-1];if(lastOp==null)return false;if(lastOp.insert!=null){return typeof lastOp.insert==='string'&&lastOp.insert.endsWith('\n');}if(lastOp.attributes!=null){return Object.keys(lastOp.attributes).some(function(attr){return _parchment2.default.query(attr,_parchment2.default.Scope.BLOCK)!=null;});}return false;}function getLastChangeIndex(delta){var deleteLength=delta.reduce(function(length,op){length+=op.delete||0;return length;},0);var changeIndex=delta.length()-deleteLength;if(endsWithNewlineChange(delta)){changeIndex-=1;}return changeIndex;}exports.default=History;exports.getLastChangeIndex=getLastChangeIndex;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.BaseTooltip=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _keyboard=__webpack_require__(35);var _keyboard2=_interopRequireDefault(_keyboard);var _theme=__webpack_require__(34);var _theme2=_interopRequireDefault(_theme);var _colorPicker=__webpack_require__(59);var _colorPicker2=_interopRequireDefault(_colorPicker);var _iconPicker=__webpack_require__(60);var _iconPicker2=_interopRequireDefault(_iconPicker);var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);var _tooltip=__webpack_require__(61);var _tooltip2=_interopRequireDefault(_tooltip);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ALIGNS=[false,'center','right','justify'];var COLORS=["#000000","#e60000","#ff9900","#ffff00","#008a00","#0066cc","#9933ff","#ffffff","#facccc","#ffebcc","#ffffcc","#cce8cc","#cce0f5","#ebd6ff","#bbbbbb","#f06666","#ffc266","#ffff66","#66b966","#66a3e0","#c285ff","#888888","#a10000","#b26b00","#b2b200","#006100","#0047b2","#6b24b2","#444444","#5c0000","#663d00","#666600","#003700","#002966","#3d1466"];var FONTS=[false,'serif','monospace'];var HEADERS=['1','2','3',false];var SIZES=['small',false,'large','huge'];var BaseTheme=function(_Theme){_inherits(BaseTheme,_Theme);function BaseTheme(quill,options){_classCallCheck(this,BaseTheme);var _this=_possibleConstructorReturn(this,(BaseTheme.__proto__||Object.getPrototypeOf(BaseTheme)).call(this,quill,options));var listener=function listener(e){if(!document.body.contains(quill.root)){return document.body.removeEventListener('click',listener);}if(_this.tooltip!=null&&!_this.tooltip.root.contains(e.target)&&document.activeElement!==_this.tooltip.textbox&&!_this.quill.hasFocus()){_this.tooltip.hide();}if(_this.pickers!=null){_this.pickers.forEach(function(picker){if(!picker.container.contains(e.target)){picker.close();}});}};quill.emitter.listenDOM('click',document.body,listener);return _this;}_createClass(BaseTheme,[{key:'addModule',value:function addModule(name){var module=_get(BaseTheme.prototype.__proto__||Object.getPrototypeOf(BaseTheme.prototype),'addModule',this).call(this,name);if(name==='toolbar'){this.extendToolbar(module);}return module;}},{key:'buildButtons',value:function buildButtons(buttons,icons){buttons.forEach(function(button){var className=button.getAttribute('class')||'';className.split(/\s+/).forEach(function(name){if(!name.startsWith('ql-'))return;name=name.slice('ql-'.length);if(icons[name]==null)return;if(name==='direction'){button.innerHTML=icons[name]['']+icons[name]['rtl'];}else if(typeof icons[name]==='string'){button.innerHTML=icons[name];}else{var value=button.value||'';if(value!=null&&icons[name][value]){button.innerHTML=icons[name][value];}}});});}},{key:'buildPickers',value:function buildPickers(selects,icons){var _this2=this;this.pickers=selects.map(function(select){if(select.classList.contains('ql-align')){if(select.querySelector('option')==null){fillSelect(select,ALIGNS);}return new _iconPicker2.default(select,icons.align);}else if(select.classList.contains('ql-background')||select.classList.contains('ql-color')){var format=select.classList.contains('ql-background')?'background':'color';if(select.querySelector('option')==null){fillSelect(select,COLORS,format==='background'?'#ffffff':'#000000');}return new _colorPicker2.default(select,icons[format]);}else{if(select.querySelector('option')==null){if(select.classList.contains('ql-font')){fillSelect(select,FONTS);}else if(select.classList.contains('ql-header')){fillSelect(select,HEADERS);}else if(select.classList.contains('ql-size')){fillSelect(select,SIZES);}}return new _picker2.default(select);}});var update=function update(){_this2.pickers.forEach(function(picker){picker.update();});};this.quill.on(_emitter2.default.events.EDITOR_CHANGE,update);}}]);return BaseTheme;}(_theme2.default);BaseTheme.DEFAULTS=_extend2.default(true,{},_theme2.default.DEFAULTS,{modules:{toolbar:{handlers:{formula:function formula(){this.quill.theme.tooltip.edit('formula');},image:function image(){var _this3=this;var fileInput=this.container.querySelector('input.ql-image[type=file]');if(fileInput==null){fileInput=document.createElement('input');fileInput.setAttribute('type','file');fileInput.setAttribute('accept','image/png, image/gif, image/jpeg, image/bmp, image/x-icon');fileInput.classList.add('ql-image');fileInput.addEventListener('change',function(){if(fileInput.files!=null&&fileInput.files[0]!=null){var reader=new FileReader();reader.onload=function(e){var range=_this3.quill.getSelection(true);_this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({image:e.target.result}),_emitter2.default.sources.USER);_this3.quill.setSelection(range.index+1,_emitter2.default.sources.SILENT);fileInput.value="";};reader.readAsDataURL(fileInput.files[0]);}});this.container.appendChild(fileInput);}fileInput.click();},video:function video(){this.quill.theme.tooltip.edit('video');}}}}});var BaseTooltip=function(_Tooltip){_inherits(BaseTooltip,_Tooltip);function BaseTooltip(quill,boundsContainer){_classCallCheck(this,BaseTooltip);var _this4=_possibleConstructorReturn(this,(BaseTooltip.__proto__||Object.getPrototypeOf(BaseTooltip)).call(this,quill,boundsContainer));_this4.textbox=_this4.root.querySelector('input[type="text"]');_this4.listen();return _this4;}_createClass(BaseTooltip,[{key:'listen',value:function listen(){var _this5=this;this.textbox.addEventListener('keydown',function(event){if(_keyboard2.default.match(event,'enter')){_this5.save();event.preventDefault();}else if(_keyboard2.default.match(event,'escape')){_this5.cancel();event.preventDefault();}});}},{key:'cancel',value:function cancel(){this.hide();}},{key:'edit',value:function edit(){var mode=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'link';var preview=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;this.root.classList.remove('ql-hidden');this.root.classList.add('ql-editing');if(preview!=null){this.textbox.value=preview;}else if(mode!==this.root.getAttribute('data-mode')){this.textbox.value='';}this.position(this.quill.getBounds(this.quill.selection.savedRange));this.textbox.select();this.textbox.setAttribute('placeholder',this.textbox.getAttribute('data-'+mode)||'');this.root.setAttribute('data-mode',mode);}},{key:'restoreFocus',value:function restoreFocus(){var scrollTop=this.quill.scrollingContainer.scrollTop;this.quill.focus();this.quill.scrollingContainer.scrollTop=scrollTop;}},{key:'save',value:function save(){var value=this.textbox.value;switch(this.root.getAttribute('data-mode')){case'link':{var scrollTop=this.quill.root.scrollTop;if(this.linkRange){this.quill.formatText(this.linkRange,'link',value,_emitter2.default.sources.USER);delete this.linkRange;}else{this.restoreFocus();this.quill.format('link',value,_emitter2.default.sources.USER);}this.quill.root.scrollTop=scrollTop;break;}case'video':{value=extractVideoUrl(value);}case'formula':{if(!value)break;var range=this.quill.getSelection(true);if(range!=null){var index=range.index+range.length;this.quill.insertEmbed(index,this.root.getAttribute('data-mode'),value,_emitter2.default.sources.USER);if(this.root.getAttribute('data-mode')==='formula'){this.quill.insertText(index+1,' ',_emitter2.default.sources.USER);}this.quill.setSelection(index+2,_emitter2.default.sources.USER);}break;}default:}this.textbox.value='';this.hide();}}]);return BaseTooltip;}(_tooltip2.default);function extractVideoUrl(url){var match=url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/)||url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);if(match){return (match[1]||'https')+'://www.youtube.com/embed/'+match[2]+'?showinfo=0';}if(match=url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)){return (match[1]||'https')+'://player.vimeo.com/video/'+match[2]+'/';}return url;}function fillSelect(select,values){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;values.forEach(function(value){var option=document.createElement('option');if(value===defaultValue){option.setAttribute('selected','selected');}else{option.setAttribute('value',value);}select.appendChild(option);});}exports.BaseTooltip=BaseTooltip;exports.default=BaseTheme;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var LinkedList=function(){function LinkedList(){this.head=this.tail=undefined;this.length=0;}LinkedList.prototype.append=function(){var nodes=[];for(var _i=0;_i<arguments.length;_i++){nodes[_i]=arguments[_i];}this.insertBefore(nodes[0],undefined);if(nodes.length>1){this.append.apply(this,nodes.slice(1));}};LinkedList.prototype.contains=function(node){var cur,next=this.iterator();while(cur=next()){if(cur===node)return true;}return false;};LinkedList.prototype.insertBefore=function(node,refNode){node.next=refNode;if(refNode!=null){node.prev=refNode.prev;if(refNode.prev!=null){refNode.prev.next=node;}refNode.prev=node;if(refNode===this.head){this.head=node;}}else if(this.tail!=null){this.tail.next=node;node.prev=this.tail;this.tail=node;}else{node.prev=undefined;this.head=this.tail=node;}this.length+=1;};LinkedList.prototype.offset=function(target){var index=0,cur=this.head;while(cur!=null){if(cur===target)return index;index+=cur.length();cur=cur.next;}return -1;};LinkedList.prototype.remove=function(node){if(!this.contains(node))return;if(node.prev!=null)node.prev.next=node.next;if(node.next!=null)node.next.prev=node.prev;if(node===this.head)this.head=node.next;if(node===this.tail)this.tail=node.prev;this.length-=1;};LinkedList.prototype.iterator=function(curNode){if(curNode===void 0){curNode=this.head;}return function(){var ret=curNode;if(curNode!=null)curNode=curNode.next;return ret;};};LinkedList.prototype.find=function(index,inclusive){if(inclusive===void 0){inclusive=false;}var cur,next=this.iterator();while(cur=next()){var length=cur.length();if(index<length||inclusive&&index===length&&(cur.next==null||cur.next.length()!==0)){return [cur,index];}index-=length;}return [null,0];};LinkedList.prototype.forEach=function(callback){var cur,next=this.iterator();while(cur=next()){callback(cur);}};LinkedList.prototype.forEachAt=function(index,length,callback){if(length<=0)return;var _a=this.find(index),startNode=_a[0],offset=_a[1];var cur,curIndex=index-offset,next=this.iterator(startNode);while((cur=next())&&curIndex<index+length){var curLength=cur.length();if(index>curIndex){callback(cur,index-curIndex,Math.min(length,curIndex+curLength-index));}else{callback(cur,0,Math.min(curLength,index+length-curIndex));}curIndex+=curLength;}};LinkedList.prototype.map=function(callback){return this.reduce(function(memo,cur){memo.push(callback(cur));return memo;},[]);};LinkedList.prototype.reduce=function(callback,memo){var cur,next=this.iterator();while(cur=next()){memo=callback(memo,cur);}return memo;};return LinkedList;}();exports.default=LinkedList;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var container_1=__webpack_require__(17);var Registry=__webpack_require__(1);var OBSERVER_CONFIG={attributes:true,characterData:true,characterDataOldValue:true,childList:true,subtree:true};var MAX_OPTIMIZE_ITERATIONS=100;var ScrollBlot=function(_super){__extends(ScrollBlot,_super);function ScrollBlot(node){var _this=_super.call(this,node)||this;_this.parent=null;_this.scroll=_this;_this.observer=new MutationObserver(function(mutations){_this.update(mutations);});_this.observer.observe(_this.domNode,OBSERVER_CONFIG);_this.attach();return _this;}ScrollBlot.prototype.detach=function(){_super.prototype.detach.call(this);this.observer.disconnect();};ScrollBlot.prototype.deleteAt=function(index,length){this.update();if(index===0&&length===this.length()){this.children.forEach(function(child){child.remove();});}else{_super.prototype.deleteAt.call(this,index,length);}};ScrollBlot.prototype.formatAt=function(index,length,name,value){this.update();_super.prototype.formatAt.call(this,index,length,name,value);};ScrollBlot.prototype.insertAt=function(index,value,def){this.update();_super.prototype.insertAt.call(this,index,value,def);};ScrollBlot.prototype.optimize=function(mutations,context){var _this=this;if(mutations===void 0){mutations=[];}if(context===void 0){context={};}_super.prototype.optimize.call(this,context);var records=[].slice.call(this.observer.takeRecords());while(records.length>0)mutations.push(records.pop());var mark=function(blot,markParent){if(markParent===void 0){markParent=true;}if(blot==null||blot===_this)return;if(blot.domNode.parentNode==null)return;if(blot.domNode[Registry.DATA_KEY].mutations==null){blot.domNode[Registry.DATA_KEY].mutations=[];}if(markParent)mark(blot.parent);};var optimize=function(blot){if(blot.domNode[Registry.DATA_KEY]==null||blot.domNode[Registry.DATA_KEY].mutations==null){return;}if(blot instanceof container_1.default){blot.children.forEach(optimize);}blot.optimize(context);};var remaining=mutations;for(var i=0;remaining.length>0;i+=1){if(i>=MAX_OPTIMIZE_ITERATIONS){throw new Error('[Parchment] Maximum optimize iterations reached');}remaining.forEach(function(mutation){var blot=Registry.find(mutation.target,true);if(blot==null)return;if(blot.domNode===mutation.target){if(mutation.type==='childList'){mark(Registry.find(mutation.previousSibling,false));[].forEach.call(mutation.addedNodes,function(node){var child=Registry.find(node,false);mark(child,false);if(child instanceof container_1.default){child.children.forEach(function(grandChild){mark(grandChild,false);});}});}else if(mutation.type==='attributes'){mark(blot.prev);}}mark(blot);});this.children.forEach(optimize);remaining=[].slice.call(this.observer.takeRecords());records=remaining.slice();while(records.length>0)mutations.push(records.pop());}};ScrollBlot.prototype.update=function(mutations,context){var _this=this;if(context===void 0){context={};}mutations=mutations||this.observer.takeRecords();mutations.map(function(mutation){var blot=Registry.find(mutation.target,true);if(blot==null)return;if(blot.domNode[Registry.DATA_KEY].mutations==null){blot.domNode[Registry.DATA_KEY].mutations=[mutation];return blot;}else{blot.domNode[Registry.DATA_KEY].mutations.push(mutation);return null;}}).forEach(function(blot){if(blot==null||blot===_this||blot.domNode[Registry.DATA_KEY]==null)return;blot.update(blot.domNode[Registry.DATA_KEY].mutations||[],context);});if(this.domNode[Registry.DATA_KEY].mutations!=null){_super.prototype.update.call(this,this.domNode[Registry.DATA_KEY].mutations,context);}this.optimize(mutations,context);};ScrollBlot.blotName='scroll';ScrollBlot.defaultChild='block';ScrollBlot.scope=Registry.Scope.BLOCK_BLOT;ScrollBlot.tagName='DIV';return ScrollBlot;}(container_1.default);exports.default=ScrollBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var format_1=__webpack_require__(18);var Registry=__webpack_require__(1);function isEqual(obj1,obj2){if(Object.keys(obj1).length!==Object.keys(obj2).length)return false;for(var prop in obj1){if(obj1[prop]!==obj2[prop])return false;}return true;}var InlineBlot=function(_super){__extends(InlineBlot,_super);function InlineBlot(){return _super!==null&&_super.apply(this,arguments)||this;}InlineBlot.formats=function(domNode){if(domNode.tagName===InlineBlot.tagName)return undefined;return _super.formats.call(this,domNode);};InlineBlot.prototype.format=function(name,value){var _this=this;if(name===this.statics.blotName&&!value){this.children.forEach(function(child){if(!(child instanceof format_1.default)){child=child.wrap(InlineBlot.blotName,true);}_this.attributes.copy(child);});this.unwrap();}else{_super.prototype.format.call(this,name,value);}};InlineBlot.prototype.formatAt=function(index,length,name,value){if(this.formats()[name]!=null||Registry.query(name,Registry.Scope.ATTRIBUTE)){var blot=this.isolate(index,length);blot.format(name,value);}else{_super.prototype.formatAt.call(this,index,length,name,value);}};InlineBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);var formats=this.formats();if(Object.keys(formats).length===0){return this.unwrap();}var next=this.next;if(next instanceof InlineBlot&&next.prev===this&&isEqual(formats,next.formats())){next.moveChildren(this);next.remove();}};InlineBlot.blotName='inline';InlineBlot.scope=Registry.Scope.INLINE_BLOT;InlineBlot.tagName='SPAN';return InlineBlot;}(format_1.default);exports.default=InlineBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var format_1=__webpack_require__(18);var Registry=__webpack_require__(1);var BlockBlot=function(_super){__extends(BlockBlot,_super);function BlockBlot(){return _super!==null&&_super.apply(this,arguments)||this;}BlockBlot.formats=function(domNode){var tagName=Registry.query(BlockBlot.blotName).tagName;if(domNode.tagName===tagName)return undefined;return _super.formats.call(this,domNode);};BlockBlot.prototype.format=function(name,value){if(Registry.query(name,Registry.Scope.BLOCK)==null){return;}else if(name===this.statics.blotName&&!value){this.replaceWith(BlockBlot.blotName);}else{_super.prototype.format.call(this,name,value);}};BlockBlot.prototype.formatAt=function(index,length,name,value){if(Registry.query(name,Registry.Scope.BLOCK)!=null){this.format(name,value);}else{_super.prototype.formatAt.call(this,index,length,name,value);}};BlockBlot.prototype.insertAt=function(index,value,def){if(def==null||Registry.query(value,Registry.Scope.INLINE)!=null){_super.prototype.insertAt.call(this,index,value,def);}else{var after=this.split(index);var blot=Registry.create(value,def);after.parent.insertBefore(blot,after);}};BlockBlot.prototype.update=function(mutations,context){if(navigator.userAgent.match(/Trident/)){this.build();}else{_super.prototype.update.call(this,mutations,context);}};BlockBlot.blotName='block';BlockBlot.scope=Registry.Scope.BLOCK_BLOT;BlockBlot.tagName='P';return BlockBlot;}(format_1.default);exports.default=BlockBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var leaf_1=__webpack_require__(19);var EmbedBlot=function(_super){__extends(EmbedBlot,_super);function EmbedBlot(){return _super!==null&&_super.apply(this,arguments)||this;}EmbedBlot.formats=function(domNode){return undefined;};EmbedBlot.prototype.format=function(name,value){_super.prototype.formatAt.call(this,0,this.length(),name,value);};EmbedBlot.prototype.formatAt=function(index,length,name,value){if(index===0&&length===this.length()){this.format(name,value);}else{_super.prototype.formatAt.call(this,index,length,name,value);}};EmbedBlot.prototype.formats=function(){return this.statics.formats(this.domNode);};return EmbedBlot;}(leaf_1.default);exports.default=EmbedBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var leaf_1=__webpack_require__(19);var Registry=__webpack_require__(1);var TextBlot=function(_super){__extends(TextBlot,_super);function TextBlot(node){var _this=_super.call(this,node)||this;_this.text=_this.statics.value(_this.domNode);return _this;}TextBlot.create=function(value){return document.createTextNode(value);};TextBlot.value=function(domNode){var text=domNode.data;if(text['normalize'])text=text['normalize']();return text;};TextBlot.prototype.deleteAt=function(index,length){this.domNode.data=this.text=this.text.slice(0,index)+this.text.slice(index+length);};TextBlot.prototype.index=function(node,offset){if(this.domNode===node){return offset;}return -1;};TextBlot.prototype.insertAt=function(index,value,def){if(def==null){this.text=this.text.slice(0,index)+value+this.text.slice(index);this.domNode.data=this.text;}else{_super.prototype.insertAt.call(this,index,value,def);}};TextBlot.prototype.length=function(){return this.text.length;};TextBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);this.text=this.statics.value(this.domNode);if(this.text.length===0){this.remove();}else if(this.next instanceof TextBlot&&this.next.prev===this){this.insertAt(this.length(),this.next.value());this.next.remove();}};TextBlot.prototype.position=function(index,inclusive){if(inclusive===void 0){inclusive=false;}return [this.domNode,index];};TextBlot.prototype.split=function(index,force){if(force===void 0){force=false;}if(!force){if(index===0)return this;if(index===this.length())return this.next;}var after=Registry.create(this.domNode.splitText(index));this.parent.insertBefore(after,this.next);this.text=this.statics.value(this.domNode);return after;};TextBlot.prototype.update=function(mutations,context){var _this=this;if(mutations.some(function(mutation){return mutation.type==='characterData'&&mutation.target===_this.domNode;})){this.text=this.statics.value(this.domNode);}};TextBlot.prototype.value=function(){return this.text;};TextBlot.blotName='text';TextBlot.scope=Registry.Scope.INLINE_BLOT;return TextBlot;}(leaf_1.default);exports.default=TextBlot;},function(module,exports,__webpack_require__){var elem=document.createElement('div');elem.classList.toggle('test-class',false);if(elem.classList.contains('test-class')){var _toggle=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(token,force){if(arguments.length>1&&!this.contains(token)===!force){return force;}else{return _toggle.call(this,token);}};}if(!String.prototype.startsWith){String.prototype.startsWith=function(searchString,position){position=position||0;return this.substr(position,searchString.length)===searchString;};}if(!String.prototype.endsWith){String.prototype.endsWith=function(searchString,position){var subjectString=this.toString();if(typeof position!=='number'||!isFinite(position)||Math.floor(position)!==position||position>subjectString.length){position=subjectString.length;}position-=searchString.length;var lastIndex=subjectString.indexOf(searchString,position);return lastIndex!==-1&&lastIndex===position;};}if(!Array.prototype.find){Object.defineProperty(Array.prototype,"find",{value:function value(predicate){if(this===null){throw new TypeError('Array.prototype.find called on null or undefined');}if(typeof predicate!=='function'){throw new TypeError('predicate must be a function');}var list=Object(this);var length=list.length>>>0;var thisArg=arguments[1];var value;for(var i=0;i<length;i++){value=list[i];if(predicate.call(thisArg,value,i,list)){return value;}}return undefined;}});}document.addEventListener("DOMContentLoaded",function(){document.execCommand("enableObjectResizing",false,false);document.execCommand("autoUrlDetect",false,false);});},function(module,exports){var DIFF_DELETE=-1;var DIFF_INSERT=1;var DIFF_EQUAL=0;function diff_main(text1,text2,cursor_pos){if(text1==text2){if(text1){return [[DIFF_EQUAL,text1]];}return [];}if(cursor_pos<0||text1.length<cursor_pos){cursor_pos=null;}var commonlength=diff_commonPrefix(text1,text2);var commonprefix=text1.substring(0,commonlength);text1=text1.substring(commonlength);text2=text2.substring(commonlength);commonlength=diff_commonSuffix(text1,text2);var commonsuffix=text1.substring(text1.length-commonlength);text1=text1.substring(0,text1.length-commonlength);text2=text2.substring(0,text2.length-commonlength);var diffs=diff_compute_(text1,text2);if(commonprefix){diffs.unshift([DIFF_EQUAL,commonprefix]);}if(commonsuffix){diffs.push([DIFF_EQUAL,commonsuffix]);}diff_cleanupMerge(diffs);if(cursor_pos!=null){diffs=fix_cursor(diffs,cursor_pos);}diffs=fix_emoji(diffs);return diffs;}function diff_compute_(text1,text2){var diffs;if(!text1){return [[DIFF_INSERT,text2]];}if(!text2){return [[DIFF_DELETE,text1]];}var longtext=text1.length>text2.length?text1:text2;var shorttext=text1.length>text2.length?text2:text1;var i=longtext.indexOf(shorttext);if(i!=-1){diffs=[[DIFF_INSERT,longtext.substring(0,i)],[DIFF_EQUAL,shorttext],[DIFF_INSERT,longtext.substring(i+shorttext.length)]];if(text1.length>text2.length){diffs[0][0]=diffs[2][0]=DIFF_DELETE;}return diffs;}if(shorttext.length==1){return [[DIFF_DELETE,text1],[DIFF_INSERT,text2]];}var hm=diff_halfMatch_(text1,text2);if(hm){var text1_a=hm[0];var text1_b=hm[1];var text2_a=hm[2];var text2_b=hm[3];var mid_common=hm[4];var diffs_a=diff_main(text1_a,text2_a);var diffs_b=diff_main(text1_b,text2_b);return diffs_a.concat([[DIFF_EQUAL,mid_common]],diffs_b);}return diff_bisect_(text1,text2);}function diff_bisect_(text1,text2){var text1_length=text1.length;var text2_length=text2.length;var max_d=Math.ceil((text1_length+text2_length)/2);var v_offset=max_d;var v_length=2*max_d;var v1=new Array(v_length);var v2=new Array(v_length);for(var x=0;x<v_length;x++){v1[x]=-1;v2[x]=-1;}v1[v_offset+1]=0;v2[v_offset+1]=0;var delta=text1_length-text2_length;var front=delta%2!=0;var k1start=0;var k1end=0;var k2start=0;var k2end=0;for(var d=0;d<max_d;d++){for(var k1=-d+k1start;k1<=d-k1end;k1+=2){var k1_offset=v_offset+k1;var x1;if(k1==-d||k1!=d&&v1[k1_offset-1]<v1[k1_offset+1]){x1=v1[k1_offset+1];}else{x1=v1[k1_offset-1]+1;}var y1=x1-k1;while(x1<text1_length&&y1<text2_length&&text1.charAt(x1)==text2.charAt(y1)){x1++;y1++;}v1[k1_offset]=x1;if(x1>text1_length){k1end+=2;}else if(y1>text2_length){k1start+=2;}else if(front){var k2_offset=v_offset+delta-k1;if(k2_offset>=0&&k2_offset<v_length&&v2[k2_offset]!=-1){var x2=text1_length-v2[k2_offset];if(x1>=x2){return diff_bisectSplit_(text1,text2,x1,y1);}}}}for(var k2=-d+k2start;k2<=d-k2end;k2+=2){var k2_offset=v_offset+k2;var x2;if(k2==-d||k2!=d&&v2[k2_offset-1]<v2[k2_offset+1]){x2=v2[k2_offset+1];}else{x2=v2[k2_offset-1]+1;}var y2=x2-k2;while(x2<text1_length&&y2<text2_length&&text1.charAt(text1_length-x2-1)==text2.charAt(text2_length-y2-1)){x2++;y2++;}v2[k2_offset]=x2;if(x2>text1_length){k2end+=2;}else if(y2>text2_length){k2start+=2;}else if(!front){var k1_offset=v_offset+delta-k2;if(k1_offset>=0&&k1_offset<v_length&&v1[k1_offset]!=-1){var x1=v1[k1_offset];var y1=v_offset+x1-k1_offset;x2=text1_length-x2;if(x1>=x2){return diff_bisectSplit_(text1,text2,x1,y1);}}}}}return [[DIFF_DELETE,text1],[DIFF_INSERT,text2]];}function diff_bisectSplit_(text1,text2,x,y){var text1a=text1.substring(0,x);var text2a=text2.substring(0,y);var text1b=text1.substring(x);var text2b=text2.substring(y);var diffs=diff_main(text1a,text2a);var diffsb=diff_main(text1b,text2b);return diffs.concat(diffsb);}function diff_commonPrefix(text1,text2){if(!text1||!text2||text1.charAt(0)!=text2.charAt(0)){return 0;}var pointermin=0;var pointermax=Math.min(text1.length,text2.length);var pointermid=pointermax;var pointerstart=0;while(pointermin<pointermid){if(text1.substring(pointerstart,pointermid)==text2.substring(pointerstart,pointermid)){pointermin=pointermid;pointerstart=pointermin;}else{pointermax=pointermid;}pointermid=Math.floor((pointermax-pointermin)/2+pointermin);}return pointermid;}function diff_commonSuffix(text1,text2){if(!text1||!text2||text1.charAt(text1.length-1)!=text2.charAt(text2.length-1)){return 0;}var pointermin=0;var pointermax=Math.min(text1.length,text2.length);var pointermid=pointermax;var pointerend=0;while(pointermin<pointermid){if(text1.substring(text1.length-pointermid,text1.length-pointerend)==text2.substring(text2.length-pointermid,text2.length-pointerend)){pointermin=pointermid;pointerend=pointermin;}else{pointermax=pointermid;}pointermid=Math.floor((pointermax-pointermin)/2+pointermin);}return pointermid;}function diff_halfMatch_(text1,text2){var longtext=text1.length>text2.length?text1:text2;var shorttext=text1.length>text2.length?text2:text1;if(longtext.length<4||shorttext.length*2<longtext.length){return null;}function diff_halfMatchI_(longtext,shorttext,i){var seed=longtext.substring(i,i+Math.floor(longtext.length/4));var j=-1;var best_common='';var best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b;while((j=shorttext.indexOf(seed,j+1))!=-1){var prefixLength=diff_commonPrefix(longtext.substring(i),shorttext.substring(j));var suffixLength=diff_commonSuffix(longtext.substring(0,i),shorttext.substring(0,j));if(best_common.length<suffixLength+prefixLength){best_common=shorttext.substring(j-suffixLength,j)+shorttext.substring(j,j+prefixLength);best_longtext_a=longtext.substring(0,i-suffixLength);best_longtext_b=longtext.substring(i+prefixLength);best_shorttext_a=shorttext.substring(0,j-suffixLength);best_shorttext_b=shorttext.substring(j+prefixLength);}}if(best_common.length*2>=longtext.length){return [best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b,best_common];}else{return null;}}var hm1=diff_halfMatchI_(longtext,shorttext,Math.ceil(longtext.length/4));var hm2=diff_halfMatchI_(longtext,shorttext,Math.ceil(longtext.length/2));var hm;if(!hm1&&!hm2){return null;}else if(!hm2){hm=hm1;}else if(!hm1){hm=hm2;}else{hm=hm1[4].length>hm2[4].length?hm1:hm2;}var text1_a,text1_b,text2_a,text2_b;if(text1.length>text2.length){text1_a=hm[0];text1_b=hm[1];text2_a=hm[2];text2_b=hm[3];}else{text2_a=hm[0];text2_b=hm[1];text1_a=hm[2];text1_b=hm[3];}var mid_common=hm[4];return [text1_a,text1_b,text2_a,text2_b,mid_common];}function diff_cleanupMerge(diffs){diffs.push([DIFF_EQUAL,'']);var pointer=0;var count_delete=0;var count_insert=0;var text_delete='';var text_insert='';var commonlength;while(pointer<diffs.length){switch(diffs[pointer][0]){case DIFF_INSERT:count_insert++;text_insert+=diffs[pointer][1];pointer++;break;case DIFF_DELETE:count_delete++;text_delete+=diffs[pointer][1];pointer++;break;case DIFF_EQUAL:if(count_delete+count_insert>1){if(count_delete!==0&&count_insert!==0){commonlength=diff_commonPrefix(text_insert,text_delete);if(commonlength!==0){if(pointer-count_delete-count_insert>0&&diffs[pointer-count_delete-count_insert-1][0]==DIFF_EQUAL){diffs[pointer-count_delete-count_insert-1][1]+=text_insert.substring(0,commonlength);}else{diffs.splice(0,0,[DIFF_EQUAL,text_insert.substring(0,commonlength)]);pointer++;}text_insert=text_insert.substring(commonlength);text_delete=text_delete.substring(commonlength);}commonlength=diff_commonSuffix(text_insert,text_delete);if(commonlength!==0){diffs[pointer][1]=text_insert.substring(text_insert.length-commonlength)+diffs[pointer][1];text_insert=text_insert.substring(0,text_insert.length-commonlength);text_delete=text_delete.substring(0,text_delete.length-commonlength);}}if(count_delete===0){diffs.splice(pointer-count_insert,count_delete+count_insert,[DIFF_INSERT,text_insert]);}else if(count_insert===0){diffs.splice(pointer-count_delete,count_delete+count_insert,[DIFF_DELETE,text_delete]);}else{diffs.splice(pointer-count_delete-count_insert,count_delete+count_insert,[DIFF_DELETE,text_delete],[DIFF_INSERT,text_insert]);}pointer=pointer-count_delete-count_insert+(count_delete?1:0)+(count_insert?1:0)+1;}else if(pointer!==0&&diffs[pointer-1][0]==DIFF_EQUAL){diffs[pointer-1][1]+=diffs[pointer][1];diffs.splice(pointer,1);}else{pointer++;}count_insert=0;count_delete=0;text_delete='';text_insert='';break;}}if(diffs[diffs.length-1][1]===''){diffs.pop();}var changes=false;pointer=1;while(pointer<diffs.length-1){if(diffs[pointer-1][0]==DIFF_EQUAL&&diffs[pointer+1][0]==DIFF_EQUAL){if(diffs[pointer][1].substring(diffs[pointer][1].length-diffs[pointer-1][1].length)==diffs[pointer-1][1]){diffs[pointer][1]=diffs[pointer-1][1]+diffs[pointer][1].substring(0,diffs[pointer][1].length-diffs[pointer-1][1].length);diffs[pointer+1][1]=diffs[pointer-1][1]+diffs[pointer+1][1];diffs.splice(pointer-1,1);changes=true;}else if(diffs[pointer][1].substring(0,diffs[pointer+1][1].length)==diffs[pointer+1][1]){diffs[pointer-1][1]+=diffs[pointer+1][1];diffs[pointer][1]=diffs[pointer][1].substring(diffs[pointer+1][1].length)+diffs[pointer+1][1];diffs.splice(pointer+1,1);changes=true;}}pointer++;}if(changes){diff_cleanupMerge(diffs);}}var diff=diff_main;diff.INSERT=DIFF_INSERT;diff.DELETE=DIFF_DELETE;diff.EQUAL=DIFF_EQUAL;module.exports=diff;function cursor_normalize_diff(diffs,cursor_pos){if(cursor_pos===0){return [DIFF_EQUAL,diffs];}for(var current_pos=0,i=0;i<diffs.length;i++){var d=diffs[i];if(d[0]===DIFF_DELETE||d[0]===DIFF_EQUAL){var next_pos=current_pos+d[1].length;if(cursor_pos===next_pos){return [i+1,diffs];}else if(cursor_pos<next_pos){diffs=diffs.slice();var split_pos=cursor_pos-current_pos;var d_left=[d[0],d[1].slice(0,split_pos)];var d_right=[d[0],d[1].slice(split_pos)];diffs.splice(i,1,d_left,d_right);return [i+1,diffs];}else{current_pos=next_pos;}}}throw new Error('cursor_pos is out of bounds!');}function fix_cursor(diffs,cursor_pos){var norm=cursor_normalize_diff(diffs,cursor_pos);var ndiffs=norm[1];var cursor_pointer=norm[0];var d=ndiffs[cursor_pointer];var d_next=ndiffs[cursor_pointer+1];if(d==null){return diffs;}else if(d[0]!==DIFF_EQUAL){return diffs;}else{if(d_next!=null&&d[1]+d_next[1]===d_next[1]+d[1]){ndiffs.splice(cursor_pointer,2,d_next,d);return merge_tuples(ndiffs,cursor_pointer,2);}else if(d_next!=null&&d_next[1].indexOf(d[1])===0){ndiffs.splice(cursor_pointer,2,[d_next[0],d[1]],[0,d[1]]);var suffix=d_next[1].slice(d[1].length);if(suffix.length>0){ndiffs.splice(cursor_pointer+2,0,[d_next[0],suffix]);}return merge_tuples(ndiffs,cursor_pointer,3);}else{return diffs;}}}function fix_emoji(diffs){var compact=false;var starts_with_pair_end=function(str){return str.charCodeAt(0)>=0xDC00&&str.charCodeAt(0)<=0xDFFF;};var ends_with_pair_start=function(str){return str.charCodeAt(str.length-1)>=0xD800&&str.charCodeAt(str.length-1)<=0xDBFF;};for(var i=2;i<diffs.length;i+=1){if(diffs[i-2][0]===DIFF_EQUAL&&ends_with_pair_start(diffs[i-2][1])&&diffs[i-1][0]===DIFF_DELETE&&starts_with_pair_end(diffs[i-1][1])&&diffs[i][0]===DIFF_INSERT&&starts_with_pair_end(diffs[i][1])){compact=true;diffs[i-1][1]=diffs[i-2][1].slice(-1)+diffs[i-1][1];diffs[i][1]=diffs[i-2][1].slice(-1)+diffs[i][1];diffs[i-2][1]=diffs[i-2][1].slice(0,-1);}}if(!compact){return diffs;}var fixed_diffs=[];for(var i=0;i<diffs.length;i+=1){if(diffs[i][1].length>0){fixed_diffs.push(diffs[i]);}}return fixed_diffs;}function merge_tuples(diffs,start,length){for(var i=start+length-1;i>=0&&i>=start-1;i--){if(i+1<diffs.length){var left_d=diffs[i];var right_d=diffs[i+1];if(left_d[0]===right_d[1]){diffs.splice(i,2,[left_d[0],left_d[1]+right_d[1]]);}}}return diffs;}},function(module,exports){exports=module.exports=typeof Object.keys==='function'?Object.keys:shim;exports.shim=shim;function shim(obj){var keys=[];for(var key in obj)keys.push(key);return keys;}},function(module,exports){var supportsArgumentsClass=function(){return Object.prototype.toString.call(arguments);}()=='[object Arguments]';exports=module.exports=supportsArgumentsClass?supported:unsupported;exports.supported=supported;function supported(object){return Object.prototype.toString.call(object)=='[object Arguments]';}exports.unsupported=unsupported;function unsupported(object){return object&&typeof object=='object'&&typeof object.length=='number'&&Object.prototype.hasOwnProperty.call(object,'callee')&&!Object.prototype.propertyIsEnumerable.call(object,'callee')||false;}},function(module,exports){var has=Object.prototype.hasOwnProperty,prefix='~';function Events(){}if(Object.create){Events.prototype=Object.create(null);if(!new Events().__proto__)prefix=false;}function EE(fn,context,once){this.fn=fn;this.context=context;this.once=once||false;}function EventEmitter(){this._events=new Events();this._eventsCount=0;}EventEmitter.prototype.eventNames=function eventNames(){var names=[],events,name;if(this._eventsCount===0)return names;for(name in events=this._events){if(has.call(events,name))names.push(prefix?name.slice(1):name);}if(Object.getOwnPropertySymbols){return names.concat(Object.getOwnPropertySymbols(events));}return names;};EventEmitter.prototype.listeners=function listeners(event,exists){var evt=prefix?prefix+event:event,available=this._events[evt];if(exists)return !!available;if(!available)return [];if(available.fn)return [available.fn];for(var i=0,l=available.length,ee=new Array(l);i<l;i++){ee[i]=available[i].fn;}return ee;};EventEmitter.prototype.emit=function emit(event,a1,a2,a3,a4,a5){var evt=prefix?prefix+event:event;if(!this._events[evt])return false;var listeners=this._events[evt],len=arguments.length,args,i;if(listeners.fn){if(listeners.once)this.removeListener(event,listeners.fn,undefined,true);switch(len){case 1:return listeners.fn.call(listeners.context),true;case 2:return listeners.fn.call(listeners.context,a1),true;case 3:return listeners.fn.call(listeners.context,a1,a2),true;case 4:return listeners.fn.call(listeners.context,a1,a2,a3),true;case 5:return listeners.fn.call(listeners.context,a1,a2,a3,a4),true;case 6:return listeners.fn.call(listeners.context,a1,a2,a3,a4,a5),true;}for(i=1,args=new Array(len-1);i<len;i++){args[i-1]=arguments[i];}listeners.fn.apply(listeners.context,args);}else{var length=listeners.length,j;for(i=0;i<length;i++){if(listeners[i].once)this.removeListener(event,listeners[i].fn,undefined,true);switch(len){case 1:listeners[i].fn.call(listeners[i].context);break;case 2:listeners[i].fn.call(listeners[i].context,a1);break;case 3:listeners[i].fn.call(listeners[i].context,a1,a2);break;case 4:listeners[i].fn.call(listeners[i].context,a1,a2,a3);break;default:if(!args)for(j=1,args=new Array(len-1);j<len;j++){args[j-1]=arguments[j];}listeners[i].fn.apply(listeners[i].context,args);}}}return true;};EventEmitter.prototype.on=function on(event,fn,context){var listener=new EE(fn,context||this),evt=prefix?prefix+event:event;if(!this._events[evt])this._events[evt]=listener,this._eventsCount++;else if(!this._events[evt].fn)this._events[evt].push(listener);else this._events[evt]=[this._events[evt],listener];return this;};EventEmitter.prototype.once=function once(event,fn,context){var listener=new EE(fn,context||this,true),evt=prefix?prefix+event:event;if(!this._events[evt])this._events[evt]=listener,this._eventsCount++;else if(!this._events[evt].fn)this._events[evt].push(listener);else this._events[evt]=[this._events[evt],listener];return this;};EventEmitter.prototype.removeListener=function removeListener(event,fn,context,once){var evt=prefix?prefix+event:event;if(!this._events[evt])return this;if(!fn){if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];return this;}var listeners=this._events[evt];if(listeners.fn){if(listeners.fn===fn&&(!once||listeners.once)&&(!context||listeners.context===context)){if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];}}else{for(var i=0,events=[],length=listeners.length;i<length;i++){if(listeners[i].fn!==fn||once&&!listeners[i].once||context&&listeners[i].context!==context){events.push(listeners[i]);}}if(events.length)this._events[evt]=events.length===1?events[0]:events;else if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(event){var evt;if(event){evt=prefix?prefix+event:event;if(this._events[evt]){if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];}}else{this._events=new Events();this._eventsCount=0;}return this;};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.addListener=EventEmitter.prototype.on;EventEmitter.prototype.setMaxListeners=function setMaxListeners(){return this;};EventEmitter.prefixed=prefix;EventEmitter.EventEmitter=EventEmitter;if('undefined'!==typeof module){module.exports=EventEmitter;}},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.matchText=exports.matchSpacing=exports.matchNewline=exports.matchBlot=exports.matchAttributor=exports.default=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _extend2=__webpack_require__(3);var _extend3=_interopRequireDefault(_extend2);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);var _align=__webpack_require__(36);var _background=__webpack_require__(37);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _color=__webpack_require__(26);var _direction=__webpack_require__(38);var _font=__webpack_require__(39);var _size=__webpack_require__(40);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:clipboard');var DOM_KEY='__ql-matcher';var CLIPBOARD_CONFIG=[[Node.TEXT_NODE,matchText],[Node.TEXT_NODE,matchNewline],['br',matchBreak],[Node.ELEMENT_NODE,matchNewline],[Node.ELEMENT_NODE,matchBlot],[Node.ELEMENT_NODE,matchSpacing],[Node.ELEMENT_NODE,matchAttributor],[Node.ELEMENT_NODE,matchStyles],['li',matchIndent],['b',matchAlias.bind(matchAlias,'bold')],['i',matchAlias.bind(matchAlias,'italic')],['style',matchIgnore]];var ATTRIBUTE_ATTRIBUTORS=[_align.AlignAttribute,_direction.DirectionAttribute].reduce(function(memo,attr){memo[attr.keyName]=attr;return memo;},{});var STYLE_ATTRIBUTORS=[_align.AlignStyle,_background.BackgroundStyle,_color.ColorStyle,_direction.DirectionStyle,_font.FontStyle,_size.SizeStyle].reduce(function(memo,attr){memo[attr.keyName]=attr;return memo;},{});var Clipboard=function(_Module){_inherits(Clipboard,_Module);function Clipboard(quill,options){_classCallCheck(this,Clipboard);var _this=_possibleConstructorReturn(this,(Clipboard.__proto__||Object.getPrototypeOf(Clipboard)).call(this,quill,options));_this.quill.root.addEventListener('paste',_this.onPaste.bind(_this));_this.container=_this.quill.addContainer('ql-clipboard');_this.container.setAttribute('contenteditable',true);_this.container.setAttribute('tabindex',-1);_this.matchers=[];CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref){var _ref2=_slicedToArray(_ref,2),selector=_ref2[0],matcher=_ref2[1];if(!options.matchVisual&&matcher===matchSpacing)return;_this.addMatcher(selector,matcher);});return _this;}_createClass(Clipboard,[{key:'addMatcher',value:function addMatcher(selector,matcher){this.matchers.push([selector,matcher]);}},{key:'convert',value:function convert(html){if(typeof html==='string'){this.container.innerHTML=html.replace(/\>\r?\n +\</g,'><');return this.convert();}var formats=this.quill.getFormat(this.quill.selection.savedRange.index);if(formats[_code2.default.blotName]){var text=this.container.innerText;this.container.innerHTML='';return new _quillDelta2.default().insert(text,_defineProperty({},_code2.default.blotName,formats[_code2.default.blotName]));}var _prepareMatching=this.prepareMatching(),_prepareMatching2=_slicedToArray(_prepareMatching,2),elementMatchers=_prepareMatching2[0],textMatchers=_prepareMatching2[1];var delta=traverse(this.container,elementMatchers,textMatchers);if(deltaEndsWith(delta,'\n')&&delta.ops[delta.ops.length-1].attributes==null){delta=delta.compose(new _quillDelta2.default().retain(delta.length()-1).delete(1));}debug.log('convert',this.container.innerHTML,delta);this.container.innerHTML='';return delta;}},{key:'dangerouslyPasteHTML',value:function dangerouslyPasteHTML(index,html){var source=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_quill2.default.sources.API;if(typeof index==='string'){return this.quill.setContents(this.convert(index),html);}else{var paste=this.convert(html);return this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste),source);}}},{key:'onPaste',value:function onPaste(e){var _this2=this;if(e.defaultPrevented||!this.quill.isEnabled())return;var range=this.quill.getSelection();var delta=new _quillDelta2.default().retain(range.index);var scrollTop=this.quill.scrollingContainer.scrollTop;this.container.focus();this.quill.selection.update(_quill2.default.sources.SILENT);setTimeout(function(){delta=delta.concat(_this2.convert()).delete(range.length);_this2.quill.updateContents(delta,_quill2.default.sources.USER);_this2.quill.setSelection(delta.length()-range.length,_quill2.default.sources.SILENT);_this2.quill.scrollingContainer.scrollTop=scrollTop;_this2.quill.focus();},1);}},{key:'prepareMatching',value:function prepareMatching(){var _this3=this;var elementMatchers=[],textMatchers=[];this.matchers.forEach(function(pair){var _pair=_slicedToArray(pair,2),selector=_pair[0],matcher=_pair[1];switch(selector){case Node.TEXT_NODE:textMatchers.push(matcher);break;case Node.ELEMENT_NODE:elementMatchers.push(matcher);break;default:[].forEach.call(_this3.container.querySelectorAll(selector),function(node){node[DOM_KEY]=node[DOM_KEY]||[];node[DOM_KEY].push(matcher);});break;}});return [elementMatchers,textMatchers];}}]);return Clipboard;}(_module2.default);Clipboard.DEFAULTS={matchers:[],matchVisual:true};function applyFormat(delta,format,value){if((typeof format==='undefined'?'undefined':_typeof(format))==='object'){return Object.keys(format).reduce(function(delta,key){return applyFormat(delta,key,format[key]);},delta);}else{return delta.reduce(function(delta,op){if(op.attributes&&op.attributes[format]){return delta.push(op);}else{return delta.insert(op.insert,_extend3.default({},_defineProperty({},format,value),op.attributes));}},new _quillDelta2.default());}}function computeStyle(node){if(node.nodeType!==Node.ELEMENT_NODE)return {};var DOM_KEY='__ql-computed-style';return node[DOM_KEY]||(node[DOM_KEY]=window.getComputedStyle(node));}function deltaEndsWith(delta,text){var endText="";for(var i=delta.ops.length-1;i>=0&&endText.length<text.length;--i){var op=delta.ops[i];if(typeof op.insert!=='string')break;endText=op.insert+endText;}return endText.slice(-1*text.length)===text;}function isLine(node){if(node.childNodes.length===0)return false;var style=computeStyle(node);return ['block','list-item'].indexOf(style.display)>-1;}function traverse(node,elementMatchers,textMatchers){if(node.nodeType===node.TEXT_NODE){return textMatchers.reduce(function(delta,matcher){return matcher(node,delta);},new _quillDelta2.default());}else if(node.nodeType===node.ELEMENT_NODE){return [].reduce.call(node.childNodes||[],function(delta,childNode){var childrenDelta=traverse(childNode,elementMatchers,textMatchers);if(childNode.nodeType===node.ELEMENT_NODE){childrenDelta=elementMatchers.reduce(function(childrenDelta,matcher){return matcher(childNode,childrenDelta);},childrenDelta);childrenDelta=(childNode[DOM_KEY]||[]).reduce(function(childrenDelta,matcher){return matcher(childNode,childrenDelta);},childrenDelta);}return delta.concat(childrenDelta);},new _quillDelta2.default());}else{return new _quillDelta2.default();}}function matchAlias(format,node,delta){return applyFormat(delta,format,true);}function matchAttributor(node,delta){var attributes=_parchment2.default.Attributor.Attribute.keys(node);var classes=_parchment2.default.Attributor.Class.keys(node);var styles=_parchment2.default.Attributor.Style.keys(node);var formats={};attributes.concat(classes).concat(styles).forEach(function(name){var attr=_parchment2.default.query(name,_parchment2.default.Scope.ATTRIBUTE);if(attr!=null){formats[attr.attrName]=attr.value(node);if(formats[attr.attrName])return;}attr=ATTRIBUTE_ATTRIBUTORS[name];if(attr!=null&&attr.attrName===name){formats[attr.attrName]=attr.value(node)||undefined;}attr=STYLE_ATTRIBUTORS[name];if(attr!=null&&attr.attrName===name){attr=STYLE_ATTRIBUTORS[name];formats[attr.attrName]=attr.value(node)||undefined;}});if(Object.keys(formats).length>0){delta=applyFormat(delta,formats);}return delta;}function matchBlot(node,delta){var match=_parchment2.default.query(node);if(match==null)return delta;if(match.prototype instanceof _parchment2.default.Embed){var embed={};var value=match.value(node);if(value!=null){embed[match.blotName]=value;delta=new _quillDelta2.default().insert(embed,match.formats(node));}}else if(typeof match.formats==='function'){delta=applyFormat(delta,match.blotName,match.formats(node));}return delta;}function matchBreak(node,delta){if(!deltaEndsWith(delta,'\n')){delta.insert('\n');}return delta;}function matchIgnore(){return new _quillDelta2.default();}function matchIndent(node,delta){var match=_parchment2.default.query(node);if(match==null||match.blotName!=='list-item'||!deltaEndsWith(delta,'\n')){return delta;}var indent=-1,parent=node.parentNode;while(!parent.classList.contains('ql-clipboard')){if((_parchment2.default.query(parent)||{}).blotName==='list'){indent+=1;}parent=parent.parentNode;}if(indent<=0)return delta;return delta.compose(new _quillDelta2.default().retain(delta.length()-1).retain(1,{indent:indent}));}function matchNewline(node,delta){if(!deltaEndsWith(delta,'\n')){if(isLine(node)||delta.length()>0&&node.nextSibling&&isLine(node.nextSibling)){delta.insert('\n');}}return delta;}function matchSpacing(node,delta){if(isLine(node)&&node.nextElementSibling!=null&&!deltaEndsWith(delta,'\n\n')){var nodeHeight=node.offsetHeight+parseFloat(computeStyle(node).marginTop)+parseFloat(computeStyle(node).marginBottom);if(node.nextElementSibling.offsetTop>node.offsetTop+nodeHeight*1.5){delta.insert('\n');}}return delta;}function matchStyles(node,delta){var formats={};var style=node.style||{};if(style.fontStyle&&computeStyle(node).fontStyle==='italic'){formats.italic=true;}if(style.fontWeight&&(computeStyle(node).fontWeight.startsWith('bold')||parseInt(computeStyle(node).fontWeight)>=700)){formats.bold=true;}if(Object.keys(formats).length>0){delta=applyFormat(delta,formats);}if(parseFloat(style.textIndent||0)>0){delta=new _quillDelta2.default().insert('\t').concat(delta);}return delta;}function matchText(node,delta){var text=node.data;if(node.parentNode.tagName==='O:P'){return delta.insert(text.trim());}if(text.trim().length===0&&node.parentNode.classList.contains('ql-clipboard')){return delta;}if(!computeStyle(node.parentNode).whiteSpace.startsWith('pre')){var replacer=function replacer(collapse,match){match=match.replace(/[^\u00a0]/g,'');return match.length<1&&collapse?' ':match;};text=text.replace(/\r\n/g,' ').replace(/\n/g,' ');text=text.replace(/\s\s+/g,replacer.bind(replacer,true));if(node.previousSibling==null&&isLine(node.parentNode)||node.previousSibling!=null&&isLine(node.previousSibling)){text=text.replace(/^\s+/,replacer.bind(replacer,false));}if(node.nextSibling==null&&isLine(node.parentNode)||node.nextSibling!=null&&isLine(node.nextSibling)){text=text.replace(/\s+$/,replacer.bind(replacer,false));}}return delta.insert(text);}exports.default=Clipboard;exports.matchAttributor=matchAttributor;exports.matchBlot=matchBlot;exports.matchNewline=matchNewline;exports.matchSpacing=matchSpacing;exports.matchText=matchText;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Bold=function(_Inline){_inherits(Bold,_Inline);function Bold(){_classCallCheck(this,Bold);return _possibleConstructorReturn(this,(Bold.__proto__||Object.getPrototypeOf(Bold)).apply(this,arguments));}_createClass(Bold,[{key:'optimize',value:function optimize(context){_get(Bold.prototype.__proto__||Object.getPrototypeOf(Bold.prototype),'optimize',this).call(this,context);if(this.domNode.tagName!==this.statics.tagName[0]){this.replaceWith(this.statics.blotName);}}}],[{key:'create',value:function create(){return _get(Bold.__proto__||Object.getPrototypeOf(Bold),'create',this).call(this);}},{key:'formats',value:function formats(){return true;}}]);return Bold;}(_inline2.default);Bold.blotName='bold';Bold.tagName=['STRONG','B'];exports.default=Bold;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.addControls=exports.default=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:toolbar');var Toolbar=function(_Module){_inherits(Toolbar,_Module);function Toolbar(quill,options){_classCallCheck(this,Toolbar);var _this=_possibleConstructorReturn(this,(Toolbar.__proto__||Object.getPrototypeOf(Toolbar)).call(this,quill,options));if(Array.isArray(_this.options.container)){var container=document.createElement('div');addControls(container,_this.options.container);quill.container.parentNode.insertBefore(container,quill.container);_this.container=container;}else if(typeof _this.options.container==='string'){_this.container=document.querySelector(_this.options.container);}else{_this.container=_this.options.container;}if(!(_this.container instanceof HTMLElement)){var _ret;return _ret=debug.error('Container required for toolbar',_this.options),_possibleConstructorReturn(_this,_ret);}_this.container.classList.add('ql-toolbar');_this.controls=[];_this.handlers={};Object.keys(_this.options.handlers).forEach(function(format){_this.addHandler(format,_this.options.handlers[format]);});[].forEach.call(_this.container.querySelectorAll('button, select'),function(input){_this.attach(input);});_this.quill.on(_quill2.default.events.EDITOR_CHANGE,function(type,range){if(type===_quill2.default.events.SELECTION_CHANGE){_this.update(range);}});_this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE,function(){var _this$quill$selection=_this.quill.selection.getRange(),_this$quill$selection2=_slicedToArray(_this$quill$selection,1),range=_this$quill$selection2[0];_this.update(range);});return _this;}_createClass(Toolbar,[{key:'addHandler',value:function addHandler(format,handler){this.handlers[format]=handler;}},{key:'attach',value:function attach(input){var _this2=this;var format=[].find.call(input.classList,function(className){return className.indexOf('ql-')===0;});if(!format)return;format=format.slice('ql-'.length);if(input.tagName==='BUTTON'){input.setAttribute('type','button');}if(this.handlers[format]==null){if(this.quill.scroll.whitelist!=null&&this.quill.scroll.whitelist[format]==null){debug.warn('ignoring attaching to disabled format',format,input);return;}if(_parchment2.default.query(format)==null){debug.warn('ignoring attaching to nonexistent format',format,input);return;}}var eventName=input.tagName==='SELECT'?'change':'click';input.addEventListener(eventName,function(e){var value=void 0;if(input.tagName==='SELECT'){if(input.selectedIndex<0)return;var selected=input.options[input.selectedIndex];if(selected.hasAttribute('selected')){value=false;}else{value=selected.value||false;}}else{if(input.classList.contains('ql-active')){value=false;}else{value=input.value||!input.hasAttribute('value');}e.preventDefault();}_this2.quill.focus();var _quill$selection$getR=_this2.quill.selection.getRange(),_quill$selection$getR2=_slicedToArray(_quill$selection$getR,1),range=_quill$selection$getR2[0];if(_this2.handlers[format]!=null){_this2.handlers[format].call(_this2,value);}else if(_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed){value=prompt('Enter '+format);if(!value)return;_this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({},format,value)),_quill2.default.sources.USER);}else{_this2.quill.format(format,value,_quill2.default.sources.USER);}_this2.update(range);});this.controls.push([format,input]);}},{key:'update',value:function update(range){var formats=range==null?{}:this.quill.getFormat(range);this.controls.forEach(function(pair){var _pair=_slicedToArray(pair,2),format=_pair[0],input=_pair[1];if(input.tagName==='SELECT'){var option=void 0;if(range==null){option=null;}else if(formats[format]==null){option=input.querySelector('option[selected]');}else if(!Array.isArray(formats[format])){var value=formats[format];if(typeof value==='string'){value=value.replace(/\"/g,'\\"');}option=input.querySelector('option[value="'+value+'"]');}if(option==null){input.value='';input.selectedIndex=-1;}else{option.selected=true;}}else{if(range==null){input.classList.remove('ql-active');}else if(input.hasAttribute('value')){var isActive=formats[format]===input.getAttribute('value')||formats[format]!=null&&formats[format].toString()===input.getAttribute('value')||formats[format]==null&&!input.getAttribute('value');input.classList.toggle('ql-active',isActive);}else{input.classList.toggle('ql-active',formats[format]!=null);}}});}}]);return Toolbar;}(_module2.default);Toolbar.DEFAULTS={};function addButton(container,format,value){var input=document.createElement('button');input.setAttribute('type','button');input.classList.add('ql-'+format);if(value!=null){input.value=value;}container.appendChild(input);}function addControls(container,groups){if(!Array.isArray(groups[0])){groups=[groups];}groups.forEach(function(controls){var group=document.createElement('span');group.classList.add('ql-formats');controls.forEach(function(control){if(typeof control==='string'){addButton(group,control);}else{var format=Object.keys(control)[0];var value=control[format];if(Array.isArray(value)){addSelect(group,format,value);}else{addButton(group,format,value);}}});container.appendChild(group);});}function addSelect(container,format,values){var input=document.createElement('select');input.classList.add('ql-'+format);values.forEach(function(value){var option=document.createElement('option');if(value!==false){option.setAttribute('value',value);}else{option.setAttribute('selected','selected');}input.appendChild(option);});container.appendChild(input);}Toolbar.DEFAULTS={container:null,handlers:{clean:function clean(){var _this3=this;var range=this.quill.getSelection();if(range==null)return;if(range.length==0){var formats=this.quill.getFormat();Object.keys(formats).forEach(function(name){if(_parchment2.default.query(name,_parchment2.default.Scope.INLINE)!=null){_this3.quill.format(name,false);}});}else{this.quill.removeFormat(range,_quill2.default.sources.USER);}},direction:function direction(value){var align=this.quill.getFormat()['align'];if(value==='rtl'&&align==null){this.quill.format('align','right',_quill2.default.sources.USER);}else if(!value&&align==='right'){this.quill.format('align',false,_quill2.default.sources.USER);}this.quill.format('direction',value,_quill2.default.sources.USER);},indent:function indent(value){var range=this.quill.getSelection();var formats=this.quill.getFormat(range);var indent=parseInt(formats.indent||0);if(value==='+1'||value==='-1'){var modifier=value==='+1'?1:-1;if(formats.direction==='rtl')modifier*=-1;this.quill.format('indent',indent+modifier,_quill2.default.sources.USER);}},link:function link(value){if(value===true){value=prompt('Enter link URL:');}this.quill.format('link',value,_quill2.default.sources.USER);},list:function list(value){var range=this.quill.getSelection();var formats=this.quill.getFormat(range);if(value==='check'){if(formats['list']==='checked'||formats['list']==='unchecked'){this.quill.format('list',false,_quill2.default.sources.USER);}else{this.quill.format('list','unchecked',_quill2.default.sources.USER);}}else{this.quill.format('list',value,_quill2.default.sources.USER);}}}};exports.default=Toolbar;exports.addControls=addControls;},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ColorPicker=function(_Picker){_inherits(ColorPicker,_Picker);function ColorPicker(select,label){_classCallCheck(this,ColorPicker);var _this=_possibleConstructorReturn(this,(ColorPicker.__proto__||Object.getPrototypeOf(ColorPicker)).call(this,select));_this.label.innerHTML=label;_this.container.classList.add('ql-color-picker');[].slice.call(_this.container.querySelectorAll('.ql-picker-item'),0,7).forEach(function(item){item.classList.add('ql-primary');});return _this;}_createClass(ColorPicker,[{key:'buildItem',value:function buildItem(option){var item=_get(ColorPicker.prototype.__proto__||Object.getPrototypeOf(ColorPicker.prototype),'buildItem',this).call(this,option);item.style.backgroundColor=option.getAttribute('value')||'';return item;}},{key:'selectItem',value:function selectItem(item,trigger){_get(ColorPicker.prototype.__proto__||Object.getPrototypeOf(ColorPicker.prototype),'selectItem',this).call(this,item,trigger);var colorLabel=this.label.querySelector('.ql-color-label');var value=item?item.getAttribute('data-value')||'':'';if(colorLabel){if(colorLabel.tagName==='line'){colorLabel.style.stroke=value;}else{colorLabel.style.fill=value;}}}}]);return ColorPicker;}(_picker2.default);exports.default=ColorPicker;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var IconPicker=function(_Picker){_inherits(IconPicker,_Picker);function IconPicker(select,icons){_classCallCheck(this,IconPicker);var _this=_possibleConstructorReturn(this,(IconPicker.__proto__||Object.getPrototypeOf(IconPicker)).call(this,select));_this.container.classList.add('ql-icon-picker');[].forEach.call(_this.container.querySelectorAll('.ql-picker-item'),function(item){item.innerHTML=icons[item.getAttribute('data-value')||''];});_this.defaultItem=_this.container.querySelector('.ql-selected');_this.selectItem(_this.defaultItem);return _this;}_createClass(IconPicker,[{key:'selectItem',value:function selectItem(item,trigger){_get(IconPicker.prototype.__proto__||Object.getPrototypeOf(IconPicker.prototype),'selectItem',this).call(this,item,trigger);item=item||this.defaultItem;this.label.innerHTML=item.innerHTML;}}]);return IconPicker;}(_picker2.default);exports.default=IconPicker;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Tooltip=function(){function Tooltip(quill,boundsContainer){var _this=this;_classCallCheck(this,Tooltip);this.quill=quill;this.boundsContainer=boundsContainer||document.body;this.root=quill.addContainer('ql-tooltip');this.root.innerHTML=this.constructor.TEMPLATE;if(this.quill.root===this.quill.scrollingContainer){this.quill.root.addEventListener('scroll',function(){_this.root.style.marginTop=-1*_this.quill.root.scrollTop+'px';});}this.hide();}_createClass(Tooltip,[{key:'hide',value:function hide(){this.root.classList.add('ql-hidden');}},{key:'position',value:function position(reference){var left=reference.left+reference.width/2-this.root.offsetWidth/2;var top=reference.bottom+this.quill.root.scrollTop;this.root.style.left=left+'px';this.root.style.top=top+'px';this.root.classList.remove('ql-flip');var containerBounds=this.boundsContainer.getBoundingClientRect();var rootBounds=this.root.getBoundingClientRect();var shift=0;if(rootBounds.right>containerBounds.right){shift=containerBounds.right-rootBounds.right;this.root.style.left=left+shift+'px';}if(rootBounds.left<containerBounds.left){shift=containerBounds.left-rootBounds.left;this.root.style.left=left+shift+'px';}if(rootBounds.bottom>containerBounds.bottom){var height=rootBounds.bottom-rootBounds.top;var verticalShift=reference.bottom-reference.top+height;this.root.style.top=top-verticalShift+'px';this.root.classList.add('ql-flip');}return shift;}},{key:'show',value:function show(){this.root.classList.remove('ql-editing');this.root.classList.remove('ql-hidden');}}]);return Tooltip;}();exports.default=Tooltip;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _base=__webpack_require__(43);var _base2=_interopRequireDefault(_base);var _link=__webpack_require__(27);var _link2=_interopRequireDefault(_link);var _selection=__webpack_require__(15);var _icons=__webpack_require__(41);var _icons2=_interopRequireDefault(_icons);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var TOOLBAR_CONFIG=[[{header:['1','2','3',false]}],['bold','italic','underline','link'],[{list:'ordered'},{list:'bullet'}],['clean']];var SnowTheme=function(_BaseTheme){_inherits(SnowTheme,_BaseTheme);function SnowTheme(quill,options){_classCallCheck(this,SnowTheme);if(options.modules.toolbar!=null&&options.modules.toolbar.container==null){options.modules.toolbar.container=TOOLBAR_CONFIG;}var _this=_possibleConstructorReturn(this,(SnowTheme.__proto__||Object.getPrototypeOf(SnowTheme)).call(this,quill,options));_this.quill.container.classList.add('ql-snow');return _this;}_createClass(SnowTheme,[{key:'extendToolbar',value:function extendToolbar(toolbar){toolbar.container.classList.add('ql-snow');this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')),_icons2.default);this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')),_icons2.default);this.tooltip=new SnowTooltip(this.quill,this.options.bounds);if(toolbar.container.querySelector('.ql-link')){this.quill.keyboard.addBinding({key:'K',shortKey:true},function(range,context){toolbar.handlers['link'].call(toolbar,!context.format.link);});}}}]);return SnowTheme;}(_base2.default);SnowTheme.DEFAULTS=_extend2.default(true,{},_base2.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function link(value){if(value){var range=this.quill.getSelection();if(range==null||range.length==0)return;var preview=this.quill.getText(range);if(/^\S+@\S+\.\S+$/.test(preview)&&preview.indexOf('mailto:')!==0){preview='mailto:'+preview;}var tooltip=this.quill.theme.tooltip;tooltip.edit('link',preview);}else{this.quill.format('link',false);}}}}}});var SnowTooltip=function(_BaseTooltip){_inherits(SnowTooltip,_BaseTooltip);function SnowTooltip(quill,bounds){_classCallCheck(this,SnowTooltip);var _this2=_possibleConstructorReturn(this,(SnowTooltip.__proto__||Object.getPrototypeOf(SnowTooltip)).call(this,quill,bounds));_this2.preview=_this2.root.querySelector('a.ql-preview');return _this2;}_createClass(SnowTooltip,[{key:'listen',value:function listen(){var _this3=this;_get(SnowTooltip.prototype.__proto__||Object.getPrototypeOf(SnowTooltip.prototype),'listen',this).call(this);this.root.querySelector('a.ql-action').addEventListener('click',function(event){if(_this3.root.classList.contains('ql-editing')){_this3.save();}else{_this3.edit('link',_this3.preview.textContent);}event.preventDefault();});this.root.querySelector('a.ql-remove').addEventListener('click',function(event){if(_this3.linkRange!=null){var range=_this3.linkRange;_this3.restoreFocus();_this3.quill.formatText(range,'link',false,_emitter2.default.sources.USER);delete _this3.linkRange;}event.preventDefault();_this3.hide();});this.quill.on(_emitter2.default.events.SELECTION_CHANGE,function(range,oldRange,source){if(range==null)return;if(range.length===0&&source===_emitter2.default.sources.USER){var _quill$scroll$descend=_this3.quill.scroll.descendant(_link2.default,range.index),_quill$scroll$descend2=_slicedToArray(_quill$scroll$descend,2),link=_quill$scroll$descend2[0],offset=_quill$scroll$descend2[1];if(link!=null){_this3.linkRange=new _selection.Range(range.index-offset,link.length());var preview=_link2.default.formats(link.domNode);_this3.preview.textContent=preview;_this3.preview.setAttribute('href',preview);_this3.show();_this3.position(_this3.quill.getBounds(_this3.linkRange));return;}}else{delete _this3.linkRange;}_this3.hide();});}},{key:'show',value:function show(){_get(SnowTooltip.prototype.__proto__||Object.getPrototypeOf(SnowTooltip.prototype),'show',this).call(this);this.root.removeAttribute('data-mode');}}]);return SnowTooltip;}(_base.BaseTooltip);SnowTooltip.TEMPLATE=['<a class="ql-preview" target="_blank" href="about:blank"></a>','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-action"></a>','<a class="ql-remove"></a>'].join('');exports.default=SnowTheme;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _core=__webpack_require__(29);var _core2=_interopRequireDefault(_core);var _align=__webpack_require__(36);var _direction=__webpack_require__(38);var _indent=__webpack_require__(64);var _blockquote=__webpack_require__(65);var _blockquote2=_interopRequireDefault(_blockquote);var _header=__webpack_require__(66);var _header2=_interopRequireDefault(_header);var _list=__webpack_require__(67);var _list2=_interopRequireDefault(_list);var _background=__webpack_require__(37);var _color=__webpack_require__(26);var _font=__webpack_require__(39);var _size=__webpack_require__(40);var _bold=__webpack_require__(56);var _bold2=_interopRequireDefault(_bold);var _italic=__webpack_require__(68);var _italic2=_interopRequireDefault(_italic);var _link=__webpack_require__(27);var _link2=_interopRequireDefault(_link);var _script=__webpack_require__(69);var _script2=_interopRequireDefault(_script);var _strike=__webpack_require__(70);var _strike2=_interopRequireDefault(_strike);var _underline=__webpack_require__(71);var _underline2=_interopRequireDefault(_underline);var _image=__webpack_require__(72);var _image2=_interopRequireDefault(_image);var _video=__webpack_require__(73);var _video2=_interopRequireDefault(_video);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _formula=__webpack_require__(74);var _formula2=_interopRequireDefault(_formula);var _syntax=__webpack_require__(75);var _syntax2=_interopRequireDefault(_syntax);var _toolbar=__webpack_require__(57);var _toolbar2=_interopRequireDefault(_toolbar);var _icons=__webpack_require__(41);var _icons2=_interopRequireDefault(_icons);var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);var _colorPicker=__webpack_require__(59);var _colorPicker2=_interopRequireDefault(_colorPicker);var _iconPicker=__webpack_require__(60);var _iconPicker2=_interopRequireDefault(_iconPicker);var _tooltip=__webpack_require__(61);var _tooltip2=_interopRequireDefault(_tooltip);var _bubble=__webpack_require__(108);var _bubble2=_interopRequireDefault(_bubble);var _snow=__webpack_require__(62);var _snow2=_interopRequireDefault(_snow);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}_core2.default.register({'attributors/attribute/direction':_direction.DirectionAttribute,'attributors/class/align':_align.AlignClass,'attributors/class/background':_background.BackgroundClass,'attributors/class/color':_color.ColorClass,'attributors/class/direction':_direction.DirectionClass,'attributors/class/font':_font.FontClass,'attributors/class/size':_size.SizeClass,'attributors/style/align':_align.AlignStyle,'attributors/style/background':_background.BackgroundStyle,'attributors/style/color':_color.ColorStyle,'attributors/style/direction':_direction.DirectionStyle,'attributors/style/font':_font.FontStyle,'attributors/style/size':_size.SizeStyle},true);_core2.default.register({'formats/align':_align.AlignClass,'formats/direction':_direction.DirectionClass,'formats/indent':_indent.IndentClass,'formats/background':_background.BackgroundStyle,'formats/color':_color.ColorStyle,'formats/font':_font.FontClass,'formats/size':_size.SizeClass,'formats/blockquote':_blockquote2.default,'formats/code-block':_code2.default,'formats/header':_header2.default,'formats/list':_list2.default,'formats/bold':_bold2.default,'formats/code':_code.Code,'formats/italic':_italic2.default,'formats/link':_link2.default,'formats/script':_script2.default,'formats/strike':_strike2.default,'formats/underline':_underline2.default,'formats/image':_image2.default,'formats/video':_video2.default,'formats/list/item':_list.ListItem,'modules/formula':_formula2.default,'modules/syntax':_syntax2.default,'modules/toolbar':_toolbar2.default,'themes/bubble':_bubble2.default,'themes/snow':_snow2.default,'ui/icons':_icons2.default,'ui/picker':_picker2.default,'ui/icon-picker':_iconPicker2.default,'ui/color-picker':_colorPicker2.default,'ui/tooltip':_tooltip2.default},true);exports.default=_core2.default;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.IndentClass=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var IdentAttributor=function(_Parchment$Attributor){_inherits(IdentAttributor,_Parchment$Attributor);function IdentAttributor(){_classCallCheck(this,IdentAttributor);return _possibleConstructorReturn(this,(IdentAttributor.__proto__||Object.getPrototypeOf(IdentAttributor)).apply(this,arguments));}_createClass(IdentAttributor,[{key:'add',value:function add(node,value){if(value==='+1'||value==='-1'){var indent=this.value(node)||0;value=value==='+1'?indent+1:indent-1;}if(value===0){this.remove(node);return true;}else{return _get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'add',this).call(this,node,value);}}},{key:'canAdd',value:function canAdd(node,value){return _get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'canAdd',this).call(this,node,value)||_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'canAdd',this).call(this,node,parseInt(value));}},{key:'value',value:function value(node){return parseInt(_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'value',this).call(this,node))||undefined;}}]);return IdentAttributor;}(_parchment2.default.Attributor.Class);var IndentClass=new IdentAttributor('indent','ql-indent',{scope:_parchment2.default.Scope.BLOCK,whitelist:[1,2,3,4,5,6,7,8]});exports.IndentClass=IndentClass;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Blockquote=function(_Block){_inherits(Blockquote,_Block);function Blockquote(){_classCallCheck(this,Blockquote);return _possibleConstructorReturn(this,(Blockquote.__proto__||Object.getPrototypeOf(Blockquote)).apply(this,arguments));}return Blockquote;}(_block2.default);Blockquote.blotName='blockquote';Blockquote.tagName='blockquote';exports.default=Blockquote;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Header=function(_Block){_inherits(Header,_Block);function Header(){_classCallCheck(this,Header);return _possibleConstructorReturn(this,(Header.__proto__||Object.getPrototypeOf(Header)).apply(this,arguments));}_createClass(Header,null,[{key:'formats',value:function formats(domNode){return this.tagName.indexOf(domNode.tagName)+1;}}]);return Header;}(_block2.default);Header.blotName='header';Header.tagName=['H1','H2','H3','H4','H5','H6'];exports.default=Header;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.ListItem=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _container=__webpack_require__(24);var _container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ListItem=function(_Block){_inherits(ListItem,_Block);function ListItem(){_classCallCheck(this,ListItem);return _possibleConstructorReturn(this,(ListItem.__proto__||Object.getPrototypeOf(ListItem)).apply(this,arguments));}_createClass(ListItem,[{key:'format',value:function format(name,value){if(name===List.blotName&&!value){this.replaceWith(_parchment2.default.create(this.statics.scope));}else{_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),'format',this).call(this,name,value);}}},{key:'remove',value:function remove(){if(this.prev==null&&this.next==null){this.parent.remove();}else{_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),'remove',this).call(this);}}},{key:'replaceWith',value:function replaceWith(name,value){this.parent.isolate(this.offset(this.parent),this.length());if(name===this.parent.statics.blotName){this.parent.replaceWith(name,value);return this;}else{this.parent.unwrap();return _get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),'replaceWith',this).call(this,name,value);}}}],[{key:'formats',value:function formats(domNode){return domNode.tagName===this.tagName?undefined:_get(ListItem.__proto__||Object.getPrototypeOf(ListItem),'formats',this).call(this,domNode);}}]);return ListItem;}(_block2.default);ListItem.blotName='list-item';ListItem.tagName='LI';var List=function(_Container){_inherits(List,_Container);_createClass(List,null,[{key:'create',value:function create(value){var tagName=value==='ordered'?'OL':'UL';var node=_get(List.__proto__||Object.getPrototypeOf(List),'create',this).call(this,tagName);if(value==='checked'||value==='unchecked'){node.setAttribute('data-checked',value==='checked');}return node;}},{key:'formats',value:function formats(domNode){if(domNode.tagName==='OL')return 'ordered';if(domNode.tagName==='UL'){if(domNode.hasAttribute('data-checked')){return domNode.getAttribute('data-checked')==='true'?'checked':'unchecked';}else{return 'bullet';}}return undefined;}}]);function List(domNode){_classCallCheck(this,List);var _this2=_possibleConstructorReturn(this,(List.__proto__||Object.getPrototypeOf(List)).call(this,domNode));var listEventHandler=function listEventHandler(e){if(e.target.parentNode!==domNode)return;var format=_this2.statics.formats(domNode);var blot=_parchment2.default.find(e.target);if(format==='checked'){blot.format('list','unchecked');}else if(format==='unchecked'){blot.format('list','checked');}};domNode.addEventListener('touchstart',listEventHandler);domNode.addEventListener('mousedown',listEventHandler);return _this2;}_createClass(List,[{key:'format',value:function format(name,value){if(this.children.length>0){this.children.tail.format(name,value);}}},{key:'formats',value:function formats(){return _defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot instanceof ListItem){_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),'insertBefore',this).call(this,blot,ref);}else{var index=ref==null?this.length():ref.offset(this);var after=this.split(index);after.parent.insertBefore(blot,after);}}},{key:'optimize',value:function optimize(context){_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),'optimize',this).call(this,context);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName&&next.domNode.getAttribute('data-checked')===this.domNode.getAttribute('data-checked')){next.moveChildren(this);next.remove();}}},{key:'replace',value:function replace(target){if(target.statics.blotName!==this.statics.blotName){var item=_parchment2.default.create(this.statics.defaultChild);target.moveChildren(item);this.appendChild(item);}_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),'replace',this).call(this,target);}}]);return List;}(_container2.default);List.blotName='list';List.scope=_parchment2.default.Scope.BLOCK_BLOT;List.tagName=['OL','UL'];List.defaultChild='list-item';List.allowedChildren=[ListItem];exports.ListItem=ListItem;exports.default=List;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _bold=__webpack_require__(56);var _bold2=_interopRequireDefault(_bold);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Italic=function(_Bold){_inherits(Italic,_Bold);function Italic(){_classCallCheck(this,Italic);return _possibleConstructorReturn(this,(Italic.__proto__||Object.getPrototypeOf(Italic)).apply(this,arguments));}return Italic;}(_bold2.default);Italic.blotName='italic';Italic.tagName=['EM','I'];exports.default=Italic;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Script=function(_Inline){_inherits(Script,_Inline);function Script(){_classCallCheck(this,Script);return _possibleConstructorReturn(this,(Script.__proto__||Object.getPrototypeOf(Script)).apply(this,arguments));}_createClass(Script,null,[{key:'create',value:function create(value){if(value==='super'){return document.createElement('sup');}else if(value==='sub'){return document.createElement('sub');}else{return _get(Script.__proto__||Object.getPrototypeOf(Script),'create',this).call(this,value);}}},{key:'formats',value:function formats(domNode){if(domNode.tagName==='SUB')return 'sub';if(domNode.tagName==='SUP')return 'super';return undefined;}}]);return Script;}(_inline2.default);Script.blotName='script';Script.tagName=['SUB','SUP'];exports.default=Script;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Strike=function(_Inline){_inherits(Strike,_Inline);function Strike(){_classCallCheck(this,Strike);return _possibleConstructorReturn(this,(Strike.__proto__||Object.getPrototypeOf(Strike)).apply(this,arguments));}return Strike;}(_inline2.default);Strike.blotName='strike';Strike.tagName='S';exports.default=Strike;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Underline=function(_Inline){_inherits(Underline,_Inline);function Underline(){_classCallCheck(this,Underline);return _possibleConstructorReturn(this,(Underline.__proto__||Object.getPrototypeOf(Underline)).apply(this,arguments));}return Underline;}(_inline2.default);Underline.blotName='underline';Underline.tagName='U';exports.default=Underline;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _link=__webpack_require__(27);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ATTRIBUTES=['alt','height','width'];var Image=function(_Parchment$Embed){_inherits(Image,_Parchment$Embed);function Image(){_classCallCheck(this,Image);return _possibleConstructorReturn(this,(Image.__proto__||Object.getPrototypeOf(Image)).apply(this,arguments));}_createClass(Image,[{key:'format',value:function format(name,value){if(ATTRIBUTES.indexOf(name)>-1){if(value){this.domNode.setAttribute(name,value);}else{this.domNode.removeAttribute(name);}}else{_get(Image.prototype.__proto__||Object.getPrototypeOf(Image.prototype),'format',this).call(this,name,value);}}}],[{key:'create',value:function create(value){var node=_get(Image.__proto__||Object.getPrototypeOf(Image),'create',this).call(this,value);if(typeof value==='string'){node.setAttribute('src',this.sanitize(value));}return node;}},{key:'formats',value:function formats(domNode){return ATTRIBUTES.reduce(function(formats,attribute){if(domNode.hasAttribute(attribute)){formats[attribute]=domNode.getAttribute(attribute);}return formats;},{});}},{key:'match',value:function match(url){return /\.(jpe?g|gif|png)$/.test(url)||/^data:image\/.+;base64/.test(url);}},{key:'sanitize',value:function sanitize(url){return _link.sanitize(url,['http','https','data'])?url:'//:0';}},{key:'value',value:function value(domNode){return domNode.getAttribute('src');}}]);return Image;}(_parchment2.default.Embed);Image.blotName='image';Image.tagName='IMG';exports.default=Image;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _block=__webpack_require__(4);var _link=__webpack_require__(27);var _link2=_interopRequireDefault(_link);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ATTRIBUTES=['height','width'];var Video=function(_BlockEmbed){_inherits(Video,_BlockEmbed);function Video(){_classCallCheck(this,Video);return _possibleConstructorReturn(this,(Video.__proto__||Object.getPrototypeOf(Video)).apply(this,arguments));}_createClass(Video,[{key:'format',value:function format(name,value){if(ATTRIBUTES.indexOf(name)>-1){if(value){this.domNode.setAttribute(name,value);}else{this.domNode.removeAttribute(name);}}else{_get(Video.prototype.__proto__||Object.getPrototypeOf(Video.prototype),'format',this).call(this,name,value);}}}],[{key:'create',value:function create(value){var node=_get(Video.__proto__||Object.getPrototypeOf(Video),'create',this).call(this,value);node.setAttribute('frameborder','0');node.setAttribute('allowfullscreen',true);node.setAttribute('src',this.sanitize(value));return node;}},{key:'formats',value:function formats(domNode){return ATTRIBUTES.reduce(function(formats,attribute){if(domNode.hasAttribute(attribute)){formats[attribute]=domNode.getAttribute(attribute);}return formats;},{});}},{key:'sanitize',value:function sanitize(url){return _link2.default.sanitize(url);}},{key:'value',value:function value(domNode){return domNode.getAttribute('src');}}]);return Video;}(_block.BlockEmbed);Video.blotName='video';Video.className='ql-video';Video.tagName='IFRAME';exports.default=Video;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.FormulaBlot=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _embed=__webpack_require__(25);var _embed2=_interopRequireDefault(_embed);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var FormulaBlot=function(_Embed){_inherits(FormulaBlot,_Embed);function FormulaBlot(){_classCallCheck(this,FormulaBlot);return _possibleConstructorReturn(this,(FormulaBlot.__proto__||Object.getPrototypeOf(FormulaBlot)).apply(this,arguments));}_createClass(FormulaBlot,null,[{key:'create',value:function create(value){var node=_get(FormulaBlot.__proto__||Object.getPrototypeOf(FormulaBlot),'create',this).call(this,value);if(typeof value==='string'){window.katex.render(value,node,{throwOnError:false,errorColor:'#f00'});node.setAttribute('data-value',value);}return node;}},{key:'value',value:function value(domNode){return domNode.getAttribute('data-value');}}]);return FormulaBlot;}(_embed2.default);FormulaBlot.blotName='formula';FormulaBlot.className='ql-formula';FormulaBlot.tagName='SPAN';var Formula=function(_Module){_inherits(Formula,_Module);_createClass(Formula,null,[{key:'register',value:function register(){_quill2.default.register(FormulaBlot,true);}}]);function Formula(){_classCallCheck(this,Formula);var _this2=_possibleConstructorReturn(this,(Formula.__proto__||Object.getPrototypeOf(Formula)).call(this));if(window.katex==null){throw new Error('Formula module requires KaTeX.');}return _this2;}return Formula;}(_module2.default);exports.FormulaBlot=FormulaBlot;exports.default=Formula;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.CodeToken=exports.CodeBlock=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var SyntaxCodeBlock=function(_CodeBlock){_inherits(SyntaxCodeBlock,_CodeBlock);function SyntaxCodeBlock(){_classCallCheck(this,SyntaxCodeBlock);return _possibleConstructorReturn(this,(SyntaxCodeBlock.__proto__||Object.getPrototypeOf(SyntaxCodeBlock)).apply(this,arguments));}_createClass(SyntaxCodeBlock,[{key:'replaceWith',value:function replaceWith(block){this.domNode.textContent=this.domNode.textContent;this.attach();_get(SyntaxCodeBlock.prototype.__proto__||Object.getPrototypeOf(SyntaxCodeBlock.prototype),'replaceWith',this).call(this,block);}},{key:'highlight',value:function highlight(_highlight){var text=this.domNode.textContent;if(this.cachedText!==text){if(text.trim().length>0||this.cachedText==null){this.domNode.innerHTML=_highlight(text);this.domNode.normalize();this.attach();}this.cachedText=text;}}}]);return SyntaxCodeBlock;}(_code2.default);SyntaxCodeBlock.className='ql-syntax';var CodeToken=new _parchment2.default.Attributor.Class('token','hljs',{scope:_parchment2.default.Scope.INLINE});var Syntax=function(_Module){_inherits(Syntax,_Module);_createClass(Syntax,null,[{key:'register',value:function register(){_quill2.default.register(CodeToken,true);_quill2.default.register(SyntaxCodeBlock,true);}}]);function Syntax(quill,options){_classCallCheck(this,Syntax);var _this2=_possibleConstructorReturn(this,(Syntax.__proto__||Object.getPrototypeOf(Syntax)).call(this,quill,options));if(typeof _this2.options.highlight!=='function'){throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');}var timer=null;_this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE,function(){clearTimeout(timer);timer=setTimeout(function(){_this2.highlight();timer=null;},_this2.options.interval);});_this2.highlight();return _this2;}_createClass(Syntax,[{key:'highlight',value:function highlight(){var _this3=this;if(this.quill.selection.composing)return;this.quill.update(_quill2.default.sources.USER);var range=this.quill.getSelection();this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code){code.highlight(_this3.options.highlight);});this.quill.update(_quill2.default.sources.SILENT);if(range!=null){this.quill.setSelection(range,_quill2.default.sources.SILENT);}}}]);return Syntax;}(_module2.default);Syntax.DEFAULTS={highlight:function(){if(window.hljs==null)return null;return function(text){var result=window.hljs.highlightAuto(text);return result.value;};}(),interval:1000};exports.CodeBlock=SyntaxCodeBlock;exports.CodeToken=CodeToken;exports.default=Syntax;},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";},function(module,exports){module.exports="<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";},function(module,exports){module.exports="<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";},function(module,exports){module.exports="<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";},function(module,exports){module.exports="<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.BubbleTooltip=undefined;var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _base=__webpack_require__(43);var _base2=_interopRequireDefault(_base);var _selection=__webpack_require__(15);var _icons=__webpack_require__(41);var _icons2=_interopRequireDefault(_icons);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var TOOLBAR_CONFIG=[['bold','italic','link'],[{header:1},{header:2},'blockquote']];var BubbleTheme=function(_BaseTheme){_inherits(BubbleTheme,_BaseTheme);function BubbleTheme(quill,options){_classCallCheck(this,BubbleTheme);if(options.modules.toolbar!=null&&options.modules.toolbar.container==null){options.modules.toolbar.container=TOOLBAR_CONFIG;}var _this=_possibleConstructorReturn(this,(BubbleTheme.__proto__||Object.getPrototypeOf(BubbleTheme)).call(this,quill,options));_this.quill.container.classList.add('ql-bubble');return _this;}_createClass(BubbleTheme,[{key:'extendToolbar',value:function extendToolbar(toolbar){this.tooltip=new BubbleTooltip(this.quill,this.options.bounds);this.tooltip.root.appendChild(toolbar.container);this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')),_icons2.default);this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')),_icons2.default);}}]);return BubbleTheme;}(_base2.default);BubbleTheme.DEFAULTS=_extend2.default(true,{},_base2.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function link(value){if(!value){this.quill.format('link',false);}else{this.quill.theme.tooltip.edit();}}}}}});var BubbleTooltip=function(_BaseTooltip){_inherits(BubbleTooltip,_BaseTooltip);function BubbleTooltip(quill,bounds){_classCallCheck(this,BubbleTooltip);var _this2=_possibleConstructorReturn(this,(BubbleTooltip.__proto__||Object.getPrototypeOf(BubbleTooltip)).call(this,quill,bounds));_this2.quill.on(_emitter2.default.events.EDITOR_CHANGE,function(type,range,oldRange,source){if(type!==_emitter2.default.events.SELECTION_CHANGE)return;if(range!=null&&range.length>0&&source===_emitter2.default.sources.USER){_this2.show();_this2.root.style.left='0px';_this2.root.style.width='';_this2.root.style.width=_this2.root.offsetWidth+'px';var lines=_this2.quill.getLines(range.index,range.length);if(lines.length===1){_this2.position(_this2.quill.getBounds(range));}else{var lastLine=lines[lines.length-1];var index=_this2.quill.getIndex(lastLine);var length=Math.min(lastLine.length()-1,range.index+range.length-index);var _bounds=_this2.quill.getBounds(new _selection.Range(index,length));_this2.position(_bounds);}}else if(document.activeElement!==_this2.textbox&&_this2.quill.hasFocus()){_this2.hide();}});return _this2;}_createClass(BubbleTooltip,[{key:'listen',value:function listen(){var _this3=this;_get(BubbleTooltip.prototype.__proto__||Object.getPrototypeOf(BubbleTooltip.prototype),'listen',this).call(this);this.root.querySelector('.ql-close').addEventListener('click',function(){_this3.root.classList.remove('ql-editing');});this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE,function(){setTimeout(function(){if(_this3.root.classList.contains('ql-hidden'))return;var range=_this3.quill.getSelection();if(range!=null){_this3.position(_this3.quill.getBounds(range));}},1);});}},{key:'cancel',value:function cancel(){this.show();}},{key:'position',value:function position(reference){var shift=_get(BubbleTooltip.prototype.__proto__||Object.getPrototypeOf(BubbleTooltip.prototype),'position',this).call(this,reference);var arrow=this.root.querySelector('.ql-tooltip-arrow');arrow.style.marginLeft='';if(shift===0)return shift;arrow.style.marginLeft=-1*shift-arrow.offsetWidth/2+'px';}}]);return BubbleTooltip;}(_base.BaseTooltip);BubbleTooltip.TEMPLATE=['<span class="ql-tooltip-arrow"></span>','<div class="ql-tooltip-editor">','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-close"></a>','</div>'].join('');exports.BubbleTooltip=BubbleTooltip;exports.default=BubbleTheme;},function(module,exports,__webpack_require__){module.exports=__webpack_require__(63);}])["default"];});});var Quill$1=unwrapExports(quill);var classCallCheck$1=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}};var createClass$1=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var defineProperty=function(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;};var get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var inherits=function(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;};var possibleConstructorReturn=function(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;};var Inline=Quill$1.import('blots/inline');var BoldBlot=function(_Inline){inherits(BoldBlot,_Inline);function BoldBlot(){classCallCheck$1(this,BoldBlot);return possibleConstructorReturn(this,(BoldBlot.__proto__||Object.getPrototypeOf(BoldBlot)).apply(this,arguments));}return BoldBlot;}(Inline);BoldBlot.blotName='bold';BoldBlot.tagName='b';var Inline$1=Quill$1.import('blots/inline');var ItalicBlot=function(_Inline){inherits(ItalicBlot,_Inline);function ItalicBlot(){classCallCheck$1(this,ItalicBlot);return possibleConstructorReturn(this,(ItalicBlot.__proto__||Object.getPrototypeOf(ItalicBlot)).apply(this,arguments));}return ItalicBlot;}(Inline$1);ItalicBlot.blotName='italic';ItalicBlot.tagName='i';var BlockEmbed=Quill$1.import('blots/block/embed');var Divider=function(_BlockEmbed){inherits(Divider,_BlockEmbed);function Divider(){classCallCheck$1(this,Divider);return possibleConstructorReturn(this,(Divider.__proto__||Object.getPrototypeOf(Divider)).apply(this,arguments));}return Divider;}(BlockEmbed);Divider.blotName='divider';Divider.tagName='hr';var BlockEmbed$1=Quill$1.import('blots/block/embed');var SUPPORTED_ATTRS=["accept","action","align","alt","autocomplete","background","bgcolor","border","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","coords","datetime","default","dir","disabled","download","enctype","face","for","headers","height","hidden","high","href","hreflang","id","ismap","label","lang","list","loop","low","max","maxlength","media","method","min","multiple","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","rowspan","spellcheck","scope","selected","shape","size","span","srclang","start","src","step","style","summary","tabindex","target","title","type","usemap","valign","value","width","xmlns"];var Table=function(_BlockEmbed){inherits(Table,_BlockEmbed);function Table(){classCallCheck$1(this,Table);return possibleConstructorReturn(this,(Table.__proto__||Object.getPrototypeOf(Table)).apply(this,arguments));}createClass$1(Table,null,[{key:'create',value:function create(value){var node=get(Table.__proto__||Object.getPrototypeOf(Table),'create',this).call(this,value);node.innerHTML=value.innerHTML;for(var attr in value.attributes){if(value.attributes[attr]!==null){node.setAttribute(attr,value.attributes[attr]);}}return node;}},{key:'value',value:function value(node){var ret={attributes:{}};if(node.tagName==='TABLE'){SUPPORTED_ATTRS.forEach(function(attr){if(node[attr]){ret.attributes[attr]=node.getAttribute(attr);}});ret.innerHTML=node.innerHTML;}return ret;}}]);return Table;}(BlockEmbed$1);Table.blotName='table';Table.tagName='TABLE';Table.className='ql-table-blob';var Inline$2=Quill$1.import('blots/inline');var Abbr=function(_Inline){inherits(Abbr,_Inline);function Abbr(){classCallCheck$1(this,Abbr);return possibleConstructorReturn(this,(Abbr.__proto__||Object.getPrototypeOf(Abbr)).apply(this,arguments));}createClass$1(Abbr,null,[{key:'create',value:function create(value){var node=get(Abbr.__proto__||Object.getPrototypeOf(Abbr),'create',this).call(this);if(typeof value==='string'){node.setAttribute('title',value);}return node;}},{key:'formats',value:function formats(node){var title=node.getAttribute('title');if(title){return title;}else{return true;}}}]);return Abbr;}(Inline$2);Abbr.blotName='abbr';Abbr.tagName='ABBR';var Inline$3=Quill$1.import('blots/inline');var Small=function(_Inline){inherits(Small,_Inline);function Small(){classCallCheck$1(this,Small);return possibleConstructorReturn(this,(Small.__proto__||Object.getPrototypeOf(Small)).apply(this,arguments));}return Small;}(Inline$3);Small.blotName='small';Small.tagName='small';var Inline$4=Quill$1.import('blots/inline');var Big=function(_Inline){inherits(Big,_Inline);function Big(){classCallCheck$1(this,Big);return possibleConstructorReturn(this,(Big.__proto__||Object.getPrototypeOf(Big)).apply(this,arguments));}return Big;}(Inline$4);Big.blotName='big';Big.tagName='big';var Inline$5=Quill$1.import('blots/inline');var Cite=function(_Inline){inherits(Cite,_Inline);function Cite(){classCallCheck$1(this,Cite);return possibleConstructorReturn(this,(Cite.__proto__||Object.getPrototypeOf(Cite)).apply(this,arguments));}return Cite;}(Inline$5);Cite.blotName='cite';Cite.tagName='cite';var Block=Quill$1.import('blots/block');var Address=function(_Block){inherits(Address,_Block);function Address(){classCallCheck$1(this,Address);return possibleConstructorReturn(this,(Address.__proto__||Object.getPrototypeOf(Address)).apply(this,arguments));}return Address;}(Block);Address.blotName='address';Address.tagName='ADDRESS';var Inline$6=Quill$1.import('blots/inline');var Del=function(_Inline){inherits(Del,_Inline);function Del(){classCallCheck$1(this,Del);return possibleConstructorReturn(this,(Del.__proto__||Object.getPrototypeOf(Del)).apply(this,arguments));}return Del;}(Inline$6);Del.blotName='del';Del.tagName='DEL';var Inline$7=Quill$1.import('blots/inline');var Q=function(_Inline){inherits(Q,_Inline);function Q(){classCallCheck$1(this,Q);return possibleConstructorReturn(this,(Q.__proto__||Object.getPrototypeOf(Q)).apply(this,arguments));}return Q;}(Inline$7);Q.blotName='q';Q.tagName='Q';var Inline$8=Quill$1.import('blots/inline');var Samp=function(_Inline){inherits(Samp,_Inline);function Samp(){classCallCheck$1(this,Samp);return possibleConstructorReturn(this,(Samp.__proto__||Object.getPrototypeOf(Samp)).apply(this,arguments));}return Samp;}(Inline$8);Samp.blotName='samp';Samp.tagName='SAMP';var Inline$9=Quill$1.import('blots/inline');var Var=function(_Inline){inherits(Var,_Inline);function Var(){classCallCheck$1(this,Var);return possibleConstructorReturn(this,(Var.__proto__||Object.getPrototypeOf(Var)).apply(this,arguments));}return Var;}(Inline$9);Var.blotName='var';Var.tagName='VAR';var Inline$10=Quill$1.import('blots/inline');var Ins=function(_Inline){inherits(Ins,_Inline);function Ins(){classCallCheck$1(this,Ins);return possibleConstructorReturn(this,(Ins.__proto__||Object.getPrototypeOf(Ins)).apply(this,arguments));}return Ins;}(Inline$10);Ins.blotName='ins';Ins.tagName='INS';var Inline$11=Quill$1.import('blots/inline');var Kbd=function(_Inline){inherits(Kbd,_Inline);function Kbd(){classCallCheck$1(this,Kbd);return possibleConstructorReturn(this,(Kbd.__proto__||Object.getPrototypeOf(Kbd)).apply(this,arguments));}return Kbd;}(Inline$11);Kbd.blotName='kbd';Kbd.tagName='KBD';var Parchment=Quill$1.import('parchment');var config={scope:Parchment.Scope.INLINE};var FontStyleAttributor=function(_Parchment$Attributor){inherits(FontStyleAttributor,_Parchment$Attributor);function FontStyleAttributor(){classCallCheck$1(this,FontStyleAttributor);return possibleConstructorReturn(this,(FontStyleAttributor.__proto__||Object.getPrototypeOf(FontStyleAttributor)).apply(this,arguments));}return FontStyleAttributor;}(Parchment.Attributor.Style);var FontStyle$1=new FontStyleAttributor('font','font-family',config);var Parchment$1=Quill$1.import('parchment');var Block$1=Quill$1.import('blots/block');var Container=Quill$1.import('blots/container');var List=Quill$1.import('formats/list');var ListItem=Quill$1.import('formats/list/item');var Dd=function(_Block){inherits(Dd,_Block);function Dd(){classCallCheck$1(this,Dd);return possibleConstructorReturn(this,(Dd.__proto__||Object.getPrototypeOf(Dd)).apply(this,arguments));}createClass$1(Dd,[{key:'format',value:function format(name,value){if(name===Dl.blotName&&!value){this.replaceWith(Parchment$1.create(this.statics.scope));}else{get(Dd.prototype.__proto__||Object.getPrototypeOf(Dd.prototype),'format',this).call(this,name,value);}}},{key:'remove',value:function remove(){if(this.prev==null&&this.next==null){this.parent.remove();}else{get(Dd.prototype.__proto__||Object.getPrototypeOf(Dd.prototype),'remove',this).call(this);}}}],[{key:'formats',value:function formats(domNode){return domNode.tagName;}},{key:'create',value:function create(value){var node=get(Dd.__proto__||Object.getPrototypeOf(Dd),'create',this).call(this,value);return node;}}]);return Dd;}(Block$1);Dd.blotName='dd';Dd.tagName='DD';var Dt=function(_Dd){inherits(Dt,_Dd);function Dt(){classCallCheck$1(this,Dt);return possibleConstructorReturn(this,(Dt.__proto__||Object.getPrototypeOf(Dt)).apply(this,arguments));}return Dt;}(Dd);Dt.blotName='dt';Dt.tagName='DT';var Dl=function(_Container){inherits(Dl,_Container);createClass$1(Dl,null,[{key:'create',value:function create(value){var node=get(Dl.__proto__||Object.getPrototypeOf(Dl),'create',this).call(this,value);return node;}},{key:'formats',value:function formats(domNode){return domNode.tagName.toLowerCase();}}]);function Dl(domNode){classCallCheck$1(this,Dl);return possibleConstructorReturn(this,(Dl.__proto__||Object.getPrototypeOf(Dl)).call(this,domNode));}createClass$1(Dl,[{key:'format',value:function format(name,value){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'formats',value:function formats(domNode){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot instanceof Dd){get(Dl.prototype.__proto__||Object.getPrototypeOf(Dl.prototype),'insertBefore',this).call(this,blot,ref);}else{var index=ref==null?this.length():ref.offset(this);var after=this.split(index);if(after){after.parent.insertBefore(blot,after);}else{this.parent.insertBefore(blot);}}}},{key:'replace',value:function replace(target){var item=void 0;if(target.statics.blotName!==this.statics.blotName){if(target.statics.blotName!==Dd.blotName&&target.statics.blotName!==Dt.blotName){item=Parchment$1.create(this.statics.defaultChild);}else{item=Parchment$1.create(target.statics.blotName);}target.moveChildren(item);this.appendChild(item);}get(Dl.prototype.__proto__||Object.getPrototypeOf(Dl.prototype),'replace',this).call(this,target);}},{key:'remove',value:function remove(){if(this.domNode.parentNode!=null){this.domNode.parentNode.removeChild(this.domNode);}this.detach();}},{key:'optimize',value:function optimize(){get(Dl.prototype.__proto__||Object.getPrototypeOf(Dl.prototype),'optimize',this).call(this);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName){next.moveChildren(this);next.remove();}}}]);return Dl;}(Container);Dl.blotName='dl';Dl.tagName='DL';Dl.scope=Parchment$1.Scope.BLOCK_BLOT;Dl.defaultChild='dt';Dl.allowedChildren=[Dt,Dd];var Image=Quill$1.import('formats/image');var ATTRIBUTES=['alt','height','width','data-fileid'];var SfdcImage=function(_Image){inherits(SfdcImage,_Image);function SfdcImage(){classCallCheck$1(this,SfdcImage);return possibleConstructorReturn(this,(SfdcImage.__proto__||Object.getPrototypeOf(SfdcImage)).apply(this,arguments));}createClass$1(SfdcImage,[{key:'format',value:function format(name,value){if(ATTRIBUTES.indexOf(name)>-1){if(value){this.domNode.setAttribute(name,value);}else{this.domNode.removeAttribute(name);}}else{get(SfdcImage.prototype.__proto__||Object.getPrototypeOf(SfdcImage.prototype),'format',this).call(this,name,value);}}}],[{key:'formats',value:function formats(domNode){return ATTRIBUTES.reduce(function(formats,attribute){if(domNode.hasAttribute(attribute)){formats[attribute]=domNode.getAttribute(attribute);}return formats;},{});}}]);return SfdcImage;}(Image);SfdcImage.blotName='image';SfdcImage.tagName='IMG';var Block$2=Quill$1.import('blots/block');var Container$1=Quill$1.import('blots/container');var Parchment$2=Quill$1.import('parchment');var QuoteBlock=function(_Block){inherits(QuoteBlock,_Block);function QuoteBlock(){classCallCheck$1(this,QuoteBlock);return possibleConstructorReturn(this,(QuoteBlock.__proto__||Object.getPrototypeOf(QuoteBlock)).apply(this,arguments));}createClass$1(QuoteBlock,[{key:'format',value:function format(name,value){if(name===Blockquote.blotName&&!value){this.replaceWith(Parchment$2.create(this.statics.scope));}else{get(QuoteBlock.prototype.__proto__||Object.getPrototypeOf(QuoteBlock.prototype),'format',this).call(this,name,value);}}},{key:'remove',value:function remove(){if(this.prev==null&&this.next==null){this.parent.remove();}else{get(QuoteBlock.prototype.__proto__||Object.getPrototypeOf(QuoteBlock.prototype),'remove',this).call(this);}}},{key:'replaceWith',value:function replaceWith(name,value){this.parent.isolate(this.offset(this.parent),this.length());if(name===this.parent.statics.blotName){this.parent.replaceWith(name,value);return this;}else{this.parent.unwrap();return get(QuoteBlock.prototype.__proto__||Object.getPrototypeOf(QuoteBlock.prototype),'replaceWith',this).call(this,name,value);}}}],[{key:'formats',value:function formats(domNode){return domNode.tagName===this.tagName?undefined:get(QuoteBlock.__proto__||Object.getPrototypeOf(QuoteBlock),'formats',this).call(this,domNode);}}]);return QuoteBlock;}(Block$2);QuoteBlock.blotName='quote-block';QuoteBlock.className='ql-quote-block';QuoteBlock.tagName=['P','H1','H2'];var Blockquote=function(_Container){inherits(Blockquote,_Container);createClass$1(Blockquote,null,[{key:'create',value:function create(value){var node=get(Blockquote.__proto__||Object.getPrototypeOf(Blockquote),'create',this).call(this,value);return node;}},{key:'formats',value:function formats(domNode){return domNode.tagName.toLowerCase();}}]);function Blockquote(domNode){classCallCheck$1(this,Blockquote);return possibleConstructorReturn(this,(Blockquote.__proto__||Object.getPrototypeOf(Blockquote)).call(this,domNode));}createClass$1(Blockquote,[{key:'format',value:function format(name,value){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'formats',value:function formats(domNode){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot instanceof Block$2){get(Blockquote.prototype.__proto__||Object.getPrototypeOf(Blockquote.prototype),'insertBefore',this).call(this,blot,ref);}else{var index=ref==null?this.length():ref.offset(this);var after=this.split(index);after.parent.insertBefore(blot,after);}}},{key:'replace',value:function replace(target){if(target.statics.blotName!==this.statics.blotName){var item=Parchment$2.create(this.statics.defaultChild);target.moveChildren(item);this.appendChild(item);}get(Blockquote.prototype.__proto__||Object.getPrototypeOf(Blockquote.prototype),'replace',this).call(this,target);}},{key:'remove',value:function remove(){if(this.domNode.parentNode!=null){this.domNode.parentNode.removeChild(this.domNode);}this.detach();}},{key:'optimize',value:function optimize(){get(Blockquote.prototype.__proto__||Object.getPrototypeOf(Blockquote.prototype),'optimize',this).call(this);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName){next.moveChildren(this);next.remove();}}}]);return Blockquote;}(Container$1);Blockquote.blotName='blockquote';Blockquote.tagName='blockquote';Blockquote.scope=Parchment$2.Scope.BLOCK_BLOT;Blockquote.defaultChild='quote-block';Blockquote.allowedChildren=[QuoteBlock];var Inline$12=Quill$1.import('blots/inline');var Bdo=function(_Inline){inherits(Bdo,_Inline);function Bdo(){classCallCheck$1(this,Bdo);return possibleConstructorReturn(this,(Bdo.__proto__||Object.getPrototypeOf(Bdo)).apply(this,arguments));}createClass$1(Bdo,null,[{key:'create',value:function create(value){var node=get(Bdo.__proto__||Object.getPrototypeOf(Bdo),'create',this).call(this);node.setAttribute('dir',value);return node;}},{key:'formats',value:function formats(node){return node.getAttribute('dir');}}]);return Bdo;}(Inline$12);Bdo.blotName='bdo';Bdo.tagName='BDO';var Inline$13=Quill$1.import('blots/inline');var Dfn=function(_Inline){inherits(Dfn,_Inline);function Dfn(){classCallCheck$1(this,Dfn);return possibleConstructorReturn(this,(Dfn.__proto__||Object.getPrototypeOf(Dfn)).apply(this,arguments));}createClass$1(Dfn,null,[{key:'create',value:function create(value){var node=get(Dfn.__proto__||Object.getPrototypeOf(Dfn),'create',this).call(this);if(typeof value==='string'){node.setAttribute('title',value);}return node;}},{key:'formats',value:function formats(node){var value=node.getAttribute('title');if(value){return value;}else{return true;}}}]);return Dfn;}(Inline$13);Dfn.blotName='dfn';Dfn.tagName='DFN';var Inline$14=Quill$1.import('blots/inline');var Grammarly=function(_Inline){inherits(Grammarly,_Inline);function Grammarly(){classCallCheck$1(this,Grammarly);return possibleConstructorReturn(this,(Grammarly.__proto__||Object.getPrototypeOf(Grammarly)).apply(this,arguments));}return Grammarly;}(Inline$14);Grammarly.tagName='G';Grammarly.blotName='grammarly-inline';Grammarly.className='gr_';var Inline$15=Quill$1.import('blots/inline');var MentionBlot=function(_Inline){inherits(MentionBlot,_Inline);function MentionBlot(){classCallCheck$1(this,MentionBlot);return possibleConstructorReturn(this,(MentionBlot.__proto__||Object.getPrototypeOf(MentionBlot)).apply(this,arguments));}createClass$1(MentionBlot,[{key:'format',value:function format(name,value){if(name==='data-mention'&&value){this.domNode.setAttribute(name,value);}else{get(MentionBlot.prototype.__proto__||Object.getPrototypeOf(MentionBlot.prototype),'format',this).call(this,name,value);}}}],[{key:'create',value:function create(id){var node=get(MentionBlot.__proto__||Object.getPrototypeOf(MentionBlot),'create',this).call(this);node.classList.add('quill_widget_element');node.setAttribute('contenteditable',false);node.setAttribute('tabindex',"-1");node.setAttribute('data-widget','chatterMention');node.setAttribute('data-mention',id);node.addEventListener('keydown',function(event){if(event.keyCode===8||event.keyCode===46){event.preventDefault();var parent=node.parentNode;if(parent){parent.removeChild(node);parent.dispatchEvent(new CustomEvent('deletemention',{bubbles:true}));}}});node.addEventListener('click',function(event){node.focus();node.dispatchEvent(new CustomEvent('clickmention',{bubbles:true}));});return node;}},{key:'formats',value:function formats(domNode){return domNode.getAttribute('data-mention');}}]);return MentionBlot;}(Inline$15);MentionBlot.blotName='mention';MentionBlot.tagName='span';MentionBlot.className='ql-chatter-mention';var BlockEmbed$2=Quill$1.import('blots/block/embed');var CodeSnippet=function(_BlockEmbed){inherits(CodeSnippet,_BlockEmbed);function CodeSnippet(){classCallCheck$1(this,CodeSnippet);return possibleConstructorReturn(this,(CodeSnippet.__proto__||Object.getPrototypeOf(CodeSnippet)).apply(this,arguments));}createClass$1(CodeSnippet,null,[{key:'create',value:function create(data){var node=get(CodeSnippet.__proto__||Object.getPrototypeOf(CodeSnippet),'create',this).call(this);node.setAttribute('contenteditable',false);node.setAttribute('tabindex',"-1");node.classList.add('quill_widget_wrapper');node.classList.add('quill_widget_block');var pre=document.createElement("pre");pre.setAttribute('spellcheck',false);pre.setAttribute('data-widget','codeSnippet');pre.classList.add('quill_widget_element');node.appendChild(pre);var code=document.createElement("code");code.setAttribute('class','language-javascript');data=data.replace(/</g,"&lt;");data=data.replace(/>/g,"&gt;");node.setAttribute("data-code",data);if(window.Aura&&Aura.Quill&&Aura.Quill.Prettify){var highlightedCode=Aura.Quill.Prettify.PR.prettyPrintOne(data,"",true);highlightedCode=highlightedCode.replace(/<li/gi,"<span");highlightedCode=highlightedCode.replace(/<\/li>/gi,"</span>");highlightedCode=highlightedCode.replace(/<ol/gi,"<span");highlightedCode=highlightedCode.replace(/<\/ol>/gi,"</span>");code.innerHTML=highlightedCode;}else{code.innerHTML=data;}pre.appendChild(code);node.addEventListener('keydown',function(event){if(event.keyCode===8||event.keyCode===46){event.preventDefault();event.stopPropagation();node.parentNode.removeChild(node);}});node.addEventListener('click',function(event){event.stopPropagation();node.focus();});return node;}},{key:'value',value:function value(node){if(node.hasAttribute("data-code")){return node.getAttribute("data-code");}return node.innerText;}}]);return CodeSnippet;}(BlockEmbed$2);CodeSnippet.blotName='code-snippet';CodeSnippet.className='ql-codesnippet';CodeSnippet.tagName='pre';var AlignStyle=Quill$1.import('attributors/style/align');var FontStyle=Quill$1.import('attributors/style/font');var SizeStyle=Quill$1.import('attributors/style/size');var ColorStyle=Quill$1.import('attributors/style/color');var Delta=Quill$1.import('delta');SizeStyle.whitelist=null;Quill$1.register(BoldBlot,true);Quill$1.register(ItalicBlot,true);Quill$1.register(AlignStyle,true);Quill$1.register(FontStyle$1,true);Quill$1.register(SizeStyle,true);Quill$1.register(ColorStyle,true);Quill$1.register(SfdcImage,true);Quill$1.register(Blockquote,true);Quill$1.register(QuoteBlock,true);Quill$1.register(Table,true);Quill$1.register(Abbr,true);Quill$1.register(Small,true);Quill$1.register(Big,true);Quill$1.register(Cite,true);Quill$1.register(Address,true);Quill$1.register(Del,true);Quill$1.register(Samp,true);Quill$1.register(Var,true);Quill$1.register(Q,true);Quill$1.register(Ins,true);Quill$1.register(Kbd,true);Quill$1.register(Dt,true);Quill$1.register(Dl,true);Quill$1.register(Dd,true);Quill$1.register(Divider,true);Quill$1.register(Bdo,true);Quill$1.register(Dfn,true);Quill$1.register(Grammarly,true);Quill$1.register(MentionBlot,true);Quill$1.register(CodeSnippet,true);Quill$1.Delta=Delta;var Quill = lwc.registerComponent(Quill$1,{tmpl:_tmpl$5});

    var labelImageSizeExceeded = 'The image exceeded the maximum size of 1 MB.';

    var labelImageUploadFailed = 'There was a problem uploading the file.';

    const Delta$1 = Quill.Delta;
    const ALLOWED_FORMATS_FOR_API = ['align', 'font', 'size'
    /* the following formats are not enabled for 220,
       leaving them here to simplify enabling them
    'link',
    'indent',
    'list',
    'bold',
    'italic',
    'strike',
    'header',
    'direction',
    'code',
    'code-block',
    'color',
    'script',
    'underline',
    'background',*/
    ];
    const ALLOWED_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
    const FONT_LIST = [{
      label: 'Salesforce Sans',
      value: 'default'
    }, {
      label: 'Arial',
      class: 'sans-serif',
      value: 'sans-serif'
    }, {
      label: 'Courier',
      class: 'courier',
      value: 'courier'
    }, {
      label: 'Verdana',
      class: 'verdana',
      value: 'verdana'
    }, {
      label: 'Tahoma',
      class: 'tahoma',
      value: 'tahoma'
    }, {
      label: 'Garamond',
      class: 'garamond',
      value: 'garamond'
    }, {
      label: 'Times New Roman',
      class: 'serif',
      value: 'serif'
    }];
    const ALLOWED_FONTS = FONT_LIST.map(item => {
      return item.value;
    });
    const ALLOWED_TAGS = ['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font'];
    const ALLOWED_ATTRS = ['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', // for custom blots
    'data-fileid'];
    const IMAGE_MAX_SIZE = 1048576; // Max size of image: 1MB - 1048576 bytes

    function _sanitize(val) {
      return configProvider$1.sanitizeDOM(val, {
        ALLOWED_TAGS,
        ALLOWED_ATTRS
      });
    }

    function computeIndentLevel(node) {
      const indentMatch = node.className.match(/ql-indent-([0-9]+)/);

      if (indentMatch) {
        return parseInt(indentMatch[1], 10);
      }

      return 0;
    }
    /**
     * Turn a list with ql- classes into a nested list.
     * Recursive!
     *
     * @param  {Array} list         an array of list items
     * @param  {Number} indentLevel the current indent level
     * @param  {String} type        ol or ul
     * @return {HTMLElement}        A DOM element
     */


    function nestList(list, indentLevel, type) {
      let level;
      let thisNode;
      let lastNode;
      const returnNode = document.createElement(type);

      while (list.length > 0) {
        if (thisNode) {
          lastNode = thisNode;
        }

        thisNode = list[0];
        level = computeIndentLevel(thisNode); // should be a sub-list. Recurse!

        if (lastNode && level > indentLevel) {
          lastNode.appendChild(nestList(list, level, type));
        } else if (level < indentLevel) {
          return returnNode;
        } else {
          thisNode.removeAttribute('class');
          returnNode.appendChild(list.shift());
        }
      }

      return returnNode;
    }
    /**
     * Recursivly flatten a nested list
     * an add quill classes
     *
     * No return, this will TRANSFORM the passed list
     * @param  {HTMLElement} list        This list node
     * @param  {Number} indentLevel The indentation level of the list passed
     */


    function unnestList(list, indentLevel) {
      const children = Array.prototype.slice.call(list.childNodes);
      children.forEach(node => {
        if (indentLevel > 0) {
          node.className = 'ql-indent-' + indentLevel;
        }

        Array.prototype.slice.call(node.childNodes).forEach(childNode => {
          const regex = /ol|ul/i;

          if (regex.test(childNode.tagName)) {
            unnestList(childNode, indentLevel + 1);
          }
        });
      });
    }

    function cleanInput(html) {
      const frag = document.createElement('div'); // eslint-disable-next-line lwc/no-inner-html

      frag.innerHTML = _sanitize(html);
      const lists = Array.prototype.slice.call(frag.querySelectorAll('ol,ul'));

      if (lists) {
        lists.forEach(list => {
          unnestList(list, 0);
          const flatList = list.querySelectorAll('li');

          if (flatList.length > 0) {
            for (let i = 0; i < flatList.length; i += 1) {
              list.appendChild(flatList[i]);
            }
          }
        });
      } // eslint-disable-next-line lwc/no-inner-html


      return frag.innerHTML;
    }

    function cleanOutput(html) {
      const frag = document.createElement('div'); // eslint-disable-next-line lwc/no-inner-html

      frag.innerHTML = html;
      const lists = Array.prototype.slice.call(frag.querySelectorAll('ol,ul'));

      if (lists) {
        lists.forEach(list => {
          const myList = nestList(Array.prototype.slice.call(list.querySelectorAll('li')), 0, list.tagName);
          list.parentNode.replaceChild(myList, list);
        });
      } // eslint-disable-next-line lwc/no-inner-html


      return frag.innerHTML;
    }

    function insertEmbed(quillInstance, format, value, attributes) {
      const insert = {};
      const attrs = attributes || {}; // this is important! if the editor
      // is not focused we can't insert.

      quillInstance.focus();
      const range = quillInstance.getSelection(); // TODO: handle alt tags!

      insert[format] = value;
      const delta = new Delta$1().retain(range.index).delete(range.length);
      delta.insert(insert, attrs);
      return quillInstance.updateContents(delta);
    }
    /**
     * 1. Attempt to upload the selected file
     *     a. If the file size exceeds 1MB, the file will not be uploaded
     *     b. If the upload encounters a problem, an error is thrown
     * 2. If the file is uploaded, insert the file/image into the editor
     * @param {Object} quillApi - Quill instance into which the image should be inserted
     * @param {Object} file - The file that needs to be uploaded
     * @param {Object} shareWithEntityId - Entity ID to share the image with
     */


    function uploadAndInsertSelectedFile(quillApi, file, shareWithEntityId) {
      if (file.size > this.IMAGE_MAX_SIZE) {
        throw new Error(this.labelImageSizeExceeded);
      } else {
        aura.createComponent('force:fileUpload', {
          shareWithEntityId,
          onUpload: serverResponse => {
            if (serverResponse.successful) {
              this.insertEmbed(quillApi, 'image', serverResponse.response.downloadUrl, {
                alt: file.name
              });
            } else {
              throw new Error(this.labelImageUploadFailed + 'Response from Server: ' + serverResponse.response);
            }
          }
        }, (uploadFileCmp, status) => {
          if (status === 'SUCCESS') {
            uploadFileCmp.uploadFile(file);
          }
        });
      }
    }

    function filterFormats(formats) {
      const ret = {};
      const keys = Object.keys(formats);
      keys.forEach(key => {
        let value = formats[key]; // remove formats not in the white list

        if (ALLOWED_FORMATS_FOR_API.indexOf(key) === -1) {
          return;
        } // check font values whitelist


        if (key === 'font' && ALLOWED_FONTS.indexOf(value) === -1) {
          return;
        } // cast size to int, check value, cast back to string later when we set it


        if (key === 'size') {
          const size = parseInt(value, 10); // fast short circuit non number values;

          if (isNaN(size)) {
            return;
          }

          if (ALLOWED_SIZES.indexOf(size) === -1) {
            return;
          }

          value = size;
        }

        ret[key] = value;
      });
      return ret;
    }

    function applyFormats(api, formats) {
      const filtered = filterFormats(formats);
      Object.keys(filtered).forEach(key => {
        let value = formats[key];

        if (key === 'size') {
          value = `${value}px`;
        }

        api.format(key, value);
      });
    }

    const inputRichTextLibrary = {
      Delta: Delta$1,
      filterFormats,
      applyFormats,
      computeIndentLevel,
      nestList,
      unnestList,
      cleanInput,
      cleanOutput,
      insertEmbed,
      uploadAndInsertSelectedFile,
      ALLOWED_SIZES,
      FONT_LIST,
      ALLOWED_ATTRS,
      ALLOWED_TAGS,
      IMAGE_MAX_SIZE,
      labelImageSizeExceeded,
      labelImageUploadFailed
    };
    var lightningQuill = {
      Quill,
      inputRichTextLibrary
    };

    const EMPTY_CHARACTER = '\u200B';
    const emptyCharMatcher = new RegExp(EMPTY_CHARACTER, 'g');

    function isNonCharacterKey(keyCode) {
      return keyCode && keyCode < 48;
    }
    /**
     * Issue: the first couple letters are entered directly without being considered
     *   as part of IME. This has to do with quill trying to create the first text
     *   node and breaking the IME. This only happens to Chrome and IE11.
     * Workaround: on compositionstart, insert empty characters at the beginning of
     *   every line. Remove all the empty chars when selection is changed.
     *
     * We use a class here to store the state of the hack instead of creating private
     * attributes in the component.
     *
     * @param {Object} rte - input rich text LWC instantce
     */


    class IMEHandler {
      constructor(inputRichText) {
        this.inputRichText = void 0;
        this.isEmptyCharInserted = false;
        this.inputRichText = inputRichText;
      }

      initializeEmptyCharHack() {
        const quill = this.inputRichText.quill;
        const editorElement = quill.root;
        let shouldInsertEmptyChar = false;

        if (isChrome) {
          const handleInsertEmptyChar = event => {
            if (isNonCharacterKey(event.keyCode)) {
              return;
            } // Find all the paragraphs that have no text or images - make sure
            // they have an empty char


            const children = editorElement.querySelectorAll('p, li');

            for (let i = 0; i < children.length; i += 1) {
              const child = children[i];

              if (child.textContent.length === 0 && child.getElementsByTagName('img').length === 0) {
                child.textContent = EMPTY_CHARACTER;
              }
            }

            this.isEmptyCharInserted = true;
          };

          editorElement.addEventListener('compositionstart', handleInsertEmptyChar);
          shouldInsertEmptyChar = true;
        } else if (isIE11) {
          const handleInsertEmptyChar = () => {
            // Insert empty character into the editor when there is no content
            // This is to make sure it works in accordance to the hack applied
            // for W-3946761.
            // Using the workaround for Chrome here would cause IE11 to freeze.
            // IE11 also doesn't need every empty line to have empty char.
            if (quill.editor.isBlank()) {
              const child = editorElement.querySelector('p');
              child.textContent = EMPTY_CHARACTER;
              this.isEmptyCharInserted = true;
            }
          };

          ['focus', 'keydown'].forEach(eventName => {
            editorElement.addEventListener(eventName, handleInsertEmptyChar);
          });
          shouldInsertEmptyChar = true;
        }

        if (shouldInsertEmptyChar) {
          quill.on('selection-change', () => {
            if (this.isEmptyCharInserted) {
              this.clearEmptyCharIfTrulyEmpty(quill);
            }
          });
        }
      }

      clearEmptyCharIfTrulyEmpty() {
        const quill = this.inputRichText.quill;
        const text = quill.getText().replace(/\n/, ''); // if the text is only the empty char that means the editor
        // should be empty

        if (!quill.hasFocus() && text === EMPTY_CHARACTER) {
          quill.setText('');
          this.isEmptyCharInserted = false;
        }
      }

      clearEmptyChars(html) {
        if (this.isEmptyCharInserted) {
          return html.replace(emptyCharMatcher, '');
        }

        return html;
      }

    }

    var IMEHandler$1 = lwc.registerComponent(IMEHandler, {
      tmpl: _tmpl$5
    });

    const {
      Quill: Quill$2,
      inputRichTextLibrary: inputRichTextLibrary$1
    } = lightningQuill;
    const TOOLBAR_CATEGORIES = {
      FORMAT_TEXT: 'FORMAT_TEXT',
      FORMAT_BACKGROUND: 'FORMAT_BACKGROUND',
      FORMAT_BODY: 'FORMAT_BODY',
      FORMAT_FONT: 'FORMAT_FONT',
      ALIGN_TEXT: 'ALIGN_TEXT',
      INSERT_CONTENT: 'INSERT_CONTENT',
      REMOVE_FORMATTING: 'REMOVE_FORMATTING'
    };
    const ALLOWED_IMAGE_FORMATS = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif'];
    const CREATE_LINK_PANEL_WIDTH = 320,
          DEFAULT_FONT_NAME_VALUE = 'default',
          DEFAULT_FONT_SIZE_VALUE = '12px',
          DEFAULT_TEXT_COLOR_VALUE = '#000000',
          DEFAULT_CATEGORY = 'FORMAT_TEXT',
          SF_DEFAULT_FORMATS = ['table', 'image', 'link', 'header'],
          BUTTON_CLASSNAMES = 'slds-button slds-button_icon-border-filled',
          TOOLBAR_SELECTOR = '.slds-rich-text-editor__toolbar > ul li .slds-button, .overflow-menu > ul > li .slds-button';
    const i18n$h = {
      alignText: labelAlignText,
      bold: labelBold,
      bullet: labelBullet,
      centerAlign: labelCenterAlign,
      composeText: labelComposeText,
      font: labelFont,
      fontSize: labelFontSize,
      formatBackground: labelFormatBackground,
      formatBody: labelFormatBody,
      formatFont: labelFormatFont,
      formatText: labelFormatText,
      indent: labelIndent,
      insertContent: labelInsertContent,
      italic: labelItalic,
      leftAlign: labelLeftAlign,
      link: labelLink,
      image: labelImage,
      linkCancel: labelLinkCancel,
      linkInput: labelLinkInput,
      linkSave: labelLinkSave,
      number: labelNumber,
      outdent: labelOutdent,
      removeFormatting: labelRemoveFormatting,
      rightAlign: labelRightAlign,
      strike: labelStrike,
      underline: labelUnderline
    };

    function defaults() {
      return [{
        category: TOOLBAR_CATEGORIES.FORMAT_TEXT,
        label: i18n$h.formatText,
        buttons: [{
          label: i18n$h.bold,
          iconName: 'utility:bold',
          format: 'bold'
        }, {
          label: i18n$h.italic,
          iconName: 'utility:italic',
          format: 'italic'
        }, {
          label: i18n$h.underline,
          iconName: 'utility:underline',
          format: 'underline'
        }, {
          label: i18n$h.strike,
          iconName: 'utility:strikethrough',
          format: 'strike'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.FORMAT_BACKGROUND,
        label: i18n$h.formatBackground,
        buttons: []
      }, {
        category: TOOLBAR_CATEGORIES.FORMAT_BODY,
        label: i18n$h.formatBody,
        buttons: [{
          label: i18n$h.bullet,
          iconName: 'utility:richtextbulletedlist',
          format: 'list',
          value: 'bullet'
        }, {
          label: i18n$h.number,
          iconName: 'utility:richtextnumberedlist',
          format: 'list',
          value: 'ordered'
        }, {
          label: i18n$h.indent,
          iconName: 'utility:richtextindent',
          format: 'indent',
          value: '+1'
        }, {
          label: i18n$h.outdent,
          iconName: 'utility:richtextoutdent',
          format: 'indent',
          value: '-1'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.ALIGN_TEXT,
        label: i18n$h.alignText,
        buttons: [{
          label: i18n$h.leftAlign,
          iconName: 'utility:left_align_text',
          format: 'align',
          value: ''
        }, {
          label: i18n$h.centerAlign,
          iconName: 'utility:center_align_text',
          format: 'align',
          value: 'center'
        }, {
          label: i18n$h.rightAlign,
          iconName: 'utility:right_align_text',
          format: 'align',
          value: 'right'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.INSERT_CONTENT,
        label: i18n$h.insertContent,
        buttons: [{
          label: i18n$h.link,
          iconName: 'utility:link',
          format: 'link'
        }, {
          label: i18n$h.image,
          iconName: 'utility:image',
          format: 'image'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.REMOVE_FORMATTING,
        label: i18n$h.removeFormatting,
        buttons: [{
          label: i18n$h.removeFormatting,
          iconName: 'utility:remove_formatting',
          format: 'clean'
        }]
      }];
    }

    const FONT_LIST$1 = inputRichTextLibrary$1.FONT_LIST;
    const ALLOWED_SIZES$1 = [];
    inputRichTextLibrary$1.ALLOWED_SIZES.forEach(size => {
      ALLOWED_SIZES$1.push({
        label: `${size}`,
        value: `${size}px`
      });
    });
    const keyCodes$1 = {
      tab: 9,
      enter: 13,
      escape: 27,
      space: 32,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40
    };
    const bindings = {
      // This will overwrite the default binding also named 'tab'
      // which would normally indent
      tab: {
        key: 9,
        shiftKey: false,

        handler() {
          // this will stop quill from preventingDefault
          // and stopping propigation on this event
          // so it will be handled normally
          return true;
        }

      },
      // names are not used, unique to avoid collision
      lightningOutdent: {
        key: 219,
        // [
        shortKey: true,

        handler() {
          this.quill.format('indent', '-1');
        }

      },
      lightningIndent: {
        key: 221,
        // ]
        shortKey: true,

        handler() {
          this.quill.format('indent', '+1');
        }

      }
    }; // Map for converting the size in <font size=x />
    // to an actual pixel value

    const FONT_SIZE_MAP = {
      1: '9px',
      2: '11px',
      3: '14px',
      4: '16px',
      5: '22px',
      6: '28px',
      7: '48px'
    };
    /**
     * Converts a CSS style value to an integer
     * Ex. "100px" -> 100
     * @param {HTMLElement} element - Element from which to retrieve the style
     * @param {String} style - The CSS style to retrieve from the element
     * @return {Integer} - Converted integer value
     */

    function getStyleAsInt(element, style) {
      return parseInt(element.style[style], 10);
    }
    /**
     * A WYSIWYG editor with a customizable toolbar for entering rich text
     */


    class LightningInputRichText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._pendingFormats = [];
        this._valid = true;
        this._disabled = false;
        this.linkPanelOpen = false;
        this.selectedFontValue = DEFAULT_FONT_NAME_VALUE;
        this.selectedSizeValue = DEFAULT_FONT_SIZE_VALUE;
        this.quillNotReady = true;
        this.selectedTextColorValue = DEFAULT_TEXT_COLOR_VALUE;
        this.label = void 0;
        this.labelVisible = false;
        this.placeholder = void 0;
        this.disabledCategories = '';
        this.formats = '';
        this.variant = void 0;
        this.messageWhenBadInput = void 0;
        this.customButtons = void 0;
        this.shareWithEntityId = void 0;
        this.quill = void 0;
        this.initialRender = true;
        this.internalValue = void 0;
        this.linkValue = 'http://';
        this.fontMenus = {
          fontList: FONT_LIST$1,
          sizeList: ALLOWED_SIZES$1
        };
      }

      /**
       * The HTML content in the rich text editor.
       * @type {string}
       *
       */
      get value() {
        return this.internalValue;
      }

      set value(val) {
        // Change internalValue and paste into editor only if
        // the contents are different from the previously saved value
        if (typeof val === 'string' && this.internalValue !== val) {
          this.internalValue = inputRichTextLibrary$1.cleanInput(val);

          if (!this.internalValue) {
            // eslint-disable-next-line no-console
            console.warn('No html sanitizer found for rich text, make sure to sanitize rich text before using lightning-input-rich-text. Using raw html value');
            this.internalValue = val;
          }

          if (this.quill) {
            this.quill.clipboard.dangerouslyPasteHTML(this.internalValue);
          }
        }
      }
      /**
       * Specifies whether the editor content is valid. If invalid, the slds-has-error class is added. This value defaults to true.
       * @type {boolean}
       * @default true
       */


      get valid() {
        return this._valid;
      }

      set valid(value) {
        this._valid = normalizeBoolean(value);

        if (this.quill) {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          const editorElement = this.quill.root;

          if (!this.valid) {
            rteElement.classList.add('slds-has-error');
            editorElement.setAttribute('aria-describedby', this.errorMessageId);
          } else {
            rteElement.classList.remove('slds-has-error');
            editorElement.removeAttribute('aria-describedby');
          }
        }
      }
      /**
       * If present, the editor is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * Sets focus on the rich text editor.
       */


      focus() {
        // Focus on inputRichText should activate editor.
        if (!this.quill) {
          this.activateEditor();
        }

        this.quill.root.focus();
      }
      /**
       * Removes focus from the rich text editor.
       */


      blur() {
        if (this.quill) {
          this.quill.root.blur();
        }
      }
      /**
       *
       * Sets a format in the editor from the cursor point onwards.
       * The format also applies to currently selected content.
       *
       * Valid formats are font, size, and align.
       * @param {Object} formats A key-value pair with format names and values.
       */


      setFormat(formats) {
        if (formats && this.quill) {
          inputRichTextLibrary$1.applyFormats(this.quill, lwc.unwrap(formats));
          const selection = this.quill.getSelection();

          if (selection.length === 0) {
            this.syncFontMenus();
          }
        } else if (formats) {
          this._pendingFormats.push(formats);
        }
      }
      /**
       * Returns an object representing the formats applied to the current selection.
       * Only align, font, and size are supported.
       *
       * @returns {Object} format an object representing the formats applied
       *                   to the selection or editor
       */


      getFormat() {
        if (!this.quill) {
          this.activateEditor();
        }

        return inputRichTextLibrary$1.filterFormats(this.quill.getFormat());
      }

      syncFontMenus() {
        const format = this.quill.getFormat();
        this.updateFontMenu(format);
        this.updateSizeMenu(format);
      }

      get showLinkValue() {
        return this.linkValue;
      }

      get isBottomToolbar() {
        return this.variant === 'bottom-toolbar';
      }

      get isColorpickerVisible() {
        return this.formats.indexOf('color') > -1;
      }

      get isFontMenusVisible() {
        if (this.disabledCategories.indexOf(TOOLBAR_CATEGORIES.FORMAT_FONT) !== -1) {
          return false;
        } // If custom formats are specified,
        // hide the fonts menus if font is not a part
        // of the custom formats


        if (this.formats.length > 0) {
          if (this.formats.indexOf('font') === -1) {
            return false;
          }
        }

        return true;
      }

      get menuDropdownAlignment() {
        if (this.isBottomToolbar) {
          return 'bottom-left';
        }

        return null;
      }

      get errorMessage() {
        return this.messageWhenBadInput;
      }

      get i18n() {
        return i18n$h;
      }

      get labelId() {
        return this.uniqueLabelId;
      }

      get errorMessageId() {
        const msg = this.template.querySelector('[data-error-message]');
        return getRealDOMId(msg);
      }

      get toolbarAriaLabel() {
        return this.disabled ? 'disabled' : '';
      }

      get renderLabel() {
        return this.labelVisible || this.label;
      }

      get computedLabel() {
        return this.label ? this.label : this.i18n.composeText;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');
        return classnames.add({
          'slds-assistive-text': !this.labelVisible
        }).toString();
      }
      /**
       * Compute the complete set of buttons to be displayed and
       * add appropriate class names to each button
       *  - If the formats attribute is specified:
       *      Filter out buttons which do not match the specified formats
       *  - Merge the custom buttons with this filtered button set
       *  - Remove an entire category if:
       *      a. There are no remaining buttons in that category
       *      b. If it is a disabled category
       *  - Add the right class names to each remaining button
       * @returns {Object} Filtered set categories and buttons
       */


      get computedCategories() {
        // If custom formats are specified,
        // filter out the buttons which do not match
        // the specified custom formats, within each category
        const customFormats = !!this.formats.length;
        const formatList = this.formats;
        let categories = defaults();

        if (customFormats) {
          categories.forEach(cat => {
            cat.buttons = cat.buttons.filter(button => formatList.includes(button.format));
          });
        } // Merge custom buttons after filtering out default buttons which
        // do not match custom formats, so that the custom buttons may be
        // included even when the custom formats do not specify them


        categories = this.mergeCustomToolbarButtons(categories); // only keep categories that have buttons and not disabled

        categories = categories.filter(cat => cat.buttons && cat.buttons.length > 0 && !this.disabledCategories.includes(cat.category)); // Add additional attributes to each button

        categories.forEach(cat => {
          cat.buttons.forEach(button => {
            // add classes
            if (button.format) {
              button.computedClass = `${BUTTON_CLASSNAMES} ql-${button.format}`;
            } else {
              button.computedClass = BUTTON_CLASSNAMES;
            } // add key for iterations


            button.key = button.label + button.value;
          });
        });
        return categories;
      }
      /**
       * Merge the provided custom buttons with the existing set
       * If custom buttons are provided:
       *      Check if the custom button's category exists in the existing set
       *          If yes, add the button(s) into that category
       *          If no, add that entire category along with button(s) into the existing set
       *      If custom buttons' categories are not specified, add buttons to the default category
       * @param {Array} buttonSet - Set of filtered buttons;
       * If custom formats are provided, this set consists of default
       * buttons with those buttons removed, which do not match the format
       * Else, it is the default set of buttons
       * @returns {Array} Returns the merged set of buttons
       */


      mergeCustomToolbarButtons(buttonSet) {
        if (this.customButtons) {
          let existingCategory = false;
          this.customButtons.forEach(customButton => {
            existingCategory = false;
            buttonSet.forEach(cat => {
              // If the custom button is of an existing category,
              // add the custom button to the existing button set under that category
              // If a category for the custom button was not given
              // add the custom button into the default (Format Text) category
              if (!existingCategory && (cat.category === customButton.category || !customButton.category && cat.category === DEFAULT_CATEGORY)) {
                existingCategory = true;
                cat.buttons = cat.buttons.concat(lwc.unwrap(customButton.buttons));
              }
            }); // If the user button is not part of an existing category,
            // append the button info along with category information
            // to the complete set of buttons

            if (!existingCategory) {
              buttonSet = buttonSet.concat(lwc.unwrap(customButton));
            }
          });
        }

        return buttonSet;
      }
      /**
       * If it is a bottom-toolbar variant, add the appropriate
       * slds class to the toolbar
       */


      setupToolbar() {
        if (this.isBottomToolbar) {
          const toolbar = this.template.querySelector('.slds-rich-text-editor__toolbar');
          toolbar.classList.add('slds-rich-text-editor__toolbar_bottom');
        }
      }
      /**
       * For initial set up of buttons
       * We set the tabindex of every button to -1,
       * except the first button, which is set to 0
       *
       * This is so that tabbing through buttons is disabled
       * Instead ,users will be able to tab onto one button and use
       * arrow keys to navigate to other buttons
       */


      setupButtons() {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);

        if (buttonList.length > 0) {
          this.setButtonTabindex(buttonList, 0);
        }
      }
      /**
       * Helper function to set tabindexes of all buttons to -1,
       * and to set the tabindex of the specified index to 0
       * @param {Array} buttonList - List of buttons to iterate through
       * @param {Number} index - Index of button whose tabindex to set to 0
       */


      setButtonTabindex(buttonList, index) {
        buttonList.forEach(button => {
          button.setAttribute('tabindex', -1);
        });
        buttonList[index].setAttribute('tabindex', 0);
      }
      /**
       * Attach custom handlers to the custom buttons
       * If custom buttons have been provided:
       *      Compare the custom button's format and the rendered
       *      toolbar button's quill class
       *      If they match, attach the provided custom handler as
       *      an onclick handler for that button
       */


      attachCustomButtonHandlers() {
        if (this.customButtons) {
          const renderedButtons = this.template.querySelectorAll(TOOLBAR_SELECTOR);
          this.customButtons.forEach(cat => {
            cat.buttons.forEach(button => {
              renderedButtons.forEach(renderedButton => {
                if (renderedButton.classList.contains('ql-' + button.format)) {
                  // Pass in the inputRichText component so that the handler
                  // has access to the quill instance
                  renderedButton.addEventListener('click', button.handler);
                }
              });
            });
          });
        }
      }
      /**
       * Add slds classes to the editor generated on initialization of Quill
       * @param {HTMLElement} qlEditor - Editor element generated from the
       * initialization of Quill
       */


      addInitialClassesAndAttributesToEditor(qlEditor) {
        qlEditor.classList.add('slds-rich-text-area__content');
        qlEditor.classList.add('slds-grow');
        qlEditor.classList.add('slds-text-color_weak');
        this.setAriaAttributesOnEditor(qlEditor);
      }
      /**
       * Add appropriate aria attributes based on values of label and labelVisible
       * @param {HTMLElement} qlEditor - Editor element on which to set aria attributes
       */


      setAriaAttributesOnEditor(qlEditor) {
        if (this.labelVisible || this.label) {
          qlEditor.setAttribute('aria-labelledby', this.uniqueLabelId);
        } else {
          qlEditor.setAttribute('aria-label', this.i18n.composeText);
        }
      }
      /**
       * Compute the list of formats to be passed in to the Quill configuration
       * If the formats attributes is specified, use that list
       * If formats are not specified:
       *      a. We set the formats of the buttons as the
       *         list of formats to pass into the Quill config
       *      b. Add font menus to list if it is not a disabled category
       * Add the Salesforce default formats to the filtered list - these are
       * on by default
       * @returns {Array} Final list of formats to pass into the Quill config
       */


      computeFormats() {
        let computedFormats = []; // If custom formats are specified, don't do anything
        // we will use this list in the quill config

        if (this.formats.length > 0) {
          return this.formats;
        } // If custom formats are not specified, we should set the
        // formats of the buttons as the formats list in the quill config
        // Visible buttons have already been calculated by the time
        // this stage is reached


        this.computedCategories.forEach(cat => {
          cat.buttons.forEach(button => {
            if (button.format) {
              // to make sure we don't have duplicates
              if (computedFormats.indexOf(button.format) === -1) {
                computedFormats.push(button.format);
              }
            }
          });
        }); // add font separately

        if (this.isFontMenusVisible) {
          computedFormats.push('font');
          computedFormats.push('size');
        }

        computedFormats = computedFormats.concat(SF_DEFAULT_FORMATS);
        return computedFormats;
      }
      /**
       * This is for conversion from <font size="">
       * to a quill size format. The font tag size is defined as
       * an integer between 1-7 with 3 being "normal" or default
       * there is no specified meaning to these sizes, so this is
       * a fairly arbitrary mapping based on experiments in the inspector
       * with font tags and slds
       * @param {Number} fontSize - Refers to the value of the size attribute
       * in a font tag
       * @returns {Number} - Value that corresponds to the right pixel size
       * in the FONT_SIZE_MAP to be rendered
       */


      getNormalizedFontSize(fontSize) {
        const size = fontSize || 3;
        const relativeSize = /^[+-]\d/.test(size) ? Number(size) + 3 : Number(size);
        let normalizedSize = relativeSize > 7 ? 7 : relativeSize;
        normalizedSize = relativeSize < 1 ? 1 : normalizedSize;
        return normalizedSize;
      }
      /**
       * Add matchers to quill so that particular tags can be converted from
       * one to another
       * Conversions:
       *      <font>    -> <span>
       *      <strike>  -> <s>
       *      <tt>      -> <code>
       *      <acronym> -> <abbr>
       *      <table>   -> {tableBlot}
       *      text-decoration
       *          underline    -> <underline>
       *          line-through -> <strike>
       */


      addTagMatchers() {
        // Convert font tags to spans
        this.quill.clipboard.addMatcher('font', (node, delta) => {
          let size = node.getAttribute('size'); // map <font> integers to px sizes

          if (size) {
            size = FONT_SIZE_MAP[this.getNormalizedFontSize(size)];
          } // size may still be undefined, that means it won't be applied
          // so this is fine


          const nodeFormats = {
            font: node.getAttribute('face'),
            // trust the defined font face
            size,
            color: node.getAttribute('color') // color is css compatible

          };
          return delta.compose(new Quill$2.Delta().retain(delta.length(), nodeFormats));
        }); // convert <strike> to <s>

        this.quill.clipboard.addMatcher('strike', (node, delta) => {
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            strike: true
          }));
        }); // convert <tt> to <code>

        this.quill.clipboard.addMatcher('tt', (node, delta) => {
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            code: true
          }));
        }); // convert <acronym> to <abbr>

        this.quill.clipboard.addMatcher('acronym', (node, delta) => {
          const title = node.getAttribute('title');
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            abbr: title ? title : true
          }));
        });
        this.quill.clipboard.addMatcher('span[style*=text-decoration]', (node, delta) => {
          const computedStyle = getComputedStyle(node) || node.style;
          const underline = computedStyle.textDecoration.match(/underline/);
          const strike = computedStyle.textDecoration.match(/line-through/);
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            underline: underline ? true : false,
            strike: strike ? true : false
          }));
        }); // This matcher detects tables, and if tables are disabled, returns a normal
        // delta, otherwise it applies the table format

        this.quill.clipboard.addMatcher('table', node => {
          if (this.formats.indexOf('table') === -1) {
            // convert creates a delta from html, in this case the html
            // *inside* the <table>
            return this.quill.clipboard.convert(node.innerHTML); // eslint-disable-line lwc/no-inner-html
          }

          const tableBlot = Quill$2.import('formats/table');
          return new Quill$2.Delta().insert({
            table: tableBlot.value(node)
          });
        });
      }
      /**
       * Initialize a new Quill instance and attach the required
       * handlers for various events
       *      1. Compute information required for configuring Quill
       *      2. Initialize Quill by passing in the computed configuration
       *      3. Add slds classes to editor element generated on init of Quill
       *      4. Add handlers for various events:
       *          a. on text change - dispatch change event
       *          b. on selection change update font and size menu values
       *          c. on double click, open link insertion panel if target is anchor
       *          d. attach custom handler for clicking on link insert button
       */


      initializeQuill() {
        // Passing in the proxy object causes Quill to error out on
        // initialization - so unwrap the editor and toolbar elements
        const container = lwc.unwrap(this.template.querySelector('.editor'));
        const toolbar = lwc.unwrap(this.template.querySelector('.slds-rich-text-editor__toolbar'));
        const computedFormats = this.computeFormats();
        const placeholder = this.placeholder;
        this._hasBeenFocused = false; // Quill Configuration: https://quilljs.com/docs/configuration/

        const quillConfig = {
          modules: {
            toolbar,
            keyboard: {
              bindings
            }
          },
          formats: computedFormats,
          placeholder
        };
        this.quill = new Quill$2(container, quillConfig);
        const editor = this.quill.root;
        this.addInitialClassesAndAttributesToEditor(this.quill.root);
        const imeHandler = new IMEHandler$1(this);
        imeHandler.initializeEmptyCharHack(); // If the editor is 'blank' it still contains a new
        // line (<p><br></p>); check if it is in fact blank
        // If so, we just use an empty string for the value
        // If not blank, clean the editor's contents
        // Fire a change event with the cleaned content as the value

        this.quill.on('text-change', () => {
          let cleanedContent = '';

          if (!this.quill.editor.isBlank()) {
            const editorContents = this.quill.scroll.domNode.innerHTML; // eslint-disable-line lwc/no-inner-html

            cleanedContent = inputRichTextLibrary$1.cleanOutput(editorContents);
          } // make sure we don't send the hacky empty characters back to the user


          cleanedContent = imeHandler.clearEmptyChars(cleanedContent);
          this.internalValue = cleanedContent;
          this.dispatchChangeEvent();
        }); // Update the font, font size menu display values and button pressed state
        // depending on where the cursor is at the time

        this.quill.on('selection-change', range => {
          if (!this._hasBeenFocused) {
            // Due to a bug in quill setting the link format before focusing the cursor in
            // the editor causes the `ql-blank` to never be removed, this change prevents enabling
            // the link button until the editor has been focused (by the user)
            const qlLink = this.template.querySelector('.ql-link');

            if (qlLink) {
              qlLink.removeAttribute('disabled');
            }

            this._hasBeenFocused = true;
          }

          let format = null;

          if (range) {
            // If no range, nothing is selected
            format = this.quill.getFormat(range);
            this.updateFontMenu(format);
            this.updateSizeMenu(format);
            this.updateTextColorButton(format);
          }

          this.updateButtonPressedState(range);
        }); // Update button pressed state depending on what the user is typing.

        this.quill.on('scroll-optimize', () => {
          requestAnimationFrame(() => {
            const range = this.quill.selection.getRange()[0];
            this.updateButtonPressedState(range);
          });
        }); // If user double clicks on a link node in the editor,
        // open the link insertion panel with the href value
        // populated in the input

        this.quill.scroll.domNode.addEventListener('dblclick', clickEvt => {
          const linkNode = this.getEnclosingLinkNode(clickEvt.target);

          if (linkNode) {
            this.expandSelectionToNode(linkNode);
            this.openLinkPanel(linkNode.getAttribute('href'));
          }
        });
        const toolbarModule = this.quill.getModule('toolbar');
        toolbarModule.addHandler('link', () => {
          this.linkButtonClickHandler();
        });
        toolbarModule.addHandler('image', () => {
          this.imageButtonClickHandler();
        });
        const previousCleanHandler = toolbarModule.handlers.clean;
        toolbarModule.addHandler('clean', () => {
          previousCleanHandler.call(this);
          const range = this.quill.getSelection();

          if (range) {
            const format = this.quill.getFormat(range);
            this.updateFontMenu(format);
            this.updateSizeMenu(format);
            this.updateTextColorButton(format);
          }

          this.updateButtonPressedState(range);
        }); // Add tag matchers

        this.addTagMatchers(); // Set initial value passed in to the editor

        if (this.internalValue) {
          this.quill.clipboard.dangerouslyPasteHTML(this.internalValue);
        } // When the editor is focused, set the slds-has-focus class and
        // dispatch focus event to execute onfocus method thats passed in


        editor.addEventListener('focus', () => {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.add('slds-has-focus');
          this.dispatchEvent(new CustomEvent('focus'));
        }); // When the editor is blurred, remove the slds-has-focus class and
        // dispatch blur event to execute onblur method thats passed in

        editor.addEventListener('blur', () => {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.remove('slds-has-focus');
          this.dispatchEvent(new CustomEvent('blur'));
        }); // If a file was pasted and is of the image formats supported,
        // proceed to upload the image and insert into the editor

        editor.addEventListener('paste', pasteEvt => {
          const clipboardData = pasteEvt.clipboardData;

          if (clipboardData && clipboardData.files && clipboardData.files.length && clipboardData.types.indexOf('text/html') === -1) {
            const pastedFile = clipboardData.files[0];

            if (ALLOWED_IMAGE_FORMATS.indexOf(pastedFile.type) > -1) {
              pasteEvt.preventDefault();
              pasteEvt.stopPropagation();
              inputRichTextLibrary$1.uploadAndInsertSelectedFile(this.quill, pastedFile, this.shareWithEntityId);
            }
          }
        });

        if (this._pendingFormats) {
          while (this._pendingFormats.length > 0) {
            const toDo = this._pendingFormats.shift();

            this.setFormat(toDo);
            this.syncFontMenus();
          }
        }
      } // Set Editor state to Disabled:
      // Disable Buttons, Comboboxes and the Editor

      /**
       * Set editor's state depending on the disabled attribute value
       * If disabled is set to true:
       *      a. Disable each button
       *      b. Disable the editor
       * If disabled is false:
       *      a. Ensure buttons are not disabled
       *      b. Enable the editor
       * Note: Font and font size menus are disabled directly
       *       based on the disabled attribute
       */


      setEditorAndButtonState() {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);

        if (this.disabled) {
          buttonList.forEach(button => {
            button.setAttribute('disabled', true);
          });

          if (this.quill) {
            this.quill.disable();
          }
        } else {
          buttonList.forEach(button => {
            // prevent link button from being enabled until editor was focused
            if (!this._hasBeenFocused && button.classList.contains('ql-link')) {
              button.setAttribute('disabled', true);
            } else {
              button.removeAttribute('disabled');
            }
          });

          if (this.quill) {
            this.quill.enable();
          }
        }
      }
      /**
       * Set appropriate error classes based on the valid attribute value
       * If valid attribute is false:
       *      a. Set the slds error class on the editor element
       *      b. Unhide the element containing the error message
       *      c. Set aria-describedby to point to error message element
       */


      setEditorValidityState() {
        // Checking validity to append error class
        if (!this.valid) {
          // Add the error class on the editor
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.add('slds-has-error'); // Set editor's aria-describedby to point to error message element

          const editorElement = this.quill.root;
          editorElement.setAttribute('aria-describedby', this.errorMessageId);
        }
      }
      /**
       * Actions to be taken on rerender if the link insertion panel is open or closed
       * If the create link panel is opened:
       *      1. Correctly position the create link panel and set focus to its input
       *      2. Attach a document click handler to handle close on click out on the
       *         create link panel
       * If the create link panel is closed:
       *      Remove the document click handler
       */


      handleLinkPanelOpen() {
        const that = this; // Position the create link panel

        if (this.linkPanelOpen) {
          const createLinkPanel = this.template.querySelector('.slds-popover__body');
          const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);
          this.calculateLinkPanelPositioning(createLinkPanel, buttonList);
          this.template.querySelector('.link-input').focus(); // Stop propagation of this event or the document click handler
          // will get executed immediately and close the create link panel
          // Attach document click handler for close on click out of the
          // create link panel

          window.event.stopPropagation();

          this._documentClickHandler = function (e) {
            that.documentClickHandler(that, e);
          };

          document.addEventListener('click', this._documentClickHandler);
        } else {
          // Remove the document click handler when the link panel is closed
          document.removeEventListener('click', this._documentClickHandler);
        }
      }
      /**
       * Generate a unique id for the errormessage and label
       */


      connectedCallback() {
        this.classList.add('slds-form-element__control');
      }

      get uniqueLabelId() {
        const label = this.template.querySelector('[data-label]');
        return getRealDOMId(label);
      }

      activateEditor(e) {
        // Initialize the Quill instance on initial render
        if (this.initialRender) {
          this.setupToolbar();
          this.setupButtons();
          this.attachCustomButtonHandlers();
          this.initializeQuill();
          this.setEditorValidityState();
          this.initialRender = false;
          this.setEditorAndButtonState();
          this.handleLinkPanelOpen();
          this.quillNotReady = false;

          if (e) {
            const shouldFocus = e.target.classList.contains('standin') || e.target.tagName === 'lightning-formated-rich-text';

            if (shouldFocus) {
              this.quill.setSelection(this.quill.getLength());
            }
          }
        }
      }
      /**
       * On the first render cycle:
       *      1. Set up button tabindexes to be accessible
       *      2. Attach custom handlers for custom buttons
       *      3. Initialize the Quill instance
       * On every rerender:
       *      1. Set editor's disabled state based on disabled attribute
       *      2. Set editor's valid state based on the valid attribute
       *      3. Handle cases when create link panel is opened or closed
       */


      renderedCallback() {
        this.setEditorAndButtonState();
        this.handleLinkPanelOpen();
      }
      /* *******************************
          Keyboard Button Navigation
      ******************************** */

      /**
       * Move to the next button on the toolbar
       * Wrap around to the first button if currently on last
       * Move to next button by:
       *      1. Setting tabindex to 0 on the new button and -1 on the rest
       *      2. Setting focus on the new button
       * @param {Array} buttonList - Array of toolbar button elements
       * @param {Number} currentIndex - Index on which focus is on currently
       */


      moveToNextButton(buttonList, currentIndex) {
        // Determine next index to move to
        let newIndex = currentIndex + 1;

        if (newIndex === buttonList.length) {
          newIndex = 0;
        } // Set tabindex 0 on new button moved to and -1 on rest


        this.setButtonTabindex(buttonList, newIndex);
        buttonList[newIndex].focus();
      }
      /**
       * Move to the previous button on the toolbar
       * Wrap around to the last button if currently on first
       * Move to previous button by:
       *      1. Setting tabindex to 0 on the new button and -1 on the rest
       *      2. Setting focus on the new button
       * @param {Array} buttonList - Array of toolbar button elements
       * @param {Number} currentIndex - Index on which focus is on currently
       */


      moveToPreviousButton(buttonList, currentIndex) {
        // Determine previous index to move to
        let newIndex = currentIndex - 1;

        if (newIndex === -1) {
          newIndex = buttonList.length - 1;
        } // Set tabindex 0 on new button moved to and -1 on rest


        this.setButtonTabindex(buttonList, newIndex);
        buttonList[newIndex].focus();
      }
      /**
       * Navigate the toolbar buttons based on the keyboard input:
       *      1. Determine the current button by capturing event's target
       *      2. If user pressed the right arrow, move to the next button in toolbar
       *      3. If user pressed the left arrow, move to the previous button in toolbar
       * @param {Event} evt - Keyboard event to retrieve target and keyCode from
       */


      navigateToolbar(evt) {
        this.activateEditor();
        const event = evt || window.event;
        const target = event.target;
        const buttonList = Array.prototype.slice.call(this.template.querySelectorAll(TOOLBAR_SELECTOR));

        if (target && target.classList.contains('slds-button')) {
          const currentIndex = buttonList.indexOf(target);

          if (currentIndex === -1) {
            return; // somehow the button that caught the event is not in the toolbar; ignore
          }

          if (event.keyCode === keyCodes$1.right) {
            this.moveToNextButton(buttonList, currentIndex);
          }

          if (event.keyCode === keyCodes$1.left) {
            this.moveToPreviousButton(buttonList, currentIndex);
          }
        }
      }
      /* ***********************************
           Inline image insertion handling
         *********************************** */

      /**
       * 1. Load the browser's native file selector
       * 2. Upload the selected file
       * 3. Insert the uploaded image into the editor
       */


      imageButtonClickHandler() {
        this.loadNativeFileSelector(fileList => {
          inputRichTextLibrary$1.uploadAndInsertSelectedFile(this.quill, fileList[0], this.shareWithEntityId);
        });
      }
      /**
       * 1. Load the browser's native file selector
       *     a. File selector will only show files of certain file types
       *     b. Supported file types - png, jpg, jpeg, gif
       * 2. Execute callback with the file list as param after a file has been selected
       * @param {Function} callback - Callback to be executed after file selection
       */


      loadNativeFileSelector(callback) {
        const container = document.createDocumentFragment();
        const input = document.createElement('input');
        input.type = 'file';
        input.multiple = false;
        input.accept = ALLOWED_IMAGE_FORMATS;

        input.onchange = function () {
          callback(this.files);
        };

        container.appendChild(input);
        input.click();
      }
      /* ***************************
           Link insertion handling
         *************************** */

      /**
       * Custom handler for onclick of link insertion button
       * 1. Get the text selected by user to insert a link on
       * 2. Get the formatting already present on the selected text
       * 3. If selected text already has a link format on it:
       *     a. If length of selected text is 0
       *         i.  Expand the selection length to the enclosing anchor node
       *         ii. Open create link panel with href value populated in input
       *     b. If length of selected text is more than 0
       *         i. Remove the link formatting from that selection
       * 4. If selected text does not have a link format on it:
       *     a. Open create link panel with 'http://' populated in input
       */


      linkButtonClickHandler() {
        const quillApi = this.quill;
        const selection = quillApi.getSelection();
        const format = quillApi.getFormat();
        quillApi.focus();

        if (format.link) {
          if (selection.length === 0) {
            // when cursor is on a link with no selection, show edit panel
            const nodeOnCursor = quillApi.getLeaf(selection.index)[0].domNode;
            const linkNode = this.getEnclosingLinkNode(nodeOnCursor);
            this.expandSelectionToNode(linkNode);
            this.openLinkPanel(linkNode.getAttribute('href'));
          } else {
            // when a link is selected, unlink it
            quillApi.format('link', false);
          }
        } else {
          this.openLinkPanel();
        }
      }
      /**
       * Update the link value to be saved as user types in create link panel input
       * @param {Event} event - Keyboard event to detect value of input
       */


      handleLinkValueChange(event) {
        event.stopPropagation(); // When pressing ESC after some input, a change evt gets fired too
        // During this case, detail doesn't exist and there is no change in value

        if (event.detail) {
          this.linkValue = event.detail.value;
        }
      }
      /**
       * Open the create link panel with the value of link already set
       * on the selection or the default value if no value is set
       * @param {String} value - Value to populate in create link panel input
       */


      openLinkPanel(value) {
        this.linkValue = value ? value : 'http://';
        this.linkPanelOpen = true;
      }
      /**
       * Setting linkPanelOpen will trigger a rerender cycle,
       * causing the create link panel to close is value is set to false
       */


      closeLinkPanel() {
        this.linkValue = 'http://';
        this.linkPanelOpen = false;
      }
      /**
       * Set the text selection's format to link type,
       * with the href value being the value typed in by
       * the user in the create link panel input box
       */


      saveLink() {
        const quillApi = this.quill;
        const selection = quillApi.getSelection(true);

        if (selection.length === 0) {
          quillApi.insertText(selection.index, this.linkValue, {
            link: this.linkValue
          });
        } else {
          quillApi.format('link', this.linkValue);
        }

        this.closeLinkPanel();
      }
      /**
       * Close create link panel without saving
       */


      cancelLink() {
        this.closeLinkPanel();
      }
      /**
       * Calculate and position the create link panel correctly based on the editor's bounds
       * 1. Attempt to align the panel's center with the insert link button's center
       * 2. If panel's right edge goes past the editor's right edge, align both the right edges
       * 3. If panel's left edge goes past the editor's left edge, align both the left edges
       * 4. Vertically position the panel based on the toolbar's position
       * @param {HTMLElement} createLinkPanel -
       */


      calculateLinkPanelPositioning(createLinkPanel) {
        const linkButton = this.template.querySelector('.ql-link');
        const toolbar = this.template.querySelector('.ql-toolbar');
        createLinkPanel.style.position = 'absolute';
        createLinkPanel.style.width = CREATE_LINK_PANEL_WIDTH + 'px'; // Horizontal Positioning of Create Link Panel:
        // Align the center of the panel with the center of the button

        const linkButtonCenter = linkButton.offsetLeft + linkButton.offsetWidth / 2;
        createLinkPanel.style.left = linkButtonCenter - CREATE_LINK_PANEL_WIDTH / 2 + 'px';
        const createLinkPanelLeft = getStyleAsInt(createLinkPanel, 'left');
        const createLinkPanelWidth = getStyleAsInt(createLinkPanel, 'width'); // If panel is going out of the editor/toolbar on the right, position the right
        // of the panel to the right of the editor/toolbar

        if (createLinkPanelLeft + createLinkPanelWidth > toolbar.offsetWidth) {
          const diff = createLinkPanelLeft + createLinkPanelWidth - toolbar.offsetWidth;
          createLinkPanel.style.left = createLinkPanelLeft - diff + 'px';
        } // If panel is going out of the editor/toolbar on the left, position the left
        // of the panel to the left of the editor/toolbar


        if (getStyleAsInt(createLinkPanel, 'left') < toolbar.offsetLeft) {
          createLinkPanel.style.left = toolbar.offsetLeft + 'px';
        } // Vertical Positioning of Create Link Panel


        if (this.variant === 'bottom-toolbar') {
          createLinkPanel.style.top = toolbar.offsetTop - createLinkPanel.offsetHeight + 'px';
        } else {
          createLinkPanel.style.top = toolbar.offsetTop + toolbar.offsetHeight + 'px';
        }
      }
      /**
       * Get the enclosing link node.
       * Search upward through parentNode.
       *
       * @param {Object} node - node of which to find enclosing node
       * @returns {Object} returns the enclosing link node
       */


      getEnclosingLinkNode(node) {
        const quillApi = this.quill;
        const endNode = quillApi.scroll.domNode;
        let currentNode = node;

        while (currentNode && currentNode !== endNode) {
          if (currentNode.tagName === 'A') {
            return currentNode;
          }

          currentNode = currentNode.parentNode;
        }

        return null;
      }
      /**
       * Expand selection to the whole node
       * when selection only covers the node partially
       *
       * @param {Object} node - node of which to expand selection
       */


      expandSelectionToNode(node) {
        const quillApi = this.quill;
        const blot = quillApi.constructor.find(node);

        if (blot) {
          quillApi.focus();
          quillApi.setSelection(quillApi.getIndex(blot), blot.length());
        }
      }
      /**
       * Handle the ENTER and ESC keys appropriately:
       *  1. Handle ENTER key to save the input value
       *  2. Handle ESC key to close the create link panel
       *
       * @param {Event} evt Keyboard event to detect and handle the key pressed
       */


      linkKeyboardPress(evt) {
        this.activateEditor();
        let handled = false;

        if (evt.keyCode === keyCodes$1.enter) {
          this.saveLink();
          handled = true;
        } else if (evt.keyCode === keyCodes$1.escape) {
          this.closeLinkPanel();
          handled = true;
        } // If the events are handled,
        // let them die here


        if (handled) {
          evt.stopPropagation();
          evt.preventDefault();
        }
      }
      /**
       * Event handler for click - for close on click out
       * @param {Object} self - Reference of the inputRichText component
       * @param {Event} e - Click event
       */


      documentClickHandler(self, e) {
        const createLinkPanel = self.template.querySelector('.slds-popover');
        const event = e || window.event;
        const target = event.target || event.srcElement;
        const clickedInside = createLinkPanel.contains(target);

        if (createLinkPanel && !clickedInside) {
          self.closeLinkPanel();
        }
      }
      /**
       * Set the format of the text to font selected from the font dropdown
       * If user selects the default font, we do not set a font name when
       * formatting the text
       * Set the selected font so the font menu displays the right value
       * @param {Event} fontChangeEvt - Event fired by dropdown combobox
       */


      selectFont(fontChangeEvt) {
        fontChangeEvt.stopPropagation();
        const selectFont = fontChangeEvt.detail.value;
        let formatFont = selectFont;

        if (formatFont === DEFAULT_FONT_NAME_VALUE) {
          // We don't want quill to set the font name to 'default'
          formatFont = '';
        }

        const quillApi = this.quill;
        quillApi.focus();
        quillApi.format('font', formatFont);
        this.selectedFontValue = selectFont;
      }
      /**
       * Set the format of the text to font size selected from the dropdown
       * @param {Event} sizeChangeEvt - Event fired by dropdown combobox
       */


      selectSize(sizeChangeEvt) {
        sizeChangeEvt.stopPropagation();
        const selectSize = sizeChangeEvt.detail.value;
        const quillApi = this.quill;
        quillApi.focus();
        quillApi.format('size', selectSize);
        this.selectedSizeValue = selectSize;
      }
      /**
       * Update the value shown by the font dropdown based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateFontMenu(format) {
        const newFont = format && format.font ? format.font : DEFAULT_FONT_NAME_VALUE;
        this.selectedFontValue = newFont;
      }
      /**
       * Update the value shown by the font size dropdown based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateSizeMenu(format) {
        const newSize = format && format.size ? format.size : DEFAULT_FONT_SIZE_VALUE;
        this.selectedSizeValue = newSize;
      }
      /**
       * Update the color shown by the color picker button based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateTextColorButton(format) {
        const newTextColor = format && format.color ? format.color : DEFAULT_TEXT_COLOR_VALUE;
        this.selectedTextColorValue = newTextColor;
      }
      /**
       * Whenever the color changes, it will trigger quill API color change
       * @param {Object} event - change event with text color from colorpicker.
       */


      handleColorUpdate(event) {
        const quillApi = this.quill;
        this.selectedTextColorValue = event.detail.color;
        quillApi.format('color', this.selectedTextColorValue);
      }
      /**
       * Whenever the quill state changes, update each button's pressed state based on the format of given range.
       * @param {Object} range - text range from quill.
       */


      updateButtonPressedState(range) {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);
        const formats = range ? this.quill.getFormat(range) : {};
        buttonList.forEach(button => {
          if (button) {
            const {
              format
            } = button.dataset;
            const value = button.getAttribute('value');
            let isActive = false;

            if (value === null) {
              isActive = !!formats[format];
            } else if (value === '' && format === 'align') {
              isActive = !formats[format];
            } else {
              isActive = formats[format] === value;
            }

            button.classList.toggle('slds-is-selected', isActive);
            button.setAttribute('aria-pressed', isActive);
          }
        });
      }
      /**
       * Check if the current device is desktop or not.
       * @returns {boolean} true if its desktop, false otherwise.
       */


      get isDesktop() {
        return configProvider$1.getFormFactor() === 'DESKTOP';
      }
      /**
       * Fire a change event by passing the contents of the
       * editor as the value
       */


      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this.internalValue
          }
        }));
      }
      /**
       * Reserved for internal use. Insert text in the rich text editor at cursor position.
       *
       * @param {String} text - text to insert
       */


      insertTextAtCursor(text) {
        if (!this.quill) {
          this.activateEditor();
        }

        const selection = this.quill.getSelection(true);
        const cursorPosition = selection ? selection.index : this.quill.getLength() - 1;

        if (selection && selection.length !== 0) {
          this.quill.deleteText(selection.index, selection.length);
        }

        this.quill.insertText(cursorPosition, text);
      }

    }

    lwc.registerDecorators(LightningInputRichText, {
      publicProps: {
        label: {
          config: 0
        },
        labelVisible: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        disabledCategories: {
          config: 0
        },
        formats: {
          config: 0
        },
        variant: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        customButtons: {
          config: 0
        },
        shareWithEntityId: {
          config: 0
        },
        value: {
          config: 3
        },
        valid: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "setFormat", "getFormat", "insertTextAtCursor"],
      track: {
        _valid: 1,
        _disabled: 1,
        linkPanelOpen: 1,
        selectedFontValue: 1,
        selectedSizeValue: 1,
        quillNotReady: 1,
        selectedTextColorValue: 1
      }
    });

    var _lightningInputRichText = lwc.registerComponent(LightningInputRichText, {
      tmpl: _tmpl$y
    });

    function tmpl$A($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_custom_element("lightning-input-rich-text", _lightningInputRichText, {
        props: {
          "value": $cmp._displayValue,
          "formats": $cmp.formats,
          "messageWhenBadInput": $cmp._helpMessage,
          "valid": $cmp._noErrors,
          "disabled": $cmp.disabled,
          "disabledCategories": $cmp.disabledCategories,
          "customButtons": $cmp.customButtons
        },
        key: 6,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleChange)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur))
        }
      }, [])];
    }

    var _tmpl$z = lwc.registerTemplate(tmpl$A);
    tmpl$A.stylesheets = [];

    if (_implicitStylesheets$e) {
      tmpl$A.stylesheets.push.apply(tmpl$A.stylesheets, _implicitStylesheets$e);
    }
    tmpl$A.stylesheetTokens = {
      hostAttribute: "lightning-quill_quill-host",
      shadowAttribute: "lightning-quill_quill"
    };

    const i18n$i = {
      required: labelRequired
    };
    const defaultFormats = ['abbr', 'address', 'align', 'alt', 'background', 'bdo', 'big', 'blockquote', 'bold', 'cite', 'clean', 'code', 'code-block', 'color', 'data-fileid', 'del', 'dfn', 'direction', 'divider', 'dl', 'dd', 'dt', 'font', 'header', 'image', 'indent', 'ins', 'ins', 'italic', 'kbd', 'link', 'list', 'q', 'samp', 'script', 'size', 'small', 'strike', 'sup', 'table', 'tt', 'underline', 'var'];

    class LightningQuill extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._required = false;
        this._helpMessage = '';
        this._noErrors = true;
        this._fieldLevelHelp = void 0;
        this._disabled = false;
        this._displayValue = void 0;
        this.label = void 0;
        this.disabledCategories = '';
        this.messageWhenValueMissing = void 0;
        this.customButtons = void 0;
        this.fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.uniqueId = generateUniqueId();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._displayValue = value ? value : '';
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      focus() {
        this.inputRichTextElement.focus();
        this.handleFocus();
      }

      blur() {
        this.inputRichTextElement.blur();
        this.handleBlur();
      }

      get validity() {
        return this._constraint.validity;
      }

      checkValidity() {
        return this._constraint.checkValidity();
      }

      reportValidity() {
        return this._constraint.reportValidity(message => {
          // The errors are shown via the underlying input-rich-text component,
          // we should change it to be more in-line with the other input components
          this._helpMessage = message;
          this._noErrors = message === '';
        });
      }

      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleChange(event) {
        this._value = event.detail.value;
      }

      get i18n() {
        return i18n$i;
      }

      get formats() {
        return defaultFormats;
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.value)
          });
        }

        return this._constraintApi;
      }

      get inputRichTextElement() {
        return this.template.querySelector('lightning-input-rich-text');
      }

    }

    lwc.registerDecorators(LightningQuill, {
      publicProps: {
        label: {
          config: 0
        },
        disabledCategories: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        customButtons: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _required: 1,
        _helpMessage: 1,
        _noErrors: 1,
        _fieldLevelHelp: 1,
        _disabled: 1,
        _displayValue: 1
      }
    });

    var _lightningQuill = lwc.registerComponent(LightningQuill, {
      tmpl: _tmpl$z
    });

    function stylesheet$g(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$g = [stylesheet$g];

    function stylesheet$h(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$h = [stylesheet$h];

    function stylesheet$i(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$i = [stylesheet$i];

    var labelPillDelete = 'Press delete or backspace to remove';

    var labelPillError = 'Error';

    var labelPillRemove = 'Remove';

    var labelPillWarning = 'Warning';

    var labelPillDeleteAndNavigate = 'Press delete or backspace to remove, press enter to navigate';

    function tmpl$B($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        h: api_element,
        c: api_custom_element,
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [!$cmp._hasError ? $cmp._hasMedia ? api_element("span", {
        classMap: {
          "slds-pill__icon_container": true
        },
        key: 4
      }, [api_slot("", {
        key: 5
      }, [], $slotset)]) : null : null, $cmp._hasError ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__icon_container": true,
          "slds-m-left_xx-small": true
        },
        props: {
          "title": $cmp.i18n.pillError,
          "iconName": "utility:warning",
          "variant": "bare",
          "svgClass": "icon-error slds-icon_x-small slds-icon-text-error"
        },
        key: 7
      }, []) : null, $cmp._hasError ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 8
      }, [api_dynamic($cmp.i18n.pillWarning)]) : null, $cmp.hasHref ? api_element("a", {
        classMap: {
          "slds-pill__action": true
        },
        attrs: {
          "href": $cmp.href
        },
        key: 10
      }, [api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 11
      }, [api_dynamic($cmp.label)])]) : null, !$cmp.hasHref ? api_element("span", {
        classMap: {
          "slds-pill__action": true
        },
        key: 13
      }, [api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 14
      }, [api_dynamic($cmp.label)])]) : null, api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-pill__remove": true
        },
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "title": $cmp.i18n.pillRemove,
          "tabIndex": api_tab_index($cmp._tabIndex),
          "alternativeText": $cmp.i18n.pillRemove
        },
        key: 15,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, [])];
    }

    var link = lwc.registerTemplate(tmpl$B);
    tmpl$B.slots = [""];
    tmpl$B.stylesheets = [];
    tmpl$B.stylesheetTokens = {
      hostAttribute: "lightning-pill_link-host",
      shadowAttribute: "lightning-pill_link"
    };

    function tmpl$C($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp._hasMedia ? api_slot("", {
        key: 3
      }, [], $slotset) : null, api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 4
      }, [api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__remove": true
        },
        props: {
          "title": $cmp.i18n.pillRemove,
          "iconName": "utility:close",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default",
          "variant": "bare"
        },
        key: 5,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.assistiveText)])];
    }

    var plain = lwc.registerTemplate(tmpl$C);
    tmpl$C.slots = [""];
    tmpl$C.stylesheets = [];
    tmpl$C.stylesheetTokens = {
      hostAttribute: "lightning-pill_plain-host",
      shadowAttribute: "lightning-pill_plain"
    };

    function tmpl$D($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element,
        ti: api_tab_index
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("a", {
        attrs: {
          "href": $cmp.href,
          "tabindex": api_tab_index($cmp._tabIndex),
          "aria-selected": $cmp._ariaSelected,
          "role": $cmp._role
        },
        key: 2,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleClick))
        }
      }, [$cmp._hasMedia ? api_slot("", {
        key: 4
      }, [], $slotset) : null, api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 5
      }, [api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__remove": true
        },
        props: {
          "title": $cmp.i18n.pillRemove,
          "iconName": "utility:close",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default",
          "variant": "bare"
        },
        key: 6,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 7
      }, [api_dynamic($cmp.assistiveText)])])];
    }

    var plainLink = lwc.registerTemplate(tmpl$D);
    tmpl$D.slots = [""];
    tmpl$D.stylesheets = [];
    tmpl$D.stylesheetTokens = {
      hostAttribute: "lightning-pill_plainLink-host",
      shadowAttribute: "lightning-pill_plainLink"
    };

    const i18n$j = {
      pillDelete: labelPillDelete,
      pillError: labelPillError,
      pillRemove: labelPillRemove,
      pillWarning: labelPillWarning,
      pillDeleteAndNavigate: labelPillDeleteAndNavigate
    };
    const VARIANT$1 = {
      PLAIN: 'plain',
      PLAIN_LINK: 'plainLink',
      LINK: 'link'
    };

    function modifyAttribute(el, name, value) {
      if (!el.isPlainLink) {
        if (value !== null && value !== undefined && value !== '') {
          el.setAttribute(name, value);
        } else {
          el.removeAttribute(name);
        }
      } else {
        el.removeAttribute(name);
      }
    }
    /**
     * A pill displays a label that can contain links and can be removed from view.
     * @slot default Placeholder for an image, such as an icon or avatar.
     */


    class LightningPill extends lwc.LightningElement {
      /**
       * The URL of the page that the link goes to.
       * @type {string}
       */
      get href() {
        return this._href;
      }

      set href(value) {
        this._href = value;

        if (this._connected && (this.isPlainLink || this.isLink)) {
          this.updateLinkInfo(value);
        }
      }

      render() {
        switch (this.variant) {
          case VARIANT$1.PLAIN:
            return plain;

          case VARIANT$1.PLAIN_LINK:
            return plainLink;

          case VARIANT$1.LINK:
          default:
            return link;
        }
      }
      /**
       * If present, the pill is shown with a red border and an error icon on the left of the label.
       * @type {boolean}
       * @default false
       */


      get hasError() {
        return this._hasError || false;
      }

      set hasError(value) {
        this._hasError = normalizeBoolean(value);
      }

      get assistiveText() {
        return this.variant === VARIANT$1.PLAIN_LINK ? this.i18n.pillDeleteAndNavigate : this.i18n.pillDelete;
      }

      constructor() {
        super();
        this._href = void 0;
        this.label = void 0;
        this.name = void 0;
        this.variant = VARIANT$1.LINK;
        this._role = void 0;
        this._ariaSelected = void 0;
        this._hasMedia = true;
        this._hasError = void 0;
        this._tabIndex = void 0;
        this._connected = false;

        this._dispatcher = () => {};

        this.addEventListener('keydown', this.handleKeypress.bind(this));
      }

      get pillClass() {
        const cssClass = ['slds-pill'];

        switch (this.variant) {
          case VARIANT$1.PLAIN:
          case VARIANT$1.PLAIN_LINK:
            break;

          case VARIANT$1.LINK:
          default:
            cssClass.push('slds-pill_link');
        }

        return cssClass;
      }

      checkMediaElement() {
        if (!this._mediaElement) {
          this._mediaElement = this.template.querySelector('slot');
        }

        return this._mediaElement && this._mediaElement.assignedNodes().length > 0;
      }

      renderedCallback() {
        const el = this.isPlainLink ? this.template.querySelector('a') : this;
        this.pillClass.forEach(name => el.classList.add(name)); // check if a component was passed into the slot

        this._hasMedia = this.checkMediaElement();
        classListMutation(this.classList, {
          'slds-has-error': this.hasError
        }); // set attributes to self if variant is plain or link

        modifyAttribute(this, 'tabindex', this.tabIndex);
        modifyAttribute(this, 'role', this.role);
        modifyAttribute(this, 'aria-selected', this.ariaSelected);
      }
      /**
       * Reserved for internal use. Specifies whether the element variant is a plain link.
       * @type {boolean}
       * @return {boolean} true if variant is a plain link.
       */


      get isPlainLink() {
        return this.variant === VARIANT$1.PLAIN_LINK;
      }

      get isLink() {
        return this.variant === VARIANT$1.LINK;
      }
      /**
       * Reserved for internal use. Use tabindex instead to indicate if an element should be focusable.
       * A value of 0 means that the pill is focusable and
       * participates in sequential keyboard navigation. A value of -1 means
       * that the pill is focusable but does not participate in keyboard navigation.
       * @type {number}
       */


      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(value) {
        this._tabIndex = value;
        modifyAttribute(this, 'tabindex', this._tabIndex);
      }
      /**
       * Specifies the aria-selected of an element.
       */


      get ariaSelected() {
        return this._ariaSelected;
      }

      set ariaSelected(value) {
        this._ariaSelected = normalizeBoolean(value);
        modifyAttribute(this, 'aria-selected', this._ariaSelected);
      }
      /**
       * Specifies the role of an element.
       */


      get role() {
        return this._role;
      }

      set role(value) {
        this._role = value;
        modifyAttribute(this, 'role', this._role);
      }

      get i18n() {
        return i18n$j;
      }

      get hasHref() {
        return !!this.href;
      }

      get labelElement() {
        if (!this._labelElement) {
          this._labelElement = this.template.querySelector('a.slds-pill__label');
        }

        return this._labelElement;
      }

      get removeIconElement() {
        if (!this._removeIconElement) {
          this._removeIconElement = this.template.querySelector('lightning-primitive-icon');
        }

        return this._removeIconElement;
      }

      connectedCallback() {
        this._connected = true;

        if (this.isPlainLink || this.isLink) {
          this.updateLinkInfo(this.href);
        }
      }

      disconnectedCallback() {
        this._connected = false;
      }

      handleKeypress(event) {
        switch (event.keyCode) {
          case keyCodes.delete:
          case keyCodes.backspace:
            this.handleRemove(event);
            break;

          case keyCodes.enter:
            this.handleEnter(event);
            break;

          default:
        }
      }

      handleEnter() {
        if (this.isPlainLink) {
          if (this.labelElement) {
            this.labelElement.click();
          }
        }
      }

      handleClick(event) {
        if (event.target === this.removeIconElement) {
          // click on the X icon to remove the item
          event.stopPropagation();
          event.preventDefault();
          this.handleRemove(event);
        } else if (this.isPlainLink || this.isLink) {
          this._dispatcher(event);
        }
      }

      handleRemove(event) {
        const removeEvent = new CustomEvent('remove', {
          cancelable: true,
          detail: {
            name: this.name
          }
        });
        this.dispatchEvent(removeEvent);

        if (removeEvent.defaultPrevented) {
          event.stopPropagation();
        }
      }
      /**
       * Reserved for internal use.
       * Sets focus on the anchor element for a plain link.
       */


      focusLink() {
        const el = this.template.querySelector('A');

        if (el) {
          el.focus();
        }
      }

      updateLinkInfo(url) {
        updateRawLinkInfo(this, {
          url: this.makeAbsoluteUrl(url)
        }).then(linkInfo => {
          this._url = linkInfo.url;
          this._dispatcher = linkInfo.dispatcher;
        });
      }

      makeAbsoluteUrl(url) {
        return isAbsoluteUrl(url) ? url : `http://${url}`;
      }

    }

    lwc.registerDecorators(LightningPill, {
      publicProps: {
        href: {
          config: 3
        },
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        variant: {
          config: 0
        },
        hasError: {
          config: 3
        },
        isPlainLink: {
          config: 1
        },
        tabIndex: {
          config: 3
        },
        ariaSelected: {
          config: 3
        },
        role: {
          config: 3
        }
      },
      publicMethods: ["focusLink"],
      track: {
        _href: 1,
        _role: 1,
        _ariaSelected: 1,
        _hasMedia: 1,
        _hasError: 1,
        _tabIndex: 1
      }
    });

    var _lightningPill = lwc.registerComponent(LightningPill, {
      tmpl: _tmpl$5
    });

    function tmpl$E($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp._src ? api_element("img", {
        attrs: {
          "src": $cmp._src,
          "alt": $cmp.alternativeText,
          "title": $cmp.alternativeText
        },
        key: 2,
        on: {
          "error": _m0 || ($ctx._m0 = api_bind($cmp.handleImageError))
        }
      }, []) : null, $cmp.showInitials ? api_element("abbr", {
        className: $cmp.computedInitialsClass,
        attrs: {
          "title": $cmp.alternativeText
        },
        key: 3
      }, [api_dynamic($cmp.initials)]) : null, $cmp.showIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.fallbackIconName,
          "alternativeText": $cmp.alternativeText,
          "title": $cmp.alternativeText
        },
        key: 4
      }, []) : null];
    }

    var _tmpl$A = lwc.registerTemplate(tmpl$E);
    tmpl$E.stylesheets = [];
    tmpl$E.stylesheetTokens = {
      hostAttribute: "lightning-avatar_avatar-host",
      shadowAttribute: "lightning-avatar_avatar"
    };

    const DEFAULT_SIZE$1 = 'medium';
    const DEFAULT_VARIANT$1 = 'square';
    /**
     * A visual representation of an object.
     */

    class LightningAvatar extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = '';
        this.fallbackIconName = void 0;
        this.initials = void 0;
        this._size = DEFAULT_SIZE$1;
        this._src = '';
        this._variant = DEFAULT_VARIANT$1;
      }

      /**
       * The size of the avatar. Valid values are x-small, small, medium, and large. This value defaults to medium.
       *
       * @type {string}
       * @default medium
       */
      get size() {
        return this._size;
      }

      set size(value) {
        this._size = normalizeString(value, {
          fallbackValue: DEFAULT_SIZE$1,
          validValues: ['x-small', 'small', 'medium', 'large']
        });
        this.updateClassList();
      }
      /**
       * The URL for the image.
       *
       * @type {string}
       * @required
       */


      get src() {
        return this._src;
      }

      set src(value) {
        this._src = typeof value === 'string' && value.trim() || '';
      }
      /**
       * The variant changes the shape of the avatar. Valid values are empty,
       * circle, and square. This value defaults to square.
       *
       * @type {string}
       * @default square
       */


      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: DEFAULT_VARIANT$1,
          validValues: ['circle', 'square']
        });
        this.updateClassList();
      }

      connectedCallback() {
        this.updateClassList();
      } // update custom element's classList


      updateClassList() {
        const size = this._size;
        const variant = this._variant;
        const classes = classSet('slds-avatar').add({
          'slds-avatar_x-small': size === 'x-small',
          'slds-avatar_small': size === 'small',
          'slds-avatar_medium': size === 'medium',
          'slds-avatar_large': size === 'large'
        }).add({
          'slds-avatar_circle': variant === 'circle'
        });
        classListMutation(this.classList, classes);
      }

      get computedInitialsClass() {
        return classSet('slds-avatar__initials').add(computeSldsClass(this.fallbackIconName)).toString();
      }

      get showInitials() {
        return !this._src && this.initials;
      }

      get showIcon() {
        return !this._src && !this.initials;
      }

      handleImageError(event) {
        // eslint-disable-next-line no-console
        console.warn(`<lightning-avatar> Image with src="${event.target.src}" failed to load.`);
        this._src = '';
      }

    }

    lwc.registerDecorators(LightningAvatar, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        fallbackIconName: {
          config: 0
        },
        initials: {
          config: 0
        },
        size: {
          config: 3
        },
        src: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        _size: 1,
        _src: 1,
        _variant: 1
      }
    });

    var _lightningAvatar = lwc.registerComponent(LightningAvatar, {
      tmpl: _tmpl$A
    });

    function tmpl$F($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        b: api_bind,
        h: api_element,
        c: api_custom_element,
        ti: api_tab_index,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [$cmp._showMore ? api_element("span", {
        classMap: {
          "slds-listbox-toggle": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 3
      }, [api_element("button", {
        classMap: {
          "slds-button": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleMoreClick))
        }
      }, [api_dynamic($cmp.computedPillCountMoreLabel)])]) : null, api_element("ul", {
        className: $cmp.computedListboxClass,
        attrs: {
          "role": "listbox",
          "aria-label": $cmp.label,
          "aria-orientation": "horizontal"
        },
        key: 5,
        on: {
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleClick)),
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.handleKeyDown))
        }
      }, api_iterator($cmp.pillViewModels, function (pillViewModel, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox-item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(7, pillViewModel.pill.item.label)
        }, [api_custom_element("lightning-pill", _lightningPill, {
          props: {
            "label": pillViewModel.pill.item.label,
            "name": index,
            "href": pillViewModel.pill.item.href,
            "tabIndex": api_tab_index(pillViewModel.tabIndex),
            "role": "option",
            "variant": pillViewModel.pill.variant,
            "ariaSelected": "true"
          },
          key: 8,
          on: {
            "click": _m1 || ($ctx._m1 = api_bind($cmp.handlePillClick)),
            "remove": _m2 || ($ctx._m2 = api_bind($cmp.handleRemove)),
            "blur": _m3 || ($ctx._m3 = api_bind($cmp.handlePillBlur)),
            "focus": _m4 || ($ctx._m4 = api_bind($cmp.handlePillFocus))
          }
        }, [pillViewModel.pill.isIcon ? api_custom_element("lightning-icon", _lightningIcon, {
          classMap: {
            "slds-pill__icon_container": true
          },
          props: {
            "iconName": pillViewModel.pill.item.iconName,
            "alternativeText": pillViewModel.pill.item.alternativeText
          },
          key: 10
        }, []) : null, pillViewModel.pill.isAvatar ? api_custom_element("lightning-avatar", _lightningAvatar, {
          classMap: {
            "slds-pill__icon_container": true
          },
          props: {
            "src": pillViewModel.pill.item.src,
            "fallbackIconName": pillViewModel.pill.item.fallbackIconName,
            "variant": pillViewModel.pill.item.variant,
            "size": "x-small",
            "alternativeText": pillViewModel.pill.item.alternativeText
          },
          key: 12
        }, []) : null])]);
      }))];
    }

    var _tmpl$B = lwc.registerTemplate(tmpl$F);
    tmpl$F.stylesheets = [];
    tmpl$F.stylesheetTokens = {
      hostAttribute: "lightning-pillContainer_pillContainer-host",
      shadowAttribute: "lightning-pillContainer_pillContainer"
    };

    var labelContainerLabel = 'Selected Options:';

    var pillContainerMoreLabel = '+{0} more';

    class LightningPillItem {
      constructor(item) {
        this._item = item;
      }

      get item() {
        return this._item;
      }

      get isAvatar() {
        return this._item.type === 'avatar';
      }

      get isIcon() {
        return this._item.type === 'icon';
      }

      get variant() {
        return this._item.href && this._item.href !== '' ? 'plainLink' : 'plain';
      }

    }

    var LightningPillItem$1 = lwc.registerComponent(LightningPillItem, {
      tmpl: _tmpl$5
    });

    const PILL_SELECTOR = 'lightning-pill';
    const i18n$k = {
      containerLabel: labelContainerLabel
    };
    /**
     * A list of pills grouped in a container. This component requires API version 42.0 and later.
     */

    class LightningPillContainer extends lwc.LightningElement {
      /**
       * Aria label for the pill container.
       * @type {string}
       */
      constructor() {
        super();
        this.label = i18n$k.containerLabel;
        this._variant = void 0;
        this._pills = [];
        this._singleLine = false;
        this._isExpanded = false;
        this._isCollapsible = false;
        this._focusedIndex = 0;
        this._focusedTabIndex = 0;
        this._pillsNotFittingCount = void 0;
        this._pillContainerElementId = void 0;
        this._pills = [];
      }

      connectedCallback() {
        this._connected = true;

        if (this.variant !== 'bare') {
          this.classList.add('slds-pill_container');
        }
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }
      }

      renderedCallback() {
        if (this._resizeObserver) {
          // If we have a resize observer and the pill container is not collapsible it means it was changed
          // to not collapsible, we should disconnect the resize observer.
          if (!this.isCollapsible) {
            this._resizeObserver.disconnect();

            this._resizeObserver = undefined;
          }
        } else if (this.isCollapsible) {
          // No resize observer and is collapsible, we should setup the resize observer
          this._resizeObserver = this._setupResizeObserver();
        }

        const ul = this.template.querySelector('ul');

        if (this._pills.length === 0) {
          // If no option is present, set ul has the focus (SLDS require UL has focus).
          ul.tabIndex = 0;
        } else {
          ul.tabIndex = -1;
          this.setFocusedItemTabIndex(0); // Consider adding pills programmatically to empty pill container.
          // UL has focus, so should shift focus to pill.

          if (this.template.querySelector('ul:focus')) {
            this.focus();
          }
        }
      }
      /**
       * The variant changes the appearance of the pill container. Accepted variants
       * include standard and bare. This value defaults to standard.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || 'standard';
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: 'standard',
          validValues: ['standard', 'bare']
        });
      }
      /**
       * Specifies whether to keep the pills in a single line.
       * @type {boolean}
       *
       */


      get singleLine() {
        return this._singleLine;
      }

      set singleLine(value) {
        this._singleLine = normalizeBoolean(value);
      }
      /**
       * Specifies whether the pill container can be collapsed.
       * @type {boolean}
       */


      get isCollapsible() {
        return this._isCollapsible;
      }

      set isCollapsible(value) {
        this._isCollapsible = normalizeBoolean(value);
      }
      /**
       * Specifies whether the pill container is expanded.
       * @type {boolean}
       */


      get isExpanded() {
        return this._isExpanded;
      }

      set isExpanded(value) {
        this._isExpanded = normalizeBoolean(value);
        this.classList.toggle('slds-is-expanded', this._isExpanded);
      }
      /**
       * An array of items to be rendered as pills in a container.
       * @type {list}
       */


      get items() {
        return this._pills;
      }

      set items(value) {
        this._pillsChanged = true;
        value = Array.isArray(value) ? value : [];
        this._pills = value.map(item => new LightningPillItem$1(item));
      }

      get pillViewModels() {
        return this._pills.map((pill, index) => {
          return {
            pill,
            tabIndex: this._focusedIndex === index ? this._focusedTabIndex : -1
          };
        });
      }

      get computedListboxClass() {
        const singleLineClass = this.singleLine ? 'slds-listbox_inline' : '';
        return `slds-listbox slds-listbox_horizontal ${singleLineClass}`;
      }

      get focusedIndex() {
        // NOTE: this._pills is manged by getter, setter. So it won't be null or undefined.
        // So call this._pill.length is safe.
        if (this._focusedIndex >= this._pills.length) {
          // Change is due to itemremove event, should move focus to the last one.
          this._focusedIndex = this._deleteLast ? this._pills.length - 1 : 0;
          this._deleteLast = false;
        } else if (this._focusedIndex < 0) {
          this._focusedIndex = this._pills.length - 1;
        }

        return this._focusedIndex;
      }

      set focusedIndex(value) {
        // Host may asynchronous update items. For example, move focus to latest item with right/left key, then host change items.
        // Then at renderedCallback call, need to update which item should has focus, but index > items.length.
        // When set it, the index is valid, but when rendered, index is not valid, so the validation check is happened at getter.
        this._focusedIndex = value;
      }

      get pillNodes() {
        if (!this._pillNodes || this._pillsChanged) {
          this._pillsChanged = false;
          this._pillNodes = this.template.querySelectorAll(PILL_SELECTOR) || [];
        }

        return this._pillNodes;
      }

      get focusedNode() {
        const pills = this.pillNodes;
        return pills.length <= 0 ? null : pills[this.focusedIndex];
      }
      /**
       * Sets focus on the pill list.
       */


      focus() {
        const focusedNode = this.focusedNode;

        if (focusedNode) {
          if (focusedNode.isPlainLink) {
            focusedNode.focusLink();
          } else {
            focusedNode.focus();
          }
        } else {
          const ul = this.template.querySelector('ul');

          if (ul) {
            ul.focus();
          }
        }
      }

      handleRemove(removeEvent) {
        const index = parseInt(removeEvent.detail.name, 10);

        if (typeof index !== 'number' || index < 0) {
          return;
        }

        this.fireEvent(index);
      }

      fireEvent(index) {
        // Mouse click on non-focused pill, switch focus to it.
        if (this.focusedIndex !== index) {
          this.switchFocus(index);
        } // Request to remove the last one, if removed, should move focus to last.


        this._deleteLast = index >= this._pills.length - 1;
        this.dispatchEvent(new CustomEvent('itemremove', {
          detail: {
            item: this.items[index].item,
            index
          }
        }));
      }

      setFocusedItemTabIndex(value) {
        const focusedNode = this.focusedNode;

        if (focusedNode) {
          this._focusedTabIndex = value;
        }
      }

      switchFocus(newValue) {
        // remove focus from current pill
        this.setFocusedItemTabIndex(-1); // move to next

        this.focusedIndex = newValue; // set focus

        this.setFocusedItemTabIndex(0);
        this.focus();
      }

      handleKeyDown(event) {
        if (this._pills.length <= 0) {
          return;
        }

        const index = this.focusedIndex;

        switch (event.keyCode) {
          case keyCodes.left:
          case keyCodes.up:
            this.switchFocus(index - 1);
            break;

          case keyCodes.right:
          case keyCodes.down:
            this.switchFocus(index + 1);
            break;

          default:
            this.focus();
        }
      }

      handlePillFocus() {
        if (!this._hasFocus) {
          this._hasFocus = true;
          this.dispatchEvent(new CustomEvent('focus'));
        }
      }

      handlePillBlur(event) {
        // Replace the below with !this.template.contains(event.relatedTarget) once 0.24 is out
        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this._hasFocus = false;
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleClick() {
        this.focus();
      }

      handlePillClick(clickEvent) {
        const index = parseInt(clickEvent.currentTarget.name, 10);

        if (index >= 0 && this.focusedIndex !== index) {
          this.switchFocus(index);
        } else {
          this.focus();
        }

        clickEvent.stopPropagation();
      }

      handleMoreClick() {
        this.focus();
      }

      get _showMore() {
        return this.isCollapsible && !this.isExpanded;
      }

      get computedPillCountMoreLabel() {
        if (this._isExpanded || isNaN(this._pillsNotFittingCount) || this._pillsNotFittingCount <= 0) {
          return undefined;
        } // TODO: We should have a standard utility for that


        return pillContainerMoreLabel.replace('{0}', this._pillsNotFittingCount);
      }

      _setupResizeObserver() {
        const resizeObserver = new LightningResizeObserver(() => {
          const visibleHeight = this.getBoundingClientRect().height;
          let notFittingCount = 0;

          for (let i = 0; i < this.pillNodes.length; i++) {
            const node = this.pillNodes[i];

            if (node.offsetTop > visibleHeight) {
              notFittingCount += 1;
            }
          }

          this._pillsNotFittingCount = notFittingCount;
        });
        resizeObserver.observe(this.template.querySelector('[role="listbox"]'));
        return resizeObserver;
      }

    }

    lwc.registerDecorators(LightningPillContainer, {
      publicProps: {
        label: {
          config: 0
        },
        variant: {
          config: 3
        },
        singleLine: {
          config: 3
        },
        isCollapsible: {
          config: 3
        },
        isExpanded: {
          config: 3
        },
        items: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _variant: 1,
        _pills: 1,
        _singleLine: 1,
        _isExpanded: 1,
        _isCollapsible: 1,
        _focusedIndex: 1,
        _focusedTabIndex: 1,
        _pillsNotFittingCount: 1,
        _pillContainerElementId: 1
      }
    });

    var _lightningPillContainer = lwc.registerComponent(LightningPillContainer, {
      tmpl: _tmpl$B
    });

    function tmpl$G($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "data-main-label": true
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        className: $cmp.computedComboboxGroupClass,
        key: 7
      }, [$cmp.computedHasFilter ? api_element("label", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        attrs: {
          "data-filter-label": true
        },
        key: 9
      }, [api_dynamic($cmp.filterLabel)]) : null, $cmp.computedHasFilter ? api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 10
      }, [api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 11
      }, [api_element("div", {
        classMap: {
          "slds-combobox_object-switcher": true,
          "slds-combobox-addon_start": true
        },
        key: 12
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        attrs: {
          "data-filter": true
        },
        props: {
          "disabled": $cmp.disabled,
          "items": $cmp.filterItems,
          "inputText": $cmp.filterInputText,
          "inputIconName": "utility:down",
          "inputIconSize": "xx-small",
          "dropdownAlignment": "auto"
        },
        key: 13,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleFilterReady)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "select": _m3 || ($ctx._m3 = api_bind($cmp.handleSelectFilter))
        }
      }, [])])])]) : null, api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        className: $cmp.computedLookupComboboxClass,
        attrs: {
          "data-lookup": true
        },
        props: {
          "variant": "lookup",
          "items": $cmp._items,
          "name": $cmp.name,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto",
          "placeholder": $cmp.placeholder,
          "inputText": $cmp.inputText,
          "inputPill": $cmp.inputPill,
          "inputMaxlength": $cmp.inputMaxlength,
          "inputIconName": $cmp.inputIconName,
          "inputIconSize": $cmp.inputIconSize,
          "inputIconAlternativeText": $cmp.inputIconAlternativeText,
          "showInputActivityIndicator": $cmp.showActivityIndicator,
          "showDropdownActivityIndicator": $cmp.showDropdownActivityIndicator
        },
        key: 14,
        on: {
          "ready": _m4 || ($ctx._m4 = api_bind($cmp.handleLookupReady)),
          "textchange": _m5 || ($ctx._m5 = api_bind($cmp.handleTextChange)),
          "textinput": _m6 || ($ctx._m6 = api_bind($cmp.handleTextInput)),
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "pillremove": _m9 || ($ctx._m9 = api_bind($cmp.handlePillRemove)),
          "endreached": _m10 || ($ctx._m10 = api_bind($cmp.handleEndReached)),
          "dropdownopenrequest": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownOpenRequest)),
          "select": _m12 || ($ctx._m12 = api_bind($cmp.handleSelect))
        }
      }, [])]), $cmp._hasPills ? api_custom_element("lightning-pill-container", _lightningPillContainer, {
        classMap: {
          "slds-listbox_selection-group": true
        },
        props: {
          "variant": "bare",
          "items": $cmp.pills,
          "isCollapsible": true,
          "isExpanded": $cmp._expandPillContainer
        },
        key: 16,
        on: {
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handlePillsBlur)),
          "focus": _m14 || ($ctx._m14 = api_bind($cmp.handlePillsFocus)),
          "itemremove": _m15 || ($ctx._m15 = api_bind($cmp.handlePillRemove))
        }
      }, []) : null]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-help-message": true,
          "id": api_scoped_id("help-message"),
          "aria-live": "assertive"
        },
        key: 18
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$C = lwc.registerTemplate(tmpl$G);
    tmpl$G.stylesheets = [];

    if (_implicitStylesheets$i) {
      tmpl$G.stylesheets.push.apply(tmpl$G.stylesheets, _implicitStylesheets$i);
    }
    tmpl$G.stylesheetTokens = {
      hostAttribute: "lightning-groupedCombobox_groupedCombobox-host",
      shadowAttribute: "lightning-groupedCombobox_groupedCombobox"
    };

    const i18n$l = {
      required: labelRequired
    };

    class LightningGroupedCombobox extends lwc.LightningElement {
      // TODO: Rename to 'showInputActivityIndicator'
      // Validity related message
      // TODO: Need to remove as if a readonly combobox is needed,
      // the regular lightning-combobox should be used
      constructor() {
        super();
        this.label = void 0;
        this.inputText = '';
        this.inputIconName = 'utility:search';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showActivityIndicator = false;
        this.showDropdownActivityIndicator = false;
        this.dropdownAlignment = 'left';
        this.placeholder = 'Select an Item';
        this.messageWhenValueMissing = i18n$l.required;
        this.name = void 0;
        this.value = void 0;
        this.required = false;
        this.disabled = false;
        this.readOnly = false;
        this.inputPill = void 0;
        this.filterLabel = void 0;
        this.filterItems = void 0;
        this.filterInputText = void 0;
        this._pills = void 0;
        this._variant = void 0;
        this._items = [];
        this._expandPillContainer = false;
        this._highlightedOptionElementId = '';
        this._helpMessage = void 0;
        this._fieldLevelHelp = void 0;
        this._filterInputId = void 0;
        this._mainInputId = void 0;
        this._mainInputId = generateUniqueId();
        this._filterInputId = generateUniqueId();
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element');
        this.interactingState = new InteractingState({
          // keeps interacting state when switching between two comboboxes and the pill container
          debounceInteraction: true
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
        });
      }

      synchronizeA11y() {
        const label = this.template.querySelector('[data-main-label]');
        const filterLabel = this.template.querySelector('[data-filter-label]');
        const helpMessage = this.template.querySelector('[data-help-message]'); // const filter = this.template.querySelector('[data-filter]');

        const lookup = this.template.querySelector('[data-lookup]');

        if (helpMessage) {
          lookup.inputDescribedByElements = helpMessage.id;
        }

        synchronizeAttrs(label, {
          for: this._mainInputId
        });
        synchronizeAttrs(filterLabel, {
          for: this._filterInputId
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get pills() {
        return this._pills;
      }

      set pills(newPills) {
        assert(Array.isArray(newPills), '"pills" must be an array.');

        if (this._connected && (!newPills || newPills.length === 0)) {
          if (this._focusOnPills) {
            // check why requestAnimationFrame is needed, something is stealing focus otherwise
            requestAnimationFrame(() => {
              this.lookupCombobox.focus();
            });
          }
        }

        this._pills = newPills;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      set items(items = []) {
        items = lwc.unwrap(items);
        this._items = items;

        if (items) {
          assert(Array.isArray(items), '"items" must be an array.');
        }
      }

      get items() {
        return this._items;
      }

      highlightInputText() {
        if (this._connected) {
          this.lookupCombobox.highlightInputText();
        }
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._connected) {
          this.lookupCombobox.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          this.lookupCombobox.focusAndOpenDropdownIfNotEmpty();
        }
      }
      /**
       * Removes focus from the input element.
       */


      blur() {
        if (this._connected) {
          this.lookupCombobox.blur();
        }
      }

      get validity() {
        return this._constraint.validity;
      }

      checkValidity() {
        return this._constraint.checkValidity();
      }

      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }

      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleLookupReady(e) {
        this._mainInputId = e.detail.id;
      }

      handleFilterReady(e) {
        this._filterInputId = e.detail.id;
      }

      get computedUniqueHelpElementId() {
        return this._helpMessage ? this._mainInputId + '-error' : null;
      }

      get lookupCombobox() {
        return this.template.querySelector('[data-lookup]');
      }

      handleDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

      handlePillRemove(event) {
        if (!this.disabled) {
          this.dispatchEvent(new CustomEvent('pillremove', {
            detail: event.detail
          }));
        }
      }

      handleTextChange(event) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text: event.detail.text
          }
        }));
      }

      handleTextInput(event) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text: event.detail.text
          }
        }));
      }

      handleSelect(event) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value: event.detail.value
          }
        }));
      }

      handleSelectFilter(event) {
        const selectedFilterValue = event.detail.value;
        this.dispatchEvent(new CustomEvent('selectfilter', {
          detail: {
            value: selectedFilterValue
          }
        }));
      }

      handleEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      handleFocus() {
        this.interactingState.enter();
        this._expandPillContainer = true;

        if (!this._hasFocus) {
          this._hasFocus = true;
          this.dispatchEvent(new CustomEvent('focus'));
        }
      }

      handlePillsFocus() {
        this.handleFocus();
        this._focusOnPills = true;
      }

      handlePillsBlur() {
        this.handleBlur();
        this._focusOnPills = false;
      }

      handleBlur() {
        this._hasFocus = false; // Once https://github.com/salesforce/lwc/issues/444 is fixed, consider switching to
        // `onfocusout` and `event.relatedTarget` to determine whether the focus stayed in the component,
        // this way the use of async blur can be avoided.

        requestAnimationFrame(() => {
          if (!this._hasFocus) {
            this.interactingState.leave();
            this.dispatchEvent(new CustomEvent('blur'));
            this._expandPillContainer = false;

            if (this.pills && this.pills.length > 0) {
              // Sometimes (involves focusing on lower pills) the pill container scrolls and the top
              // line with the "+ n more" button does not show so we have to manually scroll to the top.
              // We need to figure a better solution for this.
              requestAnimationFrame(() => {
                if (this._connected) {
                  this.template.querySelector('lightning-pill-container').scrollTop = 0;
                }
              });
            }
          }
        });
      }

      get i18n() {
        return i18n$l;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedComboboxGroupClass() {
        return classSet().add({
          'slds-has-selection': Array.isArray(this._pills) && this._pills.length > 0,
          'slds-combobox-group': this.computedHasFilter
        });
      }

      get computedHasFilter() {
        return Array.isArray(this.filterItems);
      }

      get computedLookupComboboxClass() {
        return this.computedHasFilter ? 'slds-combobox-addon_end' : '';
      }

      get _hasPills() {
        return this.pills && this.pills.length > 0;
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.value)
          });
        }

        return this._constraintApi;
      }

    }

    lwc.registerDecorators(LightningGroupedCombobox, {
      publicProps: {
        label: {
          config: 0
        },
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showActivityIndicator: {
          config: 0
        },
        showDropdownActivityIndicator: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        required: {
          config: 0
        },
        disabled: {
          config: 0
        },
        readOnly: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        filterLabel: {
          config: 0
        },
        filterItems: {
          config: 0
        },
        filterInputText: {
          config: 0
        },
        pills: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _pills: 1,
        _variant: 1,
        _items: 1,
        _expandPillContainer: 1,
        _highlightedOptionElementId: 1,
        _helpMessage: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningGroupedCombobox = lwc.registerComponent(LightningGroupedCombobox, {
      tmpl: _tmpl$C
    });

    function tmpl$H($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_custom_element("lightning-grouped-combobox", _lightningGroupedCombobox, {
        props: {
          "disabled": $cmp.disabled,
          "filterInputText": $cmp.filterInputText,
          "filterItems": $cmp.filterItems,
          "filterLabel": $cmp.filterLabel,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "inputIconName": $cmp.inputIconName,
          "inputMaxlength": $cmp.inputMaxlength,
          "inputPill": $cmp.inputPill,
          "inputText": $cmp.inputText,
          "items": $cmp.items,
          "label": $cmp.label,
          "pills": $cmp.pills,
          "placeholder": $cmp.placeholder,
          "required": $cmp.isRequired,
          "showActivityIndicator": $cmp.showActivityIndicator,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 2,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "dropdownopenrequest": _m1 || ($ctx._m1 = api_bind($cmp.handleDropdownOpenRequest)),
          "pillremove": _m2 || ($ctx._m2 = api_bind($cmp.handlePillRemove)),
          "select": _m3 || ($ctx._m3 = api_bind($cmp.handleSelect)),
          "selectfilter": _m4 || ($ctx._m4 = api_bind($cmp.handleSelectFilter)),
          "textinput": _m5 || ($ctx._m5 = api_bind($cmp.handleInputTextChange))
        }
      }, [])];
    }

    var _tmpl$D = lwc.registerTemplate(tmpl$H);
    tmpl$H.stylesheets = [];

    if (_implicitStylesheets$h) {
      tmpl$H.stylesheets.push.apply(tmpl$H.stylesheets, _implicitStylesheets$h);
    }
    tmpl$H.stylesheetTokens = {
      hostAttribute: "lightning-lookupDesktop_lookupDesktop-host",
      shadowAttribute: "lightning-lookupDesktop_lookupDesktop"
    };

    const MODAL_TYPE = 'modal';
    const POPOVER_TYPE = 'panel';

    function normalizeInt(x) {
      const parsed = parseInt(x, 10);
      return isNaN(parsed) ? 0 : parsed;
    }

    class OverlayOptions {
      constructor() {
        this._options = {
          panelType: MODAL_TYPE,
          visible: true,
          panelConfig: {}
        };
      }

      get options() {
        if (this._options.panelType === POPOVER_TYPE) {
          if (this._options.panelConfig.showCloseButton == null) {
            this._options.panelConfig.showCloseButton = false;
          }

          if (this._options.panelConfig.showPointer == null) {
            this._options.panelConfig.showPointer = true;
          }
        } // Set isCustomPanel to true, make sure AVP always is ui:modal or ui:panel.


        this._options.panelConfig.isCustomPanel = true;
        return this._options;
      }

      id(value) {
        this._options.panelConfig.devNameOrId = value;
      }

      panelType(value) {
        this._options.panelType = value;
      }

      modal() {
        this._options.panelType = MODAL_TYPE;
      }

      popover() {
        this._options.panelType = POPOVER_TYPE;
      }

      bodyClass(value) {
        this._options.panelConfig.bodyClass = value || '';
      }

      body(value) {
        this._options.panelConfig.body = value || null;
      } // modal specific


      modalClass(value) {
        this._options.panelConfig.modalClass = value || '';
        return this;
      }

      headerClass(value) {
        this._options.panelConfig.headerClass = value || '';
      }

      footerClass(value) {
        this._options.panelConfig.footerClass = value || '';
      }

      classNames(value) {
        this._options.panelConfig.classNames = value || '';
      }

      flavor(value) {
        this._options.panelConfig.flavor = value || '';
      }

      title(value) {
        if (value != null && value !== '') {
          this._options.panelConfig.header = null;
          this._options.panelConfig.title = value;
        }
      }

      header(value) {
        if (value != null) {
          if (typeof value === 'string') {
            this._options.panelConfig.header = null;
            this._options.panelConfig.title = value;
          } else {
            this._options.panelConfig.header = value;
            this._options.panelConfig.title = null;
          }
        }
      }

      footer(value) {
        this._options.panelConfig.footer = value;
      }

      showCloseButton(value) {
        this._options.panelConfig.showCloseButton = !!value;
      }

      closeCallback(value) {
        if (typeof value === 'function') {
          this._options.onDestroy = value;
        }
      } // Popover specific


      referenceSelector(value) {
        this._options.panelConfig.referenceElementSelector = value || '';
      }

      reference(value) {
        this._options.panelConfig.referenceElement = value;
      } // positioning


      showPointer(value) {
        this._options.panelConfig.showPointer = !!value;
      }

      direction(value) {
        this._options.panelConfig.direction = value;
      }

      padding(value) {
        this._options.panelConfig.pad = normalizeInt(value);
      }

      advancedConfig(value) {
        if (typeof value === 'object') {
          this._options.panelConfig.advancedConfig = value;
        }
      }

      boundingElement(value) {
        this._options.panelConfig.boundingElement = value;
      }

      pointerPadding(value) {
        this._options.panelConfig.pointerPad = normalizeInt(value);
      }

      boundingBoxPadding(value) {
        this._options.panelConfig.boundingBoxPad = normalizeInt(value);
      }

      boxDirectionPadding(value) {
        this._options.panelConfig.boxDirectionPad = normalizeInt(value);
      }

      align(value) {
        this._advancedConfig.align = normalizeInt(value);
      }

      targetAlign(value) {
        this._advancedConfig.targetAlign = normalizeInt(value);
      }

      verticalPadding(value) {
        this._advancedConfig.vertPad = normalizeInt(value);
      } // More attributes support W-5455858


      autoFocus(value) {
        this._options.panelConfig.autoFocus = !!value;
      }

      trapFocus(value) {
        this._options.panelConfig.trapFocus = !!value;
      }

      closeOnClickOut(value) {
        this._options.panelConfig.closeOnClickOut = !!value;
      }

      useTransition(value) {
        this._options.panelConfig.useTransition = !!value;
      }

      scopeScrollables(value) {
        this._options.panelConfig.scopeScrollables = !!value;
      }

      closeAction(value) {
        if (typeof value === 'function') {
          this._options.panelConfig.closeAction = value;
        }
      } // Extra attribte pass to custome panel


      customAttributes(value) {
        value = value || {};
        const keys = Object.keys(value);

        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          assert(!this[key], `${key} is a predefined option, can not be overridden by customAttributes`);

          if (!this[key]) {
            this._options.panelConfig[key] = value[key];
          }
        }
      }

      get _advancedConfig() {
        this._options.panelConfig.advancedConfig = this._options.panelConfig.advancedConfig || {};
        return this._options.panelConfig.advancedConfig;
      }

    }

    function parseOptions(options = {}) {
      const config = new OverlayOptions();
      const keys = Object.keys(options);

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (typeof config[key] === 'function' && options[key] != null) {
          config[key].apply(config, [options[key]]);
        }
      }

      return config.options;
    }

    const PANEL_ANIMATION_TIME = 220; // panel animation is 0.2s, consider ~17ms frame render, refer to panel.css in aura repo.

    class OverlayPanel {
      constructor(instance) {
        this._panelInstance = instance;
        this._visible = true;
      }

      get isVisible() {
        return this._visible;
      }

      get instance() {
        return this._panelInstance;
      }

      _createPromise(isShow, previousPromise) {
        let promise = new Promise(resolve => {
          const panelCall = isShow ? this._panelInstance.show : this._panelInstance.hide;
          let isDone = false;

          const resolveCall = () => {
            if (!isDone) {
              resolve();
              isDone = true;
            }
          };

          panelCall(resolveCall); // force the promise to resolve if animationend event didn't callback.
          // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(resolveCall, PANEL_ANIMATION_TIME);
        });

        if (previousPromise) {
          promise = this.previousPromise.then(() => promise);
        }

        return promise;
      }

      show() {
        if (!this._visible) {
          this._showPromise = this._createPromise(true, this._hidePromise).then(() => {
            this._showPromise = null;
            this._visible = true;
          });
        }

        return this._showPromise || Promise.resolve();
      }

      hide() {
        if (this._visible) {
          this._hidePromise = this._createPromise(false, this._showPromise).then(() => {
            this._hidePromise = null;
            this._visible = false;
          });
        }

        return this._hidePromise || Promise.resolve();
      }

      close(shouldReturnFocus) {
        return new Promise(resolve => {
          this._panelInstance.close(() => {
            resolve();
          }, shouldReturnFocus);
        });
      }

    }

    function showCustomOverlay(configuration, eventDispatcher) {
      const parameters = parseOptions(configuration);
      return new Promise(resolve => {
        parameters.onCreate = panelInstance => {
          resolve(new OverlayPanel(panelInstance));
        };

        eventDispatcher(parameters);
      });
    }

    function wrapComponent(cmp) {
      return new Promise((resolve, reject) => {
        if (cmp instanceof HTMLElement) {
          aura.createComponent('lightning:overlayInteropWrapper', {
            domElement: cmp
          }, (newComponent, status, errorMessage) => {
            if (status === 'SUCCESS') {
              resolve(newComponent);
            } else {
              const rejectMessage = status === 'INCOMPLETE' ? 'No response from server or client is offline.' : errorMessage;
              reject(rejectMessage);
            }
          });
        } else {
          resolve(cmp);
        }
      });
    }

    function showCustomOverlay$1(configuration) {
      return Promise.all([wrapComponent(configuration.header), wrapComponent(configuration.body), wrapComponent(configuration.footer)]).then(components => {
        const options = Object.assign({}, configuration);
        options.header = components[0];
        options.body = components[1];
        options.footer = components[2];
        return showCustomOverlay(options, eventAttributes => {
          aura.dispatchGlobalEvent('markup://ui:createPanel', eventAttributes);
        });
      });
    }

    // eslint-disable-next-line lwc/no-compat-create
    /**
     * Shows advanced search panel having scoped search results.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     * Schema -
     * {
     *      additionalFields: {Array},
     *      contextId: {String},
     *      dependentFieldBindings: {Map},
     *      entities: {Array},
     *      field: {String},
     *      groupId: {String},
     *      label: {String},
     *      maxValues: {Integer},
     *      placeholder: {String},
     *      recordId: {String},
     *      saveCallback: {Function},
     *      scopeMap: {Object},
     *      scopeSets: {Object},
     *      source: {String},
     *      term: {String},
     * }
     */

    function showAdvancedSearch(attrs) {
      showCustomOverlay$1({
        isTransient: true,
        isScrollable: false,
        isFullScreen: true,
        flavor: 'large',
        autoFocus: false,
        title: attrs.label
      }).then(panel => {
        updatePanel(panel._panelInstance, attrs);
      });
    }
    /**
     * Updates panel by setting it's body and footer.
     * @param {Object} panel - Instance of panel created, an Aura Component.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     */

    function updatePanel(panel, attrs) {
      if (!panel || !attrs) {
        return;
      }

      setPanelFooter(panel).then(setPanelBody(panel, attrs)).catch(error => {
        throw new Error(error);
      });
    }
    /**
     * Sets an instance of lookupAdvanced to panel's body.
     * @param {Object} panel - Instance of panel, an Aura Component.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     * @returns {Promise} a promise used to resolve the creation of lookupAdvanced.
     */


    function setPanelBody(panel, attrs) {
      attrs.panel = panel;
      const promise = new Promise((resolve, reject) => {
        aura.createComponent('forceSearch:lookupAdvanced', attrs, (cmp, status, error) => {
          if (status === 'SUCCESS') {
            panel.update({
              body: cmp
            });
            resolve();
          } else {
            reject(error);
          }
        });
      });
      return promise;
    }
    /**
     * Sets an instance of lookupAdvancedFooter to panel's footer.
     * @param {Object} panel - Instance of panel, an Aura Component.
     * @return {Promise} a promise used to resolve the creation of
     * lookupAdvancedFooter.
     */


    function setPanelFooter(panel) {
      const promise = new Promise((resolve, reject) => {
        aura.createComponent('forceSearch:lookupAdvancedFooter', {
          'aura:id': 'lookupAdvancedFooter'
        }, (cmp, status, error) => {
          if (status === 'SUCCESS') {
            panel.set('v.footer', cmp);
            resolve();
          } else {
            reject(error);
          }
        });
      });
      return promise;
    }

    /*
     * The name of the type of the item that represents the advanced search option.
     * @type {String}
     */
    const ACTION_ADVANCED_SEARCH = 'actionAdvancedSearch';
    /*
    * The name of the type of the item that represents the create new action.
    * @type {String}
    */

    const ACTION_CREATE_NEW = 'actionCreateNew';
    /*
     * GroupId used during advanced search.
     * The groupId indicates the group to which advancedSearch component belongs.
     * Typically only components with identical groupId values will interact.
     * @type {String}
     */

    const ADVANCED_SEARCH_GROUP_ID = 'LOOKUP';
    /*
     * The max number of values a user can select in advanced search.
     * @type {Number}
     */

    const ADVANCED_SEARCH_MAX_VALUES = 1;
    /**
     * The UI API default page value.
     * @type {Number}
     */

    const DEFAULT_PAGE = 1;
    /**
     * The UI API default pageSize value.
     * @type {Number}
     */

    const DEFAULT_PAGE_SIZE = 25;
    /**
     * The default count of items to display in combobox.
     * @type {Number}
     */

    const DEFAULT_LIST_SIZE = 5;
    /**
     * An event indicating a change in lookup value.
     * @type {String}
     */

    const EVENT_CHANGE = 'change';
    /**
     * An event indicating a create new option was selected.
     * @type {String}
     */

    const EVENT_CREATE_NEW = 'createnew';
    /**
     * An event indicating an error.
     * @type {String}
     */

    const EVENT_ERROR = 'error';
    /**
     * An event indicating an error from lds wire adapter.
     * @type {String}
     */

    const EVENT_LDS_ERROR = 'ldserror';
    /**
     * The default entity icon.
     * @type {String}
     */

    const ICON_DEFAULT = 'standard:default';
    /**
     * The add utility icon name.
     * @type {String}
     */

    const ICON_ADD = 'utility:add';
    /**
     * The check utility icon name.
     * @type {String}
     */

    const ICON_CHECK = 'utility:check';
    /**
     * The search utility icon name.
     * @type {String}
     */

    const ICON_SEARCH = 'utility:search';
    /**
     * The utility icon with small size.
     * @type {String}
     */

    const ICON_SIZE_SMALL = 'small';
    /**
     * The utility icon with extra small size.
     * Typically used with search, and add icons.
     * @type {String}
     */

    const ICON_SIZE_X_SMALL = 'x-small';
    /**
     * The max length for combobox input.
     * @type {Number}
     */

    const INPUT_MAX_LENGTH = 255;
    /**
     * The layout type for record-ui wire request.
     * @type {String}
     */

    const LAYOUT_TYPE_FULL = 'Full';
    /**
     * The lightning combobox component name.
     * @type {String}
     */

    const LIGHTNING_COMBOBOX = 'lightning-grouped-combobox';
    /**
     * The ailtn transaction MRU action type for create new.
     * @type {String}
     */

    const LOG_ACTION_CREATE_NEW_OPTION = 'CREATE_OPTION';
    /**
     * The ailtn transaction MRU action type for advanced search.
     * @type {String}
     */

    const LOG_ACTION_SEARCH_OPTION = 'SEARCH_OPTION';
    /**
     * The ailtn transaction context query type for MRU.
     * @type {String}
     */

    const LOG_CONTEXT_Q_TYPE_MRU = 'MRU';
    /**
     * The ailtn transaction context query type for TypeAhead.
     * @type {String}
     */

    const LOG_CONTEXT_Q_TYPE_TYPEAHEAD = 'Typeahead';
    /**
     * The ailtn transaction event source for click interaction.
     * @type {String}
     */

    const LOG_EVENT_CLICK = 'click';
    /**
     * The ailtn transaction event source for pill removal.
     * @type {String}
     */

    const LOG_EVENT_PILL_REMOVE = 'synthetic-pill-remove';
    /**
     * The ailtn transaction scope for lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_INPUT_LOOKUP_DESKTOP = 'search-input-lookup-desktop';
    /**
     * The ailtn transaction scope for the entiy selector for the lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_ENTITY_SELECTOR = 'search-entity-selector';
    /**
     * The ailtn transaction target for lookup input.
     * @type {String}
     */

    const LOG_TARGET_INPUT = 'search-input';
    /**
     * The ailtn transaction target for action items like advanced search.
     * @type {String}
     */

    const LOG_TARGET_MRU_ACTION_ITEM = 'search-mru-action-item';
    /**
     * The ailtn transaction target for MRU record items.
     * @type {String}
     */

    const LOG_TARGET_MRU_ITEM = 'search-mru-item';
    /**
     * The ailtn transaction target for the record pill.
     * @type {String}
     */

    const LOG_TARGET_RECORD_PILL_ITEM = 'search-record-pill-item';
    /**
     * The ailtn transaction target for the entity filter item..
     * @type {String}
     */

    const LOG_TARGET_FILTER_ITEM = 'search-filter-item';
    /**
     * The mode view for record-ui wire request.
     * @type {String}
     */

    const MODE_VIEW = 'View';
    /**
     * The combo-box action type to show record.
     * @type {String}
     */

    const OPTION_TYPE_CARD = 'option-card';
    /**
     * The combo-box option type to show an action.
     * @type {String}
     */

    const OPTION_TYPE_INLINE = 'option-inline';
    /**
     * The combo-box pill item type to show icons.
     * @type {String}
     */

    const PILL_TYPE_ICON = 'icon';
    /**
     * UI API query parameter for the dependent field bindings.
     * @type {String}
     */

    const QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS = 'dependentFieldBindings';
    /**
     * UI API query parameter for the page.
     * @type {String}
     */

    const QUERY_PARAMS_PAGE = 'page';
    /**
     * UI API query parameter for the page size.
     * @type {String}
     */

    const QUERY_PARAMS_PAGE_SIZE = 'pageSize';
    /**
     * UI API query parameter for the search term.
     * @type {String}
     */

    const QUERY_PARAMS_Q = 'q';
    /**
     * UI API query parameter for the search type like Recent or TypeAhead.
     * @type {String}
     */

    const QUERY_PARAMS_SEARCH_TYPE = 'searchType';
    /**
     * The UI API searchType value for Recent records.
     * @type {String}
     */

    const SEARCH_TYPE_RECENT = 'Recent';
    /**
     * The UI API searchType value for TypeAhead records.
     * @type {String}
     */

    const SEARCH_TYPE_TYPEAHEAD = 'TypeAhead';

    /**
     * Requests a log entry for tracking user interactions.
     * @param {String} ailtnEventSource - The synthetic event source for the interaction.
     * @param {String} ailtnScope - The component that handles the action. Effectively it's an ancestor of the target component.
     * @param {String} ailtnTarget - The component that handles the event.
     * @param {Object} ailtnContext - The composite of the context from the target and scope. This needs to be a flat map.
     */

    function log(ailtnEventSource, ailtnScope, ailtnTarget, ailtnContext) {
      if (!ailtnEventSource || !ailtnScope || !ailtnTarget) {
        return;
      }

      const _ailtnContext = ailtnContext || {};

      _ailtnContext.sourceCmp = 'lightning:lookup-desktop';
      _ailtnContext.time = Date.now();
      auraInstrumentation.interaction(ailtnTarget, ailtnScope, _ailtnContext, ailtnEventSource);
    }

    var labelAdd = 'Add';

    var labelAdvancedSearch = '"{0}" in {1}';

    var labelCreateNew = 'New {0}';

    var labelCurrentSelection = 'Current Selection';

    var labelMessageWhenBadInputDefault = 'Select an option or remove the search term.';

    var labelMruHeader = 'Recent {0}';

    var labelSearch = 'Search';

    var labelSearchObjectsPlaceholder = 'Search {0}...';

    var labelSearchPlaceholder = 'Search...';

    var labelSelectObject = 'Choose an object';

    const i18n$m = {
      add: labelAdd,
      advancedSearch: labelAdvancedSearch,
      createNew: labelCreateNew,
      currentSelection: labelCurrentSelection,
      messageWhenBadInputDefault: labelMessageWhenBadInputDefault,
      mruHeader: labelMruHeader,
      search: labelSearch,
      searchObjectsPlaceholder: labelSearchObjectsPlaceholder,
      searchPlaceholder: labelSearchPlaceholder,
      selectEntity: labelSelectObject
    };
    /**
     * Compares given array to check if they have identical (string) elements
     * irrespective of their positions.
     * Note - Does not perform deep comparison.
     * @param {Array} array1 - Source array.
     * @param {Array} array2 - Desination array for comparison.
     * @returns {Boolean} true if array1 and array2 have same elements.
     */

    function arraysIdentical(array1 = [], array2 = []) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }

      if (array1.length !== array2.length) {
        return false;
      }

      const sortedArray1 = Object.assign([], array1).sort();
      const sortedArray2 = Object.assign([], array2).sort();
      return sortedArray1.toString() === sortedArray2.toString();
    }
    /**
     * Get advanced search action item for display.
     * @param {String} term - A search term.
     * @param {String} label - Plural name of target api.
     * @returns {Object} - An advanced search action item.
     */


    function computeAdvancedSearchOption(term, label) {
      if (term === null || term === undefined) {
        term = '';
      }

      if (label === null || label === undefined) {
        label = '';
      }

      return {
        highlight: true,
        iconAlternativeText: `${i18n$m.search}`,
        iconName: ICON_SEARCH,
        iconSize: ICON_SIZE_X_SMALL,
        text: `${i18n$m.advancedSearch}`.replace('{0}', term).replace('{1}', label),
        type: OPTION_TYPE_CARD,
        value: ACTION_ADVANCED_SEARCH
      };
    }
    /**
     * Returns a CSV string of dependent field bindings given a Record
     * representaiton and a list of dependent fields.
     * @param  {Object} record - A record representation.
     * @param  {Array} dependentFields - An array of depedent field api names.
     * @return {Object} - A CSV string of dependent field bindings.
     */


    function computeBindingsString(record, dependentFields) {
      if (!record || !dependentFields || !dependentFields.length) {
        return null;
      }

      return dependentFields.map(field => {
        const value = record.fields && record.fields[field] ? record.fields[field].value : null;
        return `${field}=${value}`;
      }).join(',');
    }
    /**
     * Returns a map of dependent field bindings given a Record representaiton and
     * a list of dependent fields.
     * @param  {Object} record - A record representation.
     * @param  {Array} dependentFields - An array of depedent field api names.
     * @return {Object} - A map of dependent field bindings.
     */


    function computeBindingsMap(record, dependentFields) {
      if (!record || !dependentFields || !dependentFields.length) {
        return null;
      }

      const dependentFieldBindings = {};
      dependentFields.forEach(field => {
        const value = record.fields && record.fields[field] ? record.fields[field].value : null;
        dependentFieldBindings[field] = value;
      });
      return dependentFieldBindings;
    }
    /**
     * Get create new action item for display.
     * @param {String} label - Plural name of target api.
     * @returns {Object} - A create new action item.
     */


    function computeCreateNewOption(label = '') {
      if (label === null) {
        label = '';
      }

      return {
        iconAlternativeText: `${i18n$m.add}`,
        iconName: ICON_ADD,
        iconSize: ICON_SIZE_X_SMALL,
        text: `${i18n$m.createNew}`.replace('{0}', label),
        type: OPTION_TYPE_CARD,
        value: ACTION_CREATE_NEW
      };
    }
    /**
     * Gets deduped, and trimmed items.
     * @param {Array} items - The original list of items to be deduped.
     * @param {Array} valuesToIgnore - The list of values to ignore.
     * @param {Number} count - The count of number of items to return.
     * @returns {Array} - The the deduped and trimmed items list.
     */


    function computeDedupedItems(items = [], valuesToIgnore = [], count) {
      if (items === null) {
        items = [];
      }

      if (valuesToIgnore === null) {
        valuesToIgnore = [];
      }

      const dedupedItems = items.filter(item => {
        return valuesToIgnore.indexOf(item.value) < 0;
      });

      if (Number.isInteger(count) && count > 0 && dedupedItems.length > count) {
        dedupedItems.length = count;
      }

      return dedupedItems;
    }
    /**
     * Computes custom event to notify change, error, createnew etc.
     * @param {String} type - The type of event being dispatched.
     * @param {Object} detail - The event data.
     * @param {Boolean} bubbles - Whether or not the event bubbles.
     * @returns {Object} - A custom event.
     */


    function computeEvent(type, detail, bubbles = true) {
      if (!type) {
        return {};
      }

      if (bubbles === null) {
        bubbles = true;
      } // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments


      return new CustomEvent(type, {
        composed: bubbles,
        bubbles,
        detail
      });
    }
    /**
     * Computes the field API name, qualified with an object name if possible.
     * @param {String|FieldId} fieldName - The value from which to get the field API name.
     * @param {String} sourceApiName - The source record's api name.
     * @return {String} - The field API name.
     */


    function computeFieldApiName(fieldName = '', sourceApiName = '') {
      if (fieldName === null) {
        fieldName = '';
      }

      if (sourceApiName === null) {
        sourceApiName = '';
      }

      let apiName = '';

      if (typeof fieldName === 'string' && fieldName.length) {
        const idx = fieldName.indexOf('.');

        if (idx >= 1) {
          apiName = fieldName;
        }
      } else if (typeof fieldName === 'object' && typeof fieldName.objectApiName === 'string' && typeof fieldName.fieldApiName === 'string') {
        apiName = fieldName.objectApiName + '.' + fieldName.fieldApiName;
      }

      if (!apiName.length && fieldName.length && sourceApiName.length) {
        apiName = sourceApiName + '.' + fieldName;
      }

      return apiName;
    }
    /**
     * Computes a map of field info like isRequired, dependentFields, etc.
     * @param {Object} objectInfos - Source record's objectInfos.
     * @param {String} apiName - An api name.
     * @param {String} fieldApiName - The qualified field name.
     * @returns {Object} - A map of field infos.
     */


    function computeFieldInfo(objectInfos, apiName, fieldApiName) {
      let computedFieldInfo = {};

      if (!objectInfos || !apiName || !fieldApiName) {
        return computedFieldInfo;
      }

      const fieldName = computeUnqualifiedFieldApiName(fieldApiName);
      const objectInfo = objectInfos[apiName] || {};
      const fieldInfo = objectInfo.fields ? objectInfo.fields[fieldName] : null;

      if (fieldInfo) {
        computedFieldInfo = {
          // See https://sfdc.co/dependent-lookups for more information.
          dependentFields: fieldInfo.filteredLookupInfo ? fieldInfo.filteredLookupInfo.controllingFields : undefined,
          fieldName,
          inlineHelpText: fieldInfo.inlineHelpText,
          isRequired: fieldInfo.required,
          references: fieldInfo.referenceToInfos,
          relationshipName: fieldInfo.relationshipName
        };
      }

      return computedFieldInfo;
    }
    /**
     * Gets entity items for multi-entity filter.
     * @param {Object} references - A map of reference apis having name fields and action details.
     * @param {String} chosenApi - Selected api that gets check icon.
     * @returns {List} - An array of filter items that can be consumed by the combobox.
     */


    function computeFilterItems(references = {}, chosenApi) {
      if (references === null) {
        references = {};
      }

      const referenceApiNames = Object.keys(references);
      let items = null;

      if (referenceApiNames.length > 1) {
        // Alphabetically sort api names.
        referenceApiNames.sort();
        items = [];
        referenceApiNames.forEach(apiName => {
          const item = {
            text: references[apiName].label,
            type: OPTION_TYPE_INLINE,
            value: apiName
          };

          if (chosenApi && apiName === chosenApi) {
            item.highlight = true;
            item.iconAlternativeText = `${i18n$m.currentSelection}`;
            item.iconName = ICON_CHECK;
            item.iconSize = ICON_SIZE_X_SMALL;
          }

          items.push(item);
        });
      }

      return items;
    }
    /**
     * Gets filter label for the multi-entity lookup.
     * @returns {String} - Filter dropdown label for the multi-entity.
     */


    function computeFilterLabel() {
      return `${i18n$m.selectEntity}`;
    }
    /**
     * Determines the SLDS icon string given an objectInfo. If the icon cannot be
     * resolved from the given objectInfo, 'standard:default' is returned.
     * TODO: This needs to be done through an API.
     * @param  {Object} objectInfo - An objectInfo.
     * @return {String} - A slds icon string.
     */


    function computeIconName(objectInfo) {
      if (!objectInfo || !objectInfo.themeInfo || !objectInfo.themeInfo.iconUrl) {
        return ICON_DEFAULT;
      }

      const iconUrl = objectInfo.themeInfo.iconUrl;
      const parts = iconUrl.split('/');
      const icon = parts.pop().replace(/(_\d+)(\.\w*)/gi, '');
      const category = parts.pop();
      return `${category}:${icon}`;
    }
    /**
     * Computes heading for the display items.
     * @param {String} label - Plural name of target api.
     * @returns {List} - The new items with heading set.
     */


    function computeHeading(label = '') {
      return `${i18n$m.mruHeader}`.replace('{0}', label);
    }
    /**
     * Returns items with text slices for highlighting.
     *
     * For example -
     * items = [{ text: "salesforce", subText: "(213)111-4444",...}]
     * term = "sal force"
     * returns -
     * [
     *    {
     *      "text": [
     *        {
     *          "text": "sal",
     *          "highlight": true
     *        },
     *        {
     *          "text": "es"
     *        },
     *        {
     *            "text": "force",
     *            "highlight": true
     *        }
     *      ],
     *      "subText": [
     *        {
     *          "text": "(213)111-4444"
     *        }
     *      ],
     *      ...
     *    }
     *  ]
     *
     * Important caveats -
     *
     * Handling term with substrings:
     * --------------------------------
     * Term is broken up into parts for matching by splitting it using whitespaces.
     * Matching for each part starts from the begining till the end of the original text.
     * Parts that are subtrings of each other may get merged while highlighting.
     * For example -
     * text = "salesforce.com account"
     * term = "salesforce.com a"
     * "salesforce.com" would be highlighted but not "a" because it's a substring of "salesforce.com"
     * however for the term "salesforce.com acc" both "salesforce.com" and "acc" would be highlighted.
     *
     * Handling term with wildcards:
     * --------------------------------
     * Wildcards are not dropped while matching.
     * For example -
     * text = "salesforce.com"
     * term = "sales*"
     * would NOT result in highlighting of "sales". However if text was "sales*foo"
     * then the subtring "sales*" would be highlighted.
     *
     * @param {Array} items - Items representing records.
     * @param {String} term - A search term for matching.
     * @return {Array} - An array of items with text split for highlighting.
     */


    function computeHighlightedItems(items, term) {
      const output = []; // No-op if items or term is empty.

      if (!items || items.length === 0 || !term) {
        return output;
      } // Get unique parts of the term.
      // For example -
      // term = "sal sal sales"
      // words = ["sal","sales"]


      const words = term.trim().split(' ').filter((w, i, ar) => {
        return ar.indexOf(w) === i;
      });
      items.forEach(item => {
        const outputItem = Object.assign({}, item); // Creating text list to process text and subText.

        const textList = []; // Process text only if it's not empty

        if (item.text) {
          textList.push({
            type: 'text',
            text: item.text
          });
        } else {
          outputItem.text = null;
        } // Process subText only if it's not empty


        if (item.subText) {
          textList.push({
            type: 'subText',
            text: item.subText
          });
        } else {
          outputItem.subText = null;
        }

        textList.forEach(textItem => {
          // Get matching indexes for the search term.
          const intervals = getMatchingIndexes(textItem.text, words); // If match not found, then return the original text.

          if (intervals.length === 0) {
            outputItem[textItem.type] = [{
              text: textItem.text
            }];
          } else {
            // Get slices of matching text with highlight markers.
            outputItem[textItem.type] = splitTextFromMatchingIndexes(textItem.text, intervals);
          }
        });
        output.push(outputItem);
      });
      return output;
    }
    /**
     * Computes default error message for the bad input
     * @returns {String} The default error message for the bad input
     */


    function computeMessageWhenBadInputDefault() {
      return `${i18n$m.messageWhenBadInputDefault}`;
    }
    /**
     * Computes a map of object info for a given api.
     * @param {Object} objectInfos - Source record's objectInfos.
     * @param {String} apiName - An api name.
     * @returns {Object} - A map of object infos for the given api.
     */


    function computeObjectInfo(objectInfos, apiName) {
      if (!objectInfos || !apiName) {
        return {};
      }

      const objectInfo = objectInfos[apiName] || {};
      const themeInfo = objectInfo.themeInfo || {};
      return {
        apiName,
        color: themeInfo.color || '',
        iconAlternativeText: apiName,
        iconName: computeIconName(objectInfo),
        iconUrl: themeInfo.iconUrl || '',
        keyPrefix: objectInfo.keyPrefix,
        label: objectInfo.label,
        labelPlural: objectInfo.labelPlural
      };
    }
    /**
     * Computes an array of optional name fields required for @wire(getRecordUi)
     * For example - ['Opportunity.Name', 'User.Name'...]
     * @param {Object} references - A map of reference apis having name fields and action details.
     * @returns {Array} - An array of name fields.
     */


    function computeOptionalNameFields(references = {}) {
      if (references === null) {
        references = {};
      }

      const optionalNameFields = [];

      for (const reference in references) {
        if (references.hasOwnProperty(reference) && references[reference].hasOwnProperty('optionalNameField')) {
          optionalNameFields.push(references[reference].optionalNameField);
        }
      }

      return optionalNameFields;
    }
    /**
     * Gets placeholder text for lookup input.
     * @param {String} label - Plural name of target api.
     * @returns {String} - Placeholder text for lookup input.
     */


    function computePlaceholder(label) {
      let placeholder;

      if (label) {
        // Returns "Search <label>", for example - "Search Accounts".
        placeholder = `${i18n$m.searchObjectsPlaceholder}`.replace('{0}', label);
      } else {
        // Returns "Search..."
        placeholder = `${i18n$m.searchPlaceholder}`;
      }

      return placeholder;
    }
    /**
     * Computes a list of pills for the record values.
     * @param  {Object} record - A record representation.
     * @param {Object} fieldInfo - The record's field info.
     * @param {Object} referenceInfos - The reference api infos.
     * @returns {Array} - An array of pills for the record field values.
     */


    function computeRecordPills(record, fieldInfo, referenceInfos) {
      let pills = [];

      if (!record || !fieldInfo || !referenceInfos) {
        return pills;
      }

      const relationshipFieldValue = record.fields[fieldInfo.relationshipName].value; // No-op if relationship field value is empty.

      if (!relationshipFieldValue) {
        return pills;
      } // No-op if field value and relationship field value are inconsistent.


      if (relationshipFieldValue.fields.Id.value !== record.fields[fieldInfo.fieldName].value) {
        return pills;
      }

      const apiName = relationshipFieldValue.apiName;

      if (apiName in referenceInfos) {
        const referenceInfo = referenceInfos[apiName];
        const pill = {
          iconAlternativeText: referenceInfo.iconAlternativeText,
          iconName: referenceInfo.iconName,
          iconSize: ICON_SIZE_SMALL,
          label: relationshipFieldValue.fields[referenceInfo.nameField].value,
          type: PILL_TYPE_ICON,
          value: relationshipFieldValue.fields.Id.value
        };
        pills = [pill];
      }

      return pills;
    }
    /**
     * Computes a list of values from record for the given field.
     * @param  {Object} record - A record representation.
     * @param {String} fieldApiName - The qualified field name.
     * @returns {Array} - An array of the record field values.
     */


    function computeRecordValues(record, fieldApiName) {
      if (!record || !fieldApiName) {
        return [];
      }

      const fieldName = computeUnqualifiedFieldApiName(fieldApiName);
      const recordField = record.fields[fieldName];
      return recordField.value && recordField.value.length ? [recordField.value] : [];
    }
    /**
     * Computes a map of supported references apis with their infos like nameField, label, iconName etc.
     * @param {Object} objectInfos - Source record's objectInfos.
     * @param {Object} referenceToInfos - References for the field.
     * @returns {Object} - A map of reference infos.
     */


    function computeReferenceInfos(objectInfos = {}, referenceToInfos = []) {
      if (objectInfos === null) {
        objectInfos = {};
      }

      if (referenceToInfos === null) {
        referenceToInfos = [];
      }

      const references = {};

      for (const reference of referenceToInfos) {
        const apiName = reference.apiName;
        const nameFields = reference.nameFields;
        let nameField;

        if (Array.isArray(nameFields) && nameFields.length > 0) {
          if (nameFields.length > 1) {
            nameField = 'Name';
          } else {
            nameField = nameFields[0];
          }

          const objectInfo = computeObjectInfo(objectInfos, apiName);
          objectInfo.createNewEnabled = undefined;
          objectInfo.nameField = nameField;
          objectInfo.optionalNameField = apiName + '.' + nameField;
          references[apiName] = objectInfo;
        }
      }

      return references;
    }
    /**
     * Computes map of attributes for given object.
     * Common keys include name, label, labelPlural and iconUrl.
     * @param {Object} objectInfo - An objectInfo.
     * @returns {Object} - A map of attributes.
     */


    function computeScopeMap(objectInfo = {}) {
      if (objectInfo === null) {
        objectInfo = {};
      }

      return {
        iconUrl: objectInfo.iconUrl,
        label: objectInfo.label,
        labelPlural: objectInfo.labelPlural,
        name: objectInfo.apiName
      };
    }
    /**
     * Computes the field API name from a qualified field name.
     * For example - Opportunity.AccountId returns 'AccountId'
     * @param {String} fieldApiName - The qualified field name.
     * @return {String} - The unqualified field name.
     */


    function computeUnqualifiedFieldApiName(fieldApiName = '') {
      if (fieldApiName === null) {
        fieldApiName = '';
      }

      const idx = fieldApiName.indexOf('.'); // The object api name must non-empty.

      if (idx < 1) {
        return '';
      }

      return fieldApiName.substring(idx + 1);
    }
    /**
     * Checks if the given term is contains any CJK characters.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term contains any CJK characters.
     */


    function hasCJK(term = '') {
      if (term === null) {
        return false;
      }

      if (typeof term !== 'string') {
        return false;
      }

      const chars = term.trim().split('');

      for (let i = 0; i < chars.length; i++) {
        if (/^[\u1100-\u1200\u3040-\uFB00\uFE30-\uFE50\uFF00-\uFFF0]+$/.test(chars[i])) {
          return true;
        }
      }

      return false;
    }
    /**
     * Checks if at least one action supports "CreateFromLookup".
     * @param {Array} actions - An array of lookup actions received from @wire(getLookupActions)
     * @returns {Boolean} - True if "CreateFromLookup" action was found.
     */


    function hasCreateFromLookup(actions = []) {
      if (actions === null) {
        actions = [];
      }

      let hasCreateNew = false;

      if (!Array.isArray(actions) || actions.length === 0) {
        return hasCreateNew;
      }

      for (let i = 0; i < actions.length; i++) {
        const action = actions[i];
        const actionListContext = action.hasOwnProperty('actionListContext') ? action.actionListContext : null;
        const actionApiName = action.hasOwnProperty('apiName') ? action.apiName : null;
        hasCreateNew = actionListContext === 'Lookup' && actionApiName === 'CreateFromLookup';

        if (hasCreateNew) {
          return hasCreateNew;
        }
      }

      return hasCreateNew;
    }
    /**
     * Checks if object has no keys.
     * @param {String} obj - An object to be validated.
     * @returns {Boolean} - True if object has no keys.
     */


    function isEmptyObject(obj) {
      if (obj === undefined || obj === null) {
        return false;
      } // eslint-disable-next-line guard-for-in


      for (const name in obj) {
        return false;
      }

      return true;
    }
    /**
     * Checks if the given term is a valid search term.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term is a valid search string.
     */


    function isValidSearchTerm(term) {
      if (!term) {
        return false;
      }

      const normalizedTerm = term.replace(/[()"?*]+/g, '').trim();
      return normalizedTerm.length >= 2 || hasCJK(normalizedTerm);
    }
    /**
     * Checks if the given term is a valid typeahead search term.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term is a valid typeahead string.
     */


    function isValidTypeAheadTerm(term) {
      if (!term) {
        return false;
      }

      const normalizedTerm = term.replace(/[()"?*]+/g, '').trim();
      return normalizedTerm.length < 255 && (normalizedTerm.length > 2 || hasCJK(normalizedTerm));
    }
    /**
     * Returns matching indexes for the terms found in the given text.
     *
     * For example -
     * text = "salesforce"
     * words = ["sal","force"]
     * returns - [[0,3],[5,10]]
     *
     * @param {String} text - Original text for matchin search term.
     * @param {String} words - Distinct words or term parts.
     * @return {Array} - An array of intervals.
     */


    function getMatchingIndexes(text, words) {
      let output = []; // No-op if text to match or term is missing.

      if (!text || !words) {
        return output;
      }

      const matchIndexes = {}; // Convert text to lower case for matching.

      const lowerCasedText = text.toLowerCase();

      for (let t = 0; t < words.length; t++) {
        const word = words[t]; // Convert word to lower case for matching.

        const lowerCasedWord = word.toLowerCase();
        let index = 0,
            start = 0,
            numMatches = 0;

        while (start < text.length && index !== -1 && numMatches < 1) {
          index = lowerCasedText.indexOf(lowerCasedWord, start); // Match found.

          if (index > -1) {
            // Get end index for the current term.
            const endIndex = index + lowerCasedWord.length; // If some term part was found previously with the same start
            // index then update the endIndex having longest part.
            // For example -
            // text = "salesforce"
            // words = ["sal", "salesf"]
            //
            // For "sal", matchIndexes would be {0:3}
            // For "salesf", matchIndexes would be updated to {0:6}

            if (matchIndexes[index]) {
              if (matchIndexes[index] < endIndex) {
                matchIndexes[index] = endIndex;
              }
            } else {
              // No matching term part found for the index, make a new entry.
              matchIndexes[index] = endIndex;
            }

            numMatches++; // Increment the start pointer.

            start = endIndex;
          }
        }
      } // Convert indexes map into an array of indexes.


      output = Object.keys(matchIndexes).map(interval => {
        return [parseInt(interval, 10), matchIndexes[interval]];
      });
      return output;
    }
    /**
     * Merges overlapping intervals.
     *
     * For example -
     * intervals = [[0,3],[1,4],[5,7]]
     * returns - [[0,4],[5,7]]
     *
     * @param {Array} intervals - An array of intervals to merge.
     * @return {Array} - An array of merged intervals.
     */


    function mergeIntervals(intervals) {
      if (!intervals || !intervals.length) {
        return [];
      }

      intervals.sort((a, b) => {
        return a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1];
      });
      let prev = intervals[0];
      const output = [prev];

      for (const curr of intervals) {
        if (curr[0] <= prev[1]) {
          prev[1] = Math.max(prev[1], curr[1]);
        } else {
          output.push(curr);
          prev = curr;
        }
      }

      return output;
    }
    /**
     * Splits text using indexes and adds highlight marker.
     *
     * For example -
     * text = "salesforce"
     * intervals = [[0,3]]
     * returns -
     * [
     *  {
     *    "text": "sal",
     *    "highlight": true
     *  },
     *  {
     *    "text": "esforce"
     *  }
     * ]
     *
     * @param {String} text - Original text for matching indexes.
     * @param {Array} intervals - An array of intervals to highlight.
     * @return {Array} - An array of text items with highlighting.
     */


    function splitTextFromMatchingIndexes(text, intervals) {
      const output = []; // No-op if text or intervals is missing.

      if (!text || !intervals || intervals.length === 0) {
        return output;
      } // Merge intervals to avoid incorrect slicing.


      const _intervals = mergeIntervals(intervals); // Sort array based on first value.


      _intervals.sort((prev, next) => {
        return prev[0] > next[0];
      });

      let prevMatchEndIdx = 0;

      for (let i = 0; i < _intervals.length; i++) {
        const startIdx = _intervals[i][0];
        const endIdx = _intervals[i][1]; // Push part before start index.

        const prevText = text.substring(prevMatchEndIdx, startIdx);

        if (prevText) {
          output.push({
            text: prevText
          });
        } // Push part having match.


        output.push({
          text: text.substring(startIdx, endIdx),
          highlight: true
        }); // Update previous match index with current end index.

        prevMatchEndIdx = endIdx;
      } // Push remaining text.


      const remainingText = text.substring(prevMatchEndIdx);

      if (remainingText) {
        output.push({
          text: remainingText
        });
      }

      return output;
    }

    /**
     * Displays an input lookup for the Desktop.
     */

    class LightningLookupDesktop extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */


      /**
       * @return {String} - The lookup field name.
       */
      get fieldName() {
        return this._fieldName;
      }
      /**
       * Sets the field name for the lookup.
       * @param {String|FieldId} value - The lookup field name.
       */


      set fieldName(value) {
        this._fieldName = value;
        this.updateState();
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        const combobox = this.template.querySelector(LIGHTNING_COMBOBOX);

        if (combobox) {
          combobox.focus();
        }
      }
      /**
       * The text label for the field.
       * @type {String}
       */


      /**
       * @return {Number} - The maximum number of values supported by the lookup.
       */
      get maxValues() {
        return this._maxValues;
      }
      /**
       * Sets the maximum number of values that can be inserted into the lookup.
       * @param {Number} value - The maximum number of values for the lookup.
       */


      set maxValues(value) {
        this.updateMaxValues(value);
      }
      /**
       * The error message to be displayed when the user enters the text in the input
       * but does not select a valid option.
       * @type {String}
       *
       */


      /**
       * @return {Object} - The source record's objectInfos.
       */
      get objectInfos() {
        return this._objectInfos;
      }
      /**
       * Sets the source record's objectInfos.
       * @param {Object} value - The source record's objectInfos.
       */


      set objectInfos(value) {
        this._objectInfos = value;
        this.updateState();
      }
      /**
       * @return {Object} - The source record representation.
       */


      get record() {
        return this._record;
      }
      /**
       * Sets the source record representation.
       * @param {Object} value - The source record.
       */


      set record(value) {
        this._record = value;
        this.updateState();
      }
      /**
       * The field info in the object info is not updated based on the layout metadata.
       * It allows field to be marked as required for the given layout.
       * @return {Boolean} - Indicates whether or not the field is required.
       */


      get required() {
        return this._required;
      }
      /**
       * Sets the flag to mark the field as required.
       * @param {Boolean} value - A flag to mark the field as required.
       */


      set required(value) {
        this._required = normalizeBoolean(value);
        this.updateState();
      }
      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */


      reportValidity() {
        const combobox = this.template.querySelector(LIGHTNING_COMBOBOX);

        if (combobox) {
          return this._constraint.reportValidity(message => {
            combobox.setCustomValidity(message);
            combobox.reportValidity();
          });
        }

        return false;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        const combobox = this.template.querySelector(LIGHTNING_COMBOBOX);

        if (combobox) {
          this._constraint.setCustomValidity(message);

          combobox.setCustomValidity(message);
        }
      }
      /**
       * TODO - Remove when @wire(getLookupActions) response is invocable.
       * @return {Boolean} Indicates whether or not to show the create new option.
       */


      get showCreateNew() {
        return this._showCreateNew;
      }
      /**
       * TODO - Remove when @wire(getLookupActions) response is invocable.
       * Sets the flag to enable or disable create new option.
       * If set to true, a backend validation is made using @wire(getLookupActions) to check if
       * create action from lookup is supported for the given target api, and option is added accordingly.
       * @param {Boolean} value - A flag to enable or disable create new option.
       */


      set showCreateNew(value) {
        this._showCreateNew = normalizeBoolean(value);
        this.updateState();
      }
      /**
       * Displays a validation message if the lookup is in invalid state.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * @return {Array} An array of selected lookup values.
       */


      get value() {
        return this._value;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        // Update values, and pills.
        this.updateValue(value, [], false);
      }
      /**
       * Sets the variant type for the lookup.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Gets the validity constaint.
       */
      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => this.isRequired && (!Array.isArray(this._value) || !this._value.length),
            badInput: () => this.inputText.trim().length
          });
        }

        return this._constraintApi;
      }
      /**
       * Returns an input text for the entity filter.
       * @returns {String} See desc.
       */


      get filterInputText() {
        return this._targetObjectInfo.label;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.label = void 0;
        this.messageWhenBadInput = computeMessageWhenBadInputDefault();
        this.messageWhenValueMissing = void 0;
        this.variant = void 0;
        this.fieldLevelHelp = void 0;
        this.filterItems = void 0;
        this.filterLabel = void 0;
        this.inputIconName = void 0;
        this.inputMaxlength = void 0;
        this.inputPill = null;
        this.inputText = '';
        this.items = [];
        this.isRequired = void 0;
        this.pills = [];
        this.placeholder = '';
        this.showActivityIndicator = void 0;
        this._abortWireItems = false;
        this._actionObjectApiNames = void 0;
        this._actionRequestParams = void 0;
        this._connected = false;
        this._fieldApiName = void 0;
        this._fieldInfo = void 0;
        this._fieldName = void 0;
        this._getLookupActionsInProgress = void 0;
        this._getLookupRecordsInProgress = void 0;
        this._getRecordUiInProgress = void 0;
        this._hasDropdownOpened = void 0;
        this._maxValues = 1;
        this._objectInfos = void 0;
        this._optionalFields = void 0;
        this._pills = [];
        this._record = void 0;
        this._recordIds = void 0;
        this._referenceInfos = {};
        this._requestParams = {
          [QUERY_PARAMS_Q]: '',
          [QUERY_PARAMS_SEARCH_TYPE]: SEARCH_TYPE_RECENT,
          [QUERY_PARAMS_PAGE]: DEFAULT_PAGE,
          [QUERY_PARAMS_PAGE_SIZE]: DEFAULT_PAGE_SIZE,
          [QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS]: null
        };
        this._required = false;
        this._showCreateNew = false;
        this._sourceObjectInfo = {};
        this._targetApiName = void 0;
        this._targetObjectInfo = {};
        this._value = void 0;
        this._wireItems = [];
        this.inputIconName = ICON_SEARCH;
        this.inputMaxlength = INPUT_MAX_LENGTH;
        this.filterLabel = computeFilterLabel();
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      } // ================================================================================
      // WIRE METHODS
      // ================================================================================


      wiredLookupActions({
        error,
        data
      }) {
        // Update wire status.
        this.updateWireStatus('getLookupActions', false);

        if (error) {
          this.fireEvent(EVENT_LDS_ERROR, error);
          return;
        } else if (!data) {
          return;
        }

        try {
          for (const apiName in data.actions) {
            if (data.actions.hasOwnProperty(apiName) && this._referenceInfos.hasOwnProperty(apiName)) {
              this._referenceInfos[apiName].createNewEnabled = hasCreateFromLookup(data.actions[apiName].actions);
            }
          }
        } catch (e) {
          this.fireEvent(EVENT_ERROR, {
            error: e
          });
        }
      }

      wiredLookupRecords({
        error,
        data
      }) {
        // Update wire status.
        this.updateWireStatus('getLookupRecords', false);

        if (error) {
          this.resetCombobox();
          this.fireEvent(EVENT_LDS_ERROR, error);
          return;
        } else if (!data || this._abortWireItems) {
          return;
        }

        try {
          const records = data ? data.records : [];
          this._wireItems = records.map(record => {
            const fields = record.fields;
            return {
              iconAlternativeText: this._targetObjectInfo.iconAlternativeText,
              iconName: this._targetObjectInfo.iconName,
              iconSize: ICON_SIZE_SMALL,
              subText: fields.hasOwnProperty('DisambiguationField') ? fields.DisambiguationField.value : null,
              text: fields[this._referenceInfos[this._targetObjectInfo.apiName].nameField].value,
              type: OPTION_TYPE_CARD,
              value: fields.Id.value
            };
          });
          /*
           * During init both getLookupActions and getLookupRecords wire actions are in progress simultaneously.
           * Delaying updating record items until both actions are received.
           * TODO - W-5313904 - Handle this with Promises
           */

          if (this._getLookupActionsInProgress) {
            let counter = 0;

            const delayedUpdateItems = () => {
              if (this._getLookupActionsInProgress && counter < 100) {
                counter++; // eslint-disable-next-line lwc/no-set-timeout

                setTimeout(delayedUpdateItems, 100);
              } else {
                this.updateItems();
              }
            }; // eslint-disable-next-line lwc/no-set-timeout


            setTimeout(delayedUpdateItems, 100);
          } else {
            // Update display items.
            this.updateItems();
          }
        } catch (e) {
          this.fireEvent(EVENT_ERROR, {
            error: e
          });
        }
      }

      wiredRecordUi({
        error,
        data
      }) {
        // Update wire status.
        this.updateWireStatus('getRecordUi', false);

        if (error) {
          this.fireEvent(EVENT_LDS_ERROR, error);
          return;
        } else if (!data) {
          return;
        }

        try {
          const pills = [];
          const invalidValues = [];

          for (const r in data.records) {
            if (data.records.hasOwnProperty(r)) {
              const record = data.records[r];
              const apiName = record.apiName; // Process records of supported target apis.

              if (this._referenceInfos.hasOwnProperty(apiName)) {
                const iconName = computeIconName(this._objectInfos[apiName]);
                const pill = {
                  iconAlternativeText: apiName,
                  iconName,
                  label: record.fields[this._referenceInfos[apiName].nameField].value,
                  type: PILL_TYPE_ICON,
                  value: record.id
                };
                pills.push(pill);
              } else {
                // Collect values with invalid reference apis.
                invalidValues.push(record.id);
              }
            }
          }

          if (invalidValues.length > 0 && this._value) {
            // Remove invalid values from this._values
            const values = this._value.filter(value => !invalidValues.includes(value)); // Update values, and pills.


            this.updateValue(values, pills, false);
          } else {
            // Update pills only as no invalid values found.
            this.updatePills(pills);
          }
        } catch (e) {
          this.fireEvent(EVENT_ERROR, {
            error: e
          });
        }
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Aborts processing data from the wire action in flight.
       */


      abortWireAction() {
        this._abortWireItems = true;
        this._wireItems = [];
        this.updateWireStatus('getLookupRecords', false);
      }
      /**
       * Callback method executed by the parent component to update values after handling "createnew" event.
       * @param {Array} values - An array of newly created record ids.
       */


      createNewCallback(values = []) {
        if (!Array.isArray(values) || !values.length) {
          return;
        } // Append new values to exisitng values.


        const newValues = Object.assign([], this._value).concat(values); // Update values, pills, and fire change event.

        this.updateValue(newValues);
      }
      /**
       * Fires an event with details for parent component to handle.
       * @param {String} type - The type of event being dispatched.
       * @param {Object} detail - The event data.
       * @param {Boolean} bubbles - Whether or not the event bubbles.
       */


      fireEvent(type, detail, bubbles = true) {
        let event;

        switch (type) {
          case EVENT_ERROR:
            // eslint-disable-next-line no-console
            console.error(detail.error.message);
            event = computeEvent(type, detail, bubbles);
            break;

          case EVENT_LDS_ERROR:
            // eslint-disable-next-line no-console
            console.error(detail.message);
            event = createErrorEvent(detail);
            break;

          default:
            event = computeEvent(type, detail, bubbles);
            break;
        } // Trigger event.


        if (event) {
          this.dispatchEvent(event);
        }
      }
      /**
       * Handles advanced search by showing scoped results in a panel.
       */


      handleAdvancedSearchAction() {
        // Log click on advanced search option interaction.
        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_MRU_ACTION_ITEM, {
          scopeName: this._targetObjectInfo.apiName,
          type: LOG_ACTION_SEARCH_OPTION
        });
        const scopeMap = computeScopeMap(this._targetObjectInfo);

        const saveCallback = values => {
          // Advanced search returns an array of selected values.
          if (values && values.length > 0) {
            // Select first value as selected value.
            const selectedValue = values[0];
            const recordId = selectedValue.id;

            if (!Array.isArray(this._value) || !this._value.includes(recordId)) {
              const vals = Object.assign([], this._value);
              vals.push(recordId); // Compute pill if label is available.
              // This avoids unnecessary triggering of wire.

              if (selectedValue.Name) {
                const pill = {
                  iconAlternativeText: this._targetObjectInfo.iconAlternativeText,
                  iconName: this._targetObjectInfo.iconName,
                  label: selectedValue.Name,
                  type: PILL_TYPE_ICON,
                  value: recordId
                };
                const pills = Object.assign([], this._pills);
                pills.push(pill); // Update values with pills.

                this.updateValue(vals, pills);
              } else {
                // Update values, and resolve pills later.
                this.updateValue(vals);
              } // Reset combobox.


              this.resetCombobox();
              this.focus();
            }
          }
        };

        const fieldName = computeUnqualifiedFieldApiName(this._fieldApiName);
        const lookupAdvancedAttributes = {
          additionalFields: [],
          contextId: '',
          dependentFieldBindings: computeBindingsMap(this._record, this._fieldInfo.dependentFields),
          entities: [scopeMap],
          field: fieldName,
          groupId: ADVANCED_SEARCH_GROUP_ID,
          label: this.label,
          maxValues: ADVANCED_SEARCH_MAX_VALUES,
          placeholder: this.placeholder,
          recordId: Array.isArray(this._value) && this._value.length ? this._value[0] : '',
          saveCallback,
          scopeMap,
          scopeSets: {
            DEFAULT: [scopeMap]
          },
          source: this._sourceObjectInfo.apiName,
          term: this.inputText
        };

        try {
          // Show advanced search modal.
          showAdvancedSearch(lookupAdvancedAttributes);
        } catch (error) {
          this.fireEvent(EVENT_ERROR, {
            error
          });
        }
      }
      /**
       * Shows validation message based on the validity status on blur of the input.
       */


      handleBlur() {
        this.reportValidity();
      }
      /**
       * Handles create new option selection.
       */


      handleCreateNewAction() {
        // Log click on create new option interaction.
        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_MRU_ACTION_ITEM, {
          scopeName: this._targetObjectInfo.apiName,
          sourceName: this._sourceObjectInfo.apiName,
          type: LOG_ACTION_CREATE_NEW_OPTION
        }); // Fire an event to notify parent to handle create new action.

        this.fireEvent(EVENT_CREATE_NEW, {
          value: this._targetObjectInfo.apiName,
          callback: this.createNewCallback.bind(this)
        }); // Reset combobox.

        this.resetCombobox();
      }
      /**
       * Handles the input's focus event.
       */


      handleDropdownOpenRequest() {
        // Log lookup activation.
        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_INPUT, {
          scopeName: this._targetObjectInfo.apiName
        }); // On the first focus update the internal state that triggers wire..

        if (!this._hasDropdownOpened) {
          this._hasDropdownOpened = true; // Executes wire actions deferred until user's first interaction.

          this.updateState();
        } // Show MRU items only if -
        // 1) There is no wire action in flight AND
        // 2) User has not typed any inputText.


        if (!this._getLookupRecordsInProgress && !this.inputText.length) {
          this.updateTerm('');
        }
      }
      /**
       * Handles the oninput and onchange events from the combobox input, triggering an update to @wire parameters.
       * @param {Object} event - The input's oninput/onchange event.
       */


      handleInputTextChange(event) {
        // Stop combobox event propagation.
        event.stopPropagation(); // No-op if event detail is empty.

        if (!event.detail) {
          return;
        }

        const term = event.detail.text || ''; // Update term.

        this.updateTerm(term);
      }
      /**
       * Handles the pillremove event fired from combo-box when a selected option is removed.
       * @param {Object} event - Contains details of the event being handled.
       */


      handlePillRemove(event) {
        // Log input pill removal interaction.
        log(LOG_EVENT_PILL_REMOVE, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_RECORD_PILL_ITEM, {
          scopeName: this._targetObjectInfo.apiName
        });

        if (this._maxValues === 1) {
          // Update values, and pills.
          this.updateValue([]);
        } else if (this._maxValues > 1) {
          // No-op if event detail is empty.
          if (!event.detail) {
            return;
          }

          const removedValue = event.detail.item.value;

          if (removedValue && this._value && this._pills) {
            // Remove deleted value.
            const values = this._value.filter(v => {
              return v !== removedValue;
            }); // Remove pill for the removed value.


            const pills = this._pills.filter(p => {
              return p.value !== removedValue;
            }); // Update values, and pills.


            this.updateValue(values, pills);
          }
        } // Reset combobox.


        this.resetCombobox();
      }
      /**
       * Handles record option selection
       * @param {String} recordId - The record id of the option.
       */


      handleRecordOptionSelect(recordId) {
        // No-op if record id is empty.
        if (!recordId) {
          return;
        } // No-op if maxValues count is reached.


        if (Array.isArray(this._value) && this._value.length === this._maxValues) {
          return;
        }

        const isMRU = this._requestParams[QUERY_PARAMS_SEARCH_TYPE] === SEARCH_TYPE_RECENT;
        const itemCount = this.items.length;
        const position = this.items.findIndex(item => {
          return item.value === recordId;
        }); // Log click on record option interaction.

        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_MRU_ITEM, {
          recordId,
          position,
          qType: isMRU ? LOG_CONTEXT_Q_TYPE_MRU : LOG_CONTEXT_Q_TYPE_TYPEAHEAD,
          mruVisibleCount: isMRU ? itemCount : 0,
          typeAheadVisibleCount: isMRU ? 0 : itemCount,
          scopeName: this._targetObjectInfo.apiName
        });

        if (!Array.isArray(this._value) || !this._value.includes(recordId)) {
          // Append new value to the existing list.
          const values = Object.assign([], this._value);
          values.push(recordId); // Selected recordId is always expected to be present in the wireItems.
          // Use it to populate pill info so as to avoid triggering wire.

          const wireItem = this._wireItems.find(record => {
            return record.value === recordId;
          });

          const pills = Object.assign([], this._pills);
          pills.push({
            iconAlternativeText: wireItem.iconAlternativeText,
            iconName: wireItem.iconName,
            iconSize: wireItem.iconSize,
            label: wireItem.text,
            type: PILL_TYPE_ICON,
            value: wireItem.value
          }); // Update values, and pills.

          this.updateValue(values, pills); // Reset combobox.

          this.resetCombobox();
        }
      }
      /**
       * Handles the select event fired from combo-box when an option is selected.
       * @param {Object} event - Contains details of the event being handled.
       */


      handleSelect(event) {
        const value = event.detail.value;

        switch (value) {
          case ACTION_ADVANCED_SEARCH:
            this.handleAdvancedSearchAction();
            break;

          case ACTION_CREATE_NEW:
            this.handleCreateNewAction();
            break;

          default:
            this.handleRecordOptionSelect(value);
            break;
        }
      }
      /**
       * Handles entity filter change.
       * @param {Object} event - The filter's onchange event object.
       */


      handleSelectFilter(event) {
        if (!event.detail) {
          return;
        } // Log click on filter item interaction.


        log(LOG_EVENT_CLICK, LOG_SCOPE_ENTITY_SELECTOR, LOG_TARGET_FILTER_ITEM, {
          scopeName: this._targetObjectInfo.apiName
        });
        const selectedEntity = event.detail.value; // No-op if newly selected target api is the same as the previous one.

        if (selectedEntity === this._targetObjectInfo.apiName) {
          return;
        } // If it's a single value lookup then clear values for the previous target api.


        if (this._maxValues === 1) {
          this.updateValue([]);
        } // Update target object info as per newly selected entity.


        this._targetObjectInfo = computeObjectInfo(this._objectInfos, selectedEntity); // Update internal state.

        this.updateState();
      }
      /**
       * Resets combobox, and aborts receiving new items.
       */


      resetCombobox() {
        if (this.items.length) {
          this.items = [];
        }

        this.inputText = '';
        this.abortWireAction();
      }
      /**
       * Adds advanced search action option to the display items.
       */


      setAdvancedSearchOption() {
        const term = this.inputText || ''; // Insert the advanced search action if a valid search term found.

        if (isValidSearchTerm(term)) {
          const advancedSearchOption = computeAdvancedSearchOption(term, this._targetObjectInfo.labelPlural);
          this.items.unshift(advancedSearchOption); // Trigger items setter for the combobox.

          this.items = this.items.slice();
        }
      }
      /**
       * Adds the create new action option to the display items.
       */


      setCreateNewOption() {
        if (this.showCreateNew && // TODO - Remove when @wire(getLookupActions) response is invocable.
        this._referenceInfos[this._targetObjectInfo.apiName].createNewEnabled) {
          this.items.push(computeCreateNewOption(this._targetObjectInfo.label)); // Trigger items setter for the combobox.

          this.items = this.items.slice();
        }
      }
      /**
       * Checks if combobox items should be displayed.
       * @returns {Boolean} - True if items should be shown.
       */


      shouldDisplayItems() {
        let displayItems;

        if (!this._hasDropdownOpened) {
          displayItems = false;
        } else if (this._maxValues === 1 && this.inputPill) {
          // Don't show items if it's a single-value lookup, and inputPill is already present.
          displayItems = false;
        } else {
          displayItems = true;
        } // Clear display items.


        if (!displayItems && this.items.length) {
          this.items = [];
        }

        return displayItems;
      }
      /**
       * Updates combobox filter items.
       */


      updateFilterItems() {
        // For single-value lookup, if an inputPill is present then filter items shouldn't be shown.
        if (this._maxValues === 1 && this.inputPill) {
          this.filterItems = null;
        } else {
          this.filterItems = computeFilterItems(this._referenceInfos, this._targetObjectInfo.apiName);
        }

        this.updatePlaceholder();
      }
      /**
       * Updates the list of items displayed in the grouped-combobox dropdown,
       * adding the advanced search option if a valid search term is present.
       */


      updateItems() {
        // No-op if items are not expected to be displayed.
        if (!this.shouldDisplayItems()) {
          return;
        } // Clear previous items.


        if (this.items.length) {
          this.items = [];
        }

        const term = this.inputText || '';
        const filteredItems = computeDedupedItems(this._wireItems, this._value, DEFAULT_LIST_SIZE);

        if (filteredItems.length > 0) {
          if (!term.length) {
            // Show MRU items with the heading.
            this.items = [{
              label: computeHeading(this._targetObjectInfo.labelPlural),
              items: filteredItems
            }];
          } else if (term.length > 0) {
            // Get items with highlighting.
            this.items = computeHighlightedItems(filteredItems, term);
          }
        } // Add advanced search option.


        this.setAdvancedSearchOption(); // Add create new option.

        this.setCreateNewOption();
      }
      /**
       * Updates max value count. Also updates existing values, and pills correspondingly.
       * @param {Number} count - The maximum number of values supported by the lookup.
       */


      updateMaxValues(count) {
        // Update internal state of maxValues.
        this._maxValues = count; // No-op if values are not defined.

        if (!Array.isArray(this._value) || !this._value.length) {
          return;
        }

        let pills; // Trim existing values as per new max count.

        if (this._value.length > this._maxValues) {
          const values = this._value.slice(0, this._maxValues); // Trim existing pills as per new max count.


          const pillValues = this._pills.map(pill => {
            return pill.value;
          });

          if (arraysIdentical(pillValues, this._value)) {
            // Trim pills if they are up to date with the values.
            pills = this._pills.slice(0, this._maxValues);
            this.updateValue(values, pills, false);
          } else {
            this.updateValue(values, [], false);
          }
        } else {
          pills = Object.assign([], this._pills); // Update pills arrangement only since values remain the same.

          this.updatePills(pills);
        }
      }
      /**
       * Updates the pill using info it obtained via argument, local data or wire.
       * @param {Array} pills - An array of pills infos representing values.
       */


      updatePills(pills = []) {
        // Check if any pills are missing, if so then trigger @wire(getRecordUi) to resolve them.
        const pillValues = pills.map(pill => {
          return pill.value;
        });
        let pillsResolved = arraysIdentical(pillValues, this._value);

        if (!pillsResolved) {
          try {
            // Try to resolve pill from the source record itself to avoid hitting wire.
            const values = computeRecordValues(this._record, this._fieldApiName);

            if (arraysIdentical(values, this._value)) {
              pills = computeRecordPills(this._record, this._fieldInfo, this._referenceInfos);

              if (pills.length) {
                pillsResolved = true;
              }
            }
          } catch (error) {
            this.fireEvent(EVENT_ERROR, {
              error
            });
          }
        }

        if (pillsResolved) {
          // Update internal copy of pills.
          this._pills = pills; // Pills are empty, hence clear input as well as container pills.

          if (!pills.length) {
            this.inputPill = null;
            this.pills = [];
          } else if (pills.length > 0) {
            // inputPill, and pills can never co-exist.
            if (this._maxValues === 1) {
              this.inputPill = this._pills[0];
              this.pills = [];
            } else if (this._maxValues > 1) {
              this.pills = this._pills;
              this.inputPill = null;
            }
          } // Check if items should be displayed, and clear if necessary.


          this.shouldDisplayItems(); // Update filter items.

          this.updateFilterItems(); // Grab the focus after populating pills.

          this.focus();
          return;
        }

        if (!pillsResolved && this._value.length) {
          // Trigger wire to get record representations of live values, and update pills.
          this.updateWireStatus('getRecordUi', true);
          this._optionalFields = computeOptionalNameFields(this._referenceInfos);
          this._recordIds = this._value.slice();
        }
      }
      /**
       * Updates combobox input placeholder
       */


      updatePlaceholder() {
        const referenceApiNames = Object.keys(this._referenceInfos); // If it's a multi-entity lookup then the placeholder should be "Search..."

        const label = referenceApiNames.length === 1 ? this._targetObjectInfo.labelPlural : null;
        this.placeholder = computePlaceholder(label);
      }
      /**
       * Updates _requestParams to trigger @wire's observable.
       * @param {String} key - A property on _requestParams.
       * @param {String} value - A value corresponding to the property.
       */


      updateRequestParams(key, value) {
        // No-op if items are not expected to be displayed.
        if (!this.shouldDisplayItems()) {
          return;
        }

        this._requestParams[key] = value;
        this._requestParams = Object.assign({}, this._requestParams); // Trigger wire.

        this._targetApiName = this._targetObjectInfo.apiName;

        if (this._targetApiName && this._fieldApiName) {
          this.updateWireStatus('getLookupRecords', true);
        }
      }
      /**
       * Updates lookup's internal state.
       */


      updateState() {
        if (!this._fieldName || !Object.keys(this._record || {}).length || !Object.keys(this._objectInfos || {}).length) {
          return;
        }

        try {
          // Update source object info.
          this._sourceObjectInfo = computeObjectInfo(this._objectInfos, this._record.apiName); // Update field info.

          this._fieldApiName = computeFieldApiName(this._fieldName, this._sourceObjectInfo.apiName);
          this._fieldInfo = computeFieldInfo(this._objectInfos, this._sourceObjectInfo.apiName, this._fieldApiName);
          this.fieldLevelHelp = this._fieldInfo.inlineHelpText;
          this._referenceInfos = computeReferenceInfos(this._objectInfos, this._fieldInfo.references); // If field is marked as required in the field info then override the public property.

          if (this._fieldInfo.isRequired) {
            this._required = this._fieldInfo.isRequired;
          }

          this.isRequired = this._required; // Update dependent field bindings for the request params.

          this.updateRequestParams(QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS, computeBindingsString(this._record, this._fieldInfo.dependentFields)); // Update target info.
          // Select first field reference apiName as target api if targetObjectInfo is empty or stale.

          if (isEmptyObject(this._targetObjectInfo) || !this._referenceInfos.hasOwnProperty(this._targetObjectInfo.apiName)) {
            let targetApi;
            const fieldReferences = this._fieldInfo.references;

            if (Array.isArray(fieldReferences) && fieldReferences.length) {
              targetApi = fieldReferences[0].apiName;
            }

            this._targetObjectInfo = computeObjectInfo(this._objectInfos, targetApi);
          } else {
            // Update state could be triggered due to updating of objectInfos hence re-create
            // targetObjectInfo for it's apiName.
            this._targetObjectInfo = computeObjectInfo(this._objectInfos, this._targetObjectInfo.apiName);
          } // Update filter items for entity selection.


          this.updateFilterItems(); // Update values.

          if (this._value === undefined) {
            const values = computeRecordValues(this._record, this._fieldApiName); // Don't fire change event since default values is assigned from the record.

            this.updateValue(values, [], false);
          } // Update action info.
          // Defer wire action until user activates the lookup.


          const referenceApiNames = Object.keys(this._referenceInfos);

          if (this.showCreateNew && this._hasDropdownOpened) {
            // Trigger wire only if new reference apis found.
            this.updateWireStatus('getLookupActions', true);
            this._actionObjectApiNames = referenceApiNames;
          } // Reset combobox.


          this.resetCombobox();
        } catch (error) {
          this.fireEvent(EVENT_ERROR, {
            error
          });
        }
      }
      /**
       * Updates term state, triggering the @wire service on term change.
       * @param  {String} term - The search term.
       */


      updateTerm(term) {
        // Update combobox input text value.
        this.inputText = term; // Allow processing of the wire items.

        this._abortWireItems = false; // Determine if it's a MRU or TypeAhead request, and update request params.

        this.updateRequestParams(QUERY_PARAMS_SEARCH_TYPE, isValidTypeAheadTerm(term) ? SEARCH_TYPE_TYPEAHEAD : SEARCH_TYPE_RECENT); // Update search term, and trigger wire.

        this.updateRequestParams(QUERY_PARAMS_Q, term.trim());
      }
      /**
       * Updates the live value, sets the pills and fires 'change' event if requested.
       * Typically 'change' event should be triggered when values are committed by the user.
       * @param {Array} value - An array of record ids.
       * @param {Array} pills - An array of pill infos corresponding to the values.
       * @param {Boolean} triggerEvent - Whether or not to fire change event.
       */


      updateValue(value = [], pills = [], triggerEvent = true) {
        if (value === null) {
          value = [];
        }

        if (!Array.isArray(value)) {
          return;
        }

        if (value.length) {
          value = value.filter(val => val) // Drop empty.
          .map(val => normalizeRecordId(val.trim())) // Convert to 18-char record ids.
          .filter((elem, index, self) => {
            return index === self.indexOf(elem); // De-deupe.
          });
        } // No-op if values remain unchanged.


        if (arraysIdentical(value, this._value)) {
          return;
        } // Trim values as per the max count.


        if (value.length > this._maxValues) {
          value = value.slice(0, this._maxValues);
        } // Update internal copy of values.


        this._value = value; // Update pills.

        this.updatePills(pills);

        if (triggerEvent) {
          // Fire an event to notify that values have been changed.
          this.fireEvent(EVENT_CHANGE, {
            value: this._value
          });
        }
      }
      /**
       * Updates the wire activity status.
       * @param {String} adapterName - Name of the wire adapter.
       * @param {Boolean} inProgress - True if wire action is in progress.
       */


      updateWireStatus(adapterName, inProgress = true) {
        if (!adapterName) {
          return;
        }

        const flag = '_' + adapterName + 'InProgress'; // Update internal status.

        this[flag] = inProgress; // Update combobox input spinner.

        this.showActivityIndicator = this._getLookupActionsInProgress || this._getLookupRecordsInProgress || this._getRecordUiInProgress;
      }

    }

    lwc.registerDecorators(LightningLookupDesktop, {
      publicProps: {
        disabled: {
          config: 0
        },
        fieldName: {
          config: 3
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 3
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        objectInfos: {
          config: 3
        },
        record: {
          config: 3
        },
        required: {
          config: 3
        },
        showCreateNew: {
          config: 3
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      wire: {
        wiredLookupActions: {
          adapter: lds.getLookupActions,
          params: {
            objectApiNames: "_actionObjectApiNames"
          },
          static: {},
          method: 1
        },
        wiredLookupRecords: {
          adapter: lds.getLookupRecords,
          params: {
            fieldApiName: "_fieldApiName",
            requestParams: "_requestParams",
            targetApiName: "_targetApiName"
          },
          static: {},
          method: 1
        },
        wiredRecordUi: {
          adapter: lds.getRecordUi,
          params: {
            optionalFields: "_optionalFields",
            recordIds: "_recordIds"
          },
          static: {
            layoutTypes: [LAYOUT_TYPE_FULL],
            modes: [MODE_VIEW]
          },
          method: 1
        }
      },
      track: {
        fieldLevelHelp: 1,
        filterItems: 1,
        filterLabel: 1,
        inputIconName: 1,
        inputMaxlength: 1,
        inputPill: 1,
        inputText: 1,
        items: 1,
        isRequired: 1,
        pills: 1,
        placeholder: 1,
        showActivityIndicator: 1
      }
    });

    var _lightningLookupDesktop = lwc.registerComponent(LightningLookupDesktop, {
      tmpl: _tmpl$D
    });

    function stylesheet$j(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$j = [stylesheet$j];

    function tmpl$I($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp.disabled,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "label": $cmp.label,
          "maxLength": $cmp.maxlength,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "name": $cmp.fieldName,
          "required": $cmp.isRequired,
          "value": $cmp.inputValue,
          "variant": $cmp.variant
        },
        key: 2,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleInputValueChange))
        }
      }, [])];
    }

    var _tmpl$E = lwc.registerTemplate(tmpl$I);
    tmpl$I.stylesheets = [];

    if (_implicitStylesheets$j) {
      tmpl$I.stylesheets.push.apply(tmpl$I.stylesheets, _implicitStylesheets$j);
    }
    tmpl$I.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobile_lookupMobile-host",
      shadowAttribute: "lightning-lookupMobile_lookupMobile"
    };

    /**
     * An event indicating a change in lookup value.
     * @type {String}
     */
    const EVENT_CHANGE$1 = 'change';
    /**
     * The lightning input component name
     * @type {String}
     */

    const LIGHTNING_INPUT = 'lightning-input';
    /**
     * The max length for input.
     * @type {Number}
     */

    const INPUT_MAX_LENGTH$1 = 255;

    /**
     * Given a record, field, and objectInfos, returns a map of field attributes.
     *
     * Returned schema -
     * {
     *      inlineHelpText: {String},
     *      isRequired: {Boolean},
     * }
     *
     * @param {Object} record - A record representation.
     * @param {String} fieldName - A field api name.
     * @param {Object} objectInfos - A map of objectInfos.
     * @return {Object} A map of field attributes.
     */
    function getFieldProperties(record, fieldName, objectInfos) {
      if (Object.keys(record || {}).length === 0 || !fieldName || Object.keys(objectInfos || {}).length === 0) {
        return {
          fieldLevelHelp: null,
          isRequired: false
        };
      }

      const objectApiName = record.apiName;
      const objectInfo = objectInfos[objectApiName];

      if (!objectInfo) {
        throw new Error(`ObjectInfo [${objectApiName}] was not found`);
      }

      const fieldInfo = objectInfo.fields[fieldName];

      if (!fieldInfo) {
        throw new Error(`Field [${fieldName}] was not found`);
      }

      return {
        fieldLevelHelp: fieldInfo.inlineHelpText,
        isRequired: fieldInfo.required
      };
    }

    class LightningLookupMobile extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */


      /**
       * @return {String} The lookup field API name.
       */
      get fieldName() {
        return this._fieldName;
      }
      /**
       * Sets the api name for the lookup field.
       * @param {String} value - The lookup field api name.
       */


      set fieldName(value) {
        this._fieldName = value;
        const {
          fieldLevelHelp,
          isRequired
        } = getFieldProperties(this._record, this._fieldName, this._objectInfos);
        this.fieldLevelHelp = fieldLevelHelp;
        this.isRequired = isRequired;
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        const input = this.template.querySelector(LIGHTNING_INPUT);

        if (input) {
          input.focus();
        }
      }
      /**
       * The text label for the layout field.
       * @type {String}
       */


      /**
       * @return {Number} - The maximum number of values supported by the lookup.
       */
      get maxValues() {
        return this._maxValues;
      }
      /**
       * Sets the maximum number of values that can be inserted into the lookup.
       * @param {Number} value - The maximum number of values for the lookup.
       */


      set maxValues(value) {
        this._maxValues = value;
        const values = Object.assign([], this._value);
        this.updateValue(values);
      }
      /**
       * The error message to be displayed when the user enters bad input.
       * @type {String}
       */


      /**
       * @return {Object} The source record's objectInfos.
       */
      get objectInfos() {
        return this._objectInfos;
      }
      /**
       * Sets the source record's objectInfos.
       * @param {Object} value - The source record's objectInfos.
       */


      set objectInfos(value) {
        this._objectInfos = value;
        const {
          fieldLevelHelp,
          isRequired
        } = getFieldProperties(this._record, this._fieldName, this._objectInfos);
        this.fieldLevelHelp = fieldLevelHelp;
        this.isRequired = isRequired;
      }
      /**
       * @return {Object} Returns the source record representation.
       */


      get record() {
        return this._record;
      }
      /**
       * Sets the source record representation.
       * @param {Object} value - The source record.
       */


      set record(value) {
        this._record = value;
        const {
          fieldLevelHelp,
          isRequired
        } = getFieldProperties(this._record, this._fieldName, this._objectInfos);
        this.fieldLevelHelp = fieldLevelHelp;
        this.isRequired = isRequired;
      }
      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */


      reportValidity() {
        const input = this.template.querySelector(LIGHTNING_INPUT);

        if (input) {
          return this._constraint.reportValidity(message => {
            input.setCustomValidity(message);
            input.reportValidity();
          });
        }

        return null;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        const input = this.template.querySelector(LIGHTNING_INPUT);

        if (input) {
          this._constraint.setCustomValidity(message);

          input.setCustomValidity(message);
        }
      }
      /**
       * Indicates whether or not the field is required.
       * // TODO - Consume required api.
       * @type {Boolean}
       */


      /**
       * Displays an error message if the combobox value is required but missing.
       */
      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * @return {Array} An array of selected lookup values.
       */


      get value() {
        return this._value;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        this.updateValue(value);
      }
      /**
       * Sets the variant type for the lookup.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Gets the validity constaint.
       */
      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => this.isRequired && (!Array.isArray(this._value) || !this._value.length)
          });
        }

        return this._constraintApi;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.label = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenValueMissing = void 0;
        this.required = false;
        this.showCreateNew = false;
        this.variant = void 0;
        this.fieldLevelHelp = void 0;
        this.inputValue = void 0;
        this.isRequired = void 0;
        this.maxlength = void 0;
        this._connected = false;
        this._fieldName = void 0;
        this._maxValues = void 0;
        this._objectInfos = void 0;
        this._record = void 0;
        this._value = void 0;
        this.maxlength = INPUT_MAX_LENGTH$1;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Fires an event with details for parent component to handle.
       * @param {String} type - The type of event being dispatched.
       * @param {Object} detail - The event data.
       * @param {Boolean} bubbles - Whether or not the event bubbles.
       */


      fireEvent(type, detail, bubbles) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        new CustomEvent(type, {
          composed: bubbles,
          bubbles,
          detail
        }));
      }

      handleInputValueChange(event) {
        // Stop input event propagation.
        event.stopPropagation(); // No-op if event detail is empty.

        if (!event.detail) {
          return;
        }

        const text = (event.detail.value || '').trim();
        let values;

        if (!text.length) {
          // Default empty string value to an empty array.
          values = [];
        } else {
          // Convert comma separated values to an array.
          values = text.split(',');
        }

        this.updateValue(values);
      }
      /**
       * Updates the live value and sets the pills.
       * @param {Array} value - An array of record ids.
       */


      updateValue(value) {
        if (value === undefined) {
          this._value = value;
          return;
        } else if (value === null) {
          value = [];
        }

        if (!Array.isArray(value)) {
          return;
        } // Drop empty values, and trim them to remove extra white spaces.


        value = value.filter(val => val).map(val => val.trim()); // Trim values to the max value count.

        if (value.length > this._maxValues) {
          value = value.slice(0, this._maxValues);
        }

        this._value = value;
        this.inputValue = value.join(','); // Fire event to notify that values have been changed.

        this.fireEvent(EVENT_CHANGE$1, {
          value: this._value
        }, true);
      }

    }

    lwc.registerDecorators(LightningLookupMobile, {
      publicProps: {
        disabled: {
          config: 0
        },
        fieldName: {
          config: 3
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 3
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        objectInfos: {
          config: 3
        },
        record: {
          config: 3
        },
        required: {
          config: 0
        },
        showCreateNew: {
          config: 0
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        fieldLevelHelp: 1,
        inputValue: 1,
        isRequired: 1,
        maxlength: 1
      }
    });

    var _lightningLookupMobile = lwc.registerComponent(LightningLookupMobile, {
      tmpl: _tmpl$E
    });

    function tmpl$J($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [$cmp.isDesktop ? api_custom_element("lightning-lookup-desktop", _lightningLookupDesktop, {
        props: {
          "disabled": $cmp.disabled,
          "fieldName": $cmp.fieldName,
          "label": $cmp.label,
          "maxValues": $cmp.maxValues,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record,
          "required": $cmp.required,
          "showCreateNew": $cmp.showCreateNew,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 3
      }, []) : null, !$cmp.isDesktop ? api_custom_element("lightning-lookup-mobile", _lightningLookupMobile, {
        props: {
          "disabled": $cmp.disabled,
          "fieldName": $cmp.fieldName,
          "label": $cmp.label,
          "maxValues": $cmp.maxValues,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record,
          "required": $cmp.required,
          "showCreateNew": $cmp.showCreateNew,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 5
      }, []) : null];
    }

    var _tmpl$F = lwc.registerTemplate(tmpl$J);
    tmpl$J.stylesheets = [];

    if (_implicitStylesheets$g) {
      tmpl$J.stylesheets.push.apply(tmpl$J.stylesheets, _implicitStylesheets$g);
    }
    tmpl$J.stylesheetTokens = {
      hostAttribute: "lightning-lookup_lookup-host",
      shadowAttribute: "lightning-lookup_lookup"
    };

    /**
     * The desktop form factor.
     * @type {String}
     */
    const FORM_FACTOR_DESKTOP = 'DESKTOP';
    /**
     * The query selector used for the desktop implementation of lookups.
     * @type {String}
     */

    const LIGHTNING_LOOKUP_DESKTOP = 'lightning-lookup-desktop';
    /**
     * The query selector used for the mobile implementation of lookups.
     * @type {String}
     */

    const LIGHTNING_LOOKUP_MOBILE = 'lightning-lookup-mobile';

    class LightningLookup extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        if (this._lookupElement) {
          return this._lookupElement.checkValidity();
        }

        return false;
      }
      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */


      /**
       * Sets focus on the input element.
       */
      focus() {
        if (!this._connected) {
          return;
        }

        if (this._lookupElement) {
          this._lookupElement.focus();
        }
      }
      /**
       * The text label for the layout field.
       * @type {String}
       */


      /**
       * @return {String} The error message to be displayed when the user enters the text in
       * the input but does not select a valid option.
       */
      get messageWhenBadInput() {
        if (this._lookupElement) {
          this._messageWhenBadInput = this._lookupElement.messageWhenBadInput;
        }

        return this._messageWhenBadInput;
      }
      /**
       * Sets the error message to be displayed when the user enters the text in the input
       * but does not select a valid option.
       * @param {String} value - The error message.
       */


      set messageWhenBadInput(value) {
        this._messageWhenBadInput = value;

        if (this._lookupElement) {
          this._lookupElement.messageWhenBadInput = this._messageWhenBadInput;
        }
      }
      /**
       * @return {String} The error message to be displayed when the lookup value
       * is required but is currently missing.
       */


      get messageWhenValueMissing() {
        if (this._lookupElement) {
          this._messageWhenValueMissing = this._lookupElement.messageWhenValueMissing;
        }

        return this._messageWhenValueMissing;
      }
      /**
       * The error message to be displayed when the lookup value is required but is currently missing.
       * @param {String} value - The error message.
       */


      set messageWhenValueMissing(value) {
        this._messageWhenValueMissing = value;

        if (this._lookupElement) {
          this._lookupElement.messageWhenValueMissing = this._messageWhenValueMissing;
        }
      }
      /**
       * The source record's objectInfos.
       * @param {Object}
       */


      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */
      reportValidity() {
        if (this._lookupElement) {
          return this._lookupElement.reportValidity();
        }

        return false;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        if (this._lookupElement) {
          this._lookupElement.setCustomValidity(message);
        }
      }
      /**
       * Indicates whether or not the show create new option.
       * TODO - Remove when @wire(getLookupActions) response is invocable.
       * @type {Boolean}
       */


      /**
       * Displays a validation message if the lookup is in invalid state.
       */
      showHelpMessageIfInvalid() {
        if (this._lookupElement) {
          this._lookupElement.showHelpMessageIfInvalid();
        }
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        if (this._lookupElement) {
          return this._lookupElement.validity;
        }

        return null;
      }
      /**
       * @return {Array} An array of selected lookup values.
       */


      get value() {
        if (this._lookupElement) {
          this._value = this._lookupElement.value;
        }

        return this._value;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        this._value = value;

        if (this._lookupElement) {
          this._lookupElement.value = value;
        }
      }
      /**
       * @return {String} The value of variant.
       */


      get variant() {
        if (this._lookupElement) {
          this._variant = this._lookupElement.variant;
        }

        return this._variant || VARIANT.STANDARD;
      }
      /**
       * Sets the variant type for the lookup.
       * @param {String} value - The value of variant.
       */


      set variant(value) {
        this._variant = normalizeVariant(value);

        if (this._lookupElement) {
          this._lookupElement.variant = this._variant;
        }

        this.updateClassList();
      } // ================================================================================
      // PRIVATE PROPERTIES
      // ================================================================================

      /**
       * Indicates whether or not the component is connected.
       * @type {Boolean}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Indicates whether or not the component is loaded on the desktop form factor.
       * @return {Boolean} - See desc.
       */
      get isDesktop() {
        return this._isDesktop;
      }
      /**
       * Returns the lookup DOM element.
       * @returns {Object} - See desc.
       */


      get lookupElement() {
        if (!this._connected) {
          return null;
        }

        if (this._lookupElement) {
          return this._lookupElement;
        }

        return null;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.fieldName = void 0;
        this.label = void 0;
        this.maxValues = 1;
        this.objectInfos = void 0;
        this.record = void 0;
        this.required = false;
        this.showCreateNew = false;
        this._connected = false;
        this._isDesktop = void 0;
        this._initProps = false;
        this._lookupElement = void 0;
        this._messageWhenBadInput = void 0;
        this._messageWhenValueMissing = void 0;
        this._value = void 0;
        this._variant = void 0;
        const formFactor = configProvider$1.getFormFactor();
        this._isDesktop = formFactor === FORM_FACTOR_DESKTOP;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
        this._initProps = false;
        this._lookupElement = undefined;
      }

      renderedCallback() {
        if (!this._lookupElement) {
          const lookupSelector = this._isDesktop ? LIGHTNING_LOOKUP_DESKTOP : LIGHTNING_LOOKUP_MOBILE;
          this._lookupElement = this.template.querySelector(lookupSelector);
        }

        if (!this._initProps) {
          this.synchronizeProps();
          this._initProps = true;
        }
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Synchronizes properties with child lookup element.
       */


      synchronizeProps() {
        if (this._lookupElement) {
          this._lookupElement.value = this._value;
          this._lookupElement.variant = this._variant;

          if (this._messageWhenBadInput !== undefined) {
            this._lookupElement.messageWhenBadInput = this._messageWhenBadInput;
          }

          if (this._messageWhenValueMissing !== undefined) {
            this._lookupElement.messageWhenValueMissing = this._messageWhenValueMissing;
          }
        }
      }

    }

    lwc.registerDecorators(LightningLookup, {
      publicProps: {
        disabled: {
          config: 0
        },
        fieldName: {
          config: 0
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenValueMissing: {
          config: 3
        },
        objectInfos: {
          config: 0
        },
        record: {
          config: 0
        },
        required: {
          config: 0
        },
        showCreateNew: {
          config: 0
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"]
    });

    var _lightningLookup = lwc.registerComponent(LightningLookup, {
      tmpl: _tmpl$F
    });

    function stylesheet$k(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$k = [stylesheet$k];

    function tmpl$K($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 2
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 3
      }, [api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-size_1-of-2": true
        },
        key: 9
      }, [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-latitude": true
        },
        props: {
          "label": $cmp.i18n.latitude,
          "name": "latitude",
          "value": $cmp.latitude,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "messageWhenBadInput": $cmp.i18n.invalidLatitude,
          "messageWhenValueMissing": $cmp.i18n.coordinateIsRequired
        },
        key: 10,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleLatitudeChange)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleLatitudeBlur))
        }
      }, [])]), api_element("div", {
        classMap: {
          "slds-size_1-of-2": true
        },
        key: 11
      }, [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-longitude": true
        },
        props: {
          "label": $cmp.i18n.longitude,
          "name": "longitude",
          "value": $cmp.longitude,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "messageWhenBadInput": $cmp.i18n.invalidLongitude,
          "messageWhenValueMissing": $cmp.i18n.coordinateIsRequired
        },
        key: 12,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleLongitudeChange)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleLongitudeBlur))
        }
      }, [])])])])])])];
    }

    var _tmpl$G = lwc.registerTemplate(tmpl$K);
    tmpl$K.stylesheets = [];

    if (_implicitStylesheets$k) {
      tmpl$K.stylesheets.push.apply(tmpl$K.stylesheets, _implicitStylesheets$k);
    }
    tmpl$K.stylesheetTokens = {
      hostAttribute: "lightning-inputLocation_inputLocation-host",
      shadowAttribute: "lightning-inputLocation_inputLocation"
    };

    var labelCoordinateIsRequired = 'Coordinate is required';

    var labelInvalidLatitude = 'Latitude should be a decimal number in a range [-90, 90]';

    var labelInvalidLongitude = 'Longitude should be a decimal number in a range [-180, 180]';

    var labelLatitude = 'Latitude';

    var labelLongitude = 'Longitude';

    const VALID_RANGES = {
      LATITUDE: [-90, 90],
      LONGITUDE: [-180, 180]
    };

    function isNumber(value) {
      return value !== '' && value !== null && isFinite(value);
    }

    function isValidRange(start, end, dec) {
      const val = parseFloat(dec);
      return !isNaN(val) && val <= end && val >= start ? true : false;
    }

    function validateFormatAndRange(coordinate, range) {
      const truncatedCoordinate = coordinate.trim();
      return isNumber(truncatedCoordinate) && isValidRange(range[0], range[1], truncatedCoordinate);
    }

    function validateCoordinate(name, value) {
      return validateFormatAndRange(value, VALID_RANGES[name.toUpperCase()]);
    }

    const i18n$n = {
      coordinateIsRequired: labelCoordinateIsRequired,
      invalidLatitude: labelInvalidLatitude,
      invalidLongitude: labelInvalidLongitude,
      latitude: labelLatitude,
      longitude: labelLongitude
    };
    /**
     * Represents a geolocation compound field that accepts a latitude and longitude value.
     */

    class LightningInputLocation extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.fieldLevelHelp = void 0;
        this._latitude = '';
        this._longitude = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._variant = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.interactingState = new InteractingState({
          // keeps interacting state when switch between latitude and longitude
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
          this.dispatchEvent(new CustomEvent('blur'));
        });
        this.classList.add('slds-form-element', 'slds-form-compound');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The latitude value. Latitude values must be within -90 and 90.
       * @type {string}
       *
       */


      get latitude() {
        return this._latitude;
      }

      set latitude(value) {
        //  Converting the value to string when value is of type decimal to be consistent
        if (value != null) {
          value = value.toString();
        }

        this._latitude = normalizeString(value);
      }
      /**
       * The longitude value. Longitude values must be within -180 and 180.
       * @type {string}
       *
       */


      get longitude() {
        return this._longitude;
      }

      set longitude(value) {
        //  Converting the value to string when value is of type decimal to be consistent
        if (value != null) {
          value = value.toString();
        }

        this._longitude = normalizeString(value);
      }
      /**
       * If present, the geolocation fields are disabled and users cannot interact with them.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the geolocations fields are read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the geolocation fields must be filled out before the form is submitted.
       * An error message is displayed if a user interacts with the field
       * and does not provide a value.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of a geolocation compound field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and geolocation fields.
       * Use label-stacked to place the label above the geolocation fields.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * Sets focus on the latitude field.
       */


      focus() {
        if (this._connected) {
          this.getCoordinateElement('latitude').focus();
        }
      }
      /**
       * Removes keyboard focus from the latitude and longitude fields.
       */


      blur() {
        if (this._connected) {
          this.getCoordinateElement('latitude').blur();
          this.getCoordinateElement('longitude').blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the latitude and longitude field meet all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the latitude or longitude field if the coordinates are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the latitude or longitude field when
       * the value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - Name of the field, which must be latitude or longitude.
       */


      setCustomValidityForField(message, fieldName) {
        assert(['latitude', 'longitude'].indexOf(fieldName) >= 0, '"fieldName" must be "latitude" or "longitude"');

        this._coordinateConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        Object.keys(this._coordinateConstraints).forEach(coordinate => {
          this._reportValidityForCoordinate(coordinate);
        });
        return valid;
      }

      get i18n() {
        return i18n$n;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleLatitudeBlur() {
        this.interactingState.leave();

        this._reportValidityForCoordinate('latitude');
      }

      handleLongitudeBlur() {
        this.interactingState.leave();

        this._reportValidityForCoordinate('longitude');
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleLatitudeChange(event) {
        this.handleChange('latitude', event);
      }

      handleLongitudeChange(event) {
        this.handleChange('longitude', event);
      }

      handleChange(coordinate, event) {
        event.stopPropagation();
        const value = event.detail.value;

        if (this[coordinate] === value) {
          // Value didn't change. No need to dispatch.
          return;
        } // Update component state accordingly


        if (coordinate === 'longitude') {
          this._longitude = value;
        } else if (coordinate === 'latitude') {
          this._latitude = value;
        }

        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            latitude: this.latitude,
            longitude: this.longitude
          }
        }));
      }

      get _coordinateConstraints() {
        if (!this._coordinateConstraintApis) {
          this._coordinateConstraintApis = ['latitude', 'longitude'].reduce((constraints, coordinate) => {
            const constraintProviders = {
              badInput: () => !this.disabled && !isEmptyString(this[coordinate]) && !validateCoordinate(coordinate, this[coordinate]),
              valueMissing: () => !this.disabled && this.required && isEmptyString(this[coordinate])
            };
            constraints[coordinate] = new FieldConstraintApi(this.getCoordinateElement.bind(this, coordinate), constraintProviders);
            return constraints;
          }, {});
        }

        return this._coordinateConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          const {
            _coordinateConstraints
          } = this;

          const checkCoordinates = property => Object.values(_coordinateConstraints).some(coordinateConstraint => coordinateConstraint.validity[property]);

          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => checkCoordinates('customError'),
            badInput: () => checkCoordinates('badInput'),
            valueMissing: () => checkCoordinates('valueMissing')
          });
        }

        return this._combinedConstraintApi;
      }

      getCoordinateElement(fieldName) {
        const propertyName = `_${fieldName}Element`;

        if (!this[propertyName]) {
          this[propertyName] = this.template.querySelector(`lightning-input[data-${fieldName}]`);
        }

        return this[propertyName];
      }

      _reportValidityForCoordinate(coordinate) {
        this._coordinateConstraints[coordinate].reportValidity(helpMessage => {
          const coordinateElement = this.getCoordinateElement(coordinate);
          coordinateElement.setCustomValidity(helpMessage);
          coordinateElement.reportValidity();
        });
      }

    }

    LightningInputLocation.delegatesFocus = true;

    lwc.registerDecorators(LightningInputLocation, {
      publicProps: {
        label: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        latitude: {
          config: 3
        },
        longitude: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity"],
      track: {
        _latitude: 1,
        _longitude: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _variant: 1
      }
    });

    var _lightningInputLocation = lwc.registerComponent(LightningInputLocation, {
      tmpl: _tmpl$G
    });

    function tmpl$L($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [$cmp.failed ? api_element("span", {
        classMap: {
          "slds-hide": true
        },
        key: 3
      }, [api_text("No input rendered: "), api_dynamic($cmp.errorMessage)]) : null, $cmp.ready ? $cmp.isTypeName ? api_custom_element("lightning-input-name", _lightningInputName, {
        props: {
          "label": $cmp.label,
          "firstName": $cmp.internalValue.FirstName,
          "lastName": $cmp.internalValue.LastName,
          "salutation": $cmp.internalValue.Salutation,
          "options": $cmp.picklistOptions,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 6,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeAddress ? api_custom_element("lightning-input-address", _lightningInputAddress, {
        props: {
          "streetLabel": $cmp.addressField.Street.label,
          "cityLabel": $cmp.addressField.City.label,
          "provinceLabel": $cmp.state.label,
          "countryLabel": $cmp.country.label,
          "postalCodeLabel": $cmp.addressField.PostalCode.label,
          "street": $cmp._street,
          "city": $cmp._city,
          "province": $cmp._state,
          "postalCode": $cmp._postalCode,
          "country": $cmp._country,
          "provinceOptions": $cmp.state.options,
          "countryOptions": $cmp.country.options,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 8,
        on: {
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeNumber ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "name": $cmp._fieldName,
          "type": "number",
          "variant": $cmp.inputVariant,
          "required": $cmp.required,
          "label": $cmp.label,
          "formatter": $cmp.numberFormatter,
          "value": $cmp.internalValue,
          "step": $cmp.numberStep,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 10,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeText ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "label": $cmp.label,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "name": $cmp._fieldName,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 12,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeCheckbox ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "checked": $cmp.internalValue,
          "type": "checkbox",
          "variant": $cmp.inputVariant,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 14,
        on: {
          "change": _m4 || ($ctx._m4 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeEmail ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.internalValue,
          "required": $cmp.required,
          "type": "email",
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 16,
        on: {
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeTextArea ? api_custom_element("lightning-textarea", _lightningTextarea, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "variant": $cmp.inputVariant,
          "maxLength": $cmp.uiField.length,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 18,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeRichText ? api_custom_element("lightning-quill", _lightningQuill, {
        props: {
          "label": $cmp.label,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 20,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeDate ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "type": "date",
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 22,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeDateTime ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "type": "datetime",
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "required": $cmp.required,
          "disabled": $cmp._disabled,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 24,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypePicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "options": $cmp.picklistOptions,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 26,
        on: {
          "change": _m10 || ($ctx._m10 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeMultiPicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
        props: {
          "multiple": true,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "options": $cmp.picklistOptions,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 28,
        on: {
          "change": _m11 || ($ctx._m11 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeReference ? api_custom_element("lightning-lookup", _lightningLookup, {
        props: {
          "disabled": $cmp._disabled,
          "fieldName": $cmp._fieldName,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record.record,
          "value": $cmp.lookupValue,
          "variant": $cmp.inputVariant,
          "label": $cmp.label
        },
        key: 30,
        on: {
          "change": _m12 || ($ctx._m12 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeLocation ? api_custom_element("lightning-input-location", _lightningInputLocation, {
        props: {
          "longitude": $cmp.value.longitude,
          "latitude": $cmp.value.latitude,
          "label": $cmp.label,
          "disabled": $cmp._disabled,
          "required": $cmp.required
        },
        key: 32,
        on: {
          "change": _m13 || ($ctx._m13 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeUnsupportedReference ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": true,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "type": "text",
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 34,
        on: {
          "change": _m14 || ($ctx._m14 = api_bind($cmp.handleChange))
        }
      }, []) : null : null];
    }

    var _tmpl$H = lwc.registerTemplate(tmpl$L);
    tmpl$L.stylesheets = [];
    tmpl$L.stylesheetTokens = {
      hostAttribute: "lightning-inputField_inputField-host",
      shadowAttribute: "lightning-inputField_inputField"
    };

    function isInDependencyChain(uiField, fields, picklistValues) {
      return hasDependents(uiField, fields, picklistValues) || hasController(uiField, fields, picklistValues);
    }
    function hasDependents(uiField, fields, picklistValues) {
      for (const fieldName in fields) {
        if (fields.hasOwnProperty(fieldName)) {
          const field = fields[fieldName];

          if (field.controllerName === uiField.apiName) {
            // make sure the dependent field exists in the form
            if (picklistFieldInForm(fieldName, picklistValues)) {
              return true;
            }
          }
        }
      }

      return false;
    }

    function hasController(uiField, fields, picklistValues) {
      const controllerName = uiField.controllerName;
      const hasControllingField = fields[controllerName] !== undefined;
      return hasControllingField && (picklistFieldInForm(controllerName, picklistValues) || checkboxFieldInForm(controllerName, fields));
    }

    function isControllerMissing(uiField, fields, picklistValues) {
      const controllerName = uiField.controllerName;
      const hasControllingField = fields[controllerName] !== undefined;
      return hasControllingField && !picklistFieldInForm(controllerName, picklistValues) && !checkboxFieldInForm(controllerName, fields);
    }

    function picklistFieldInForm(fieldName, picklistValues) {
      return picklistValues[fieldName] !== undefined;
    }

    function checkboxFieldInForm(fieldName, fields) {
      return fields[fieldName] !== undefined && Fields.BOOLEAN === fields[fieldName].dataType;
    }

    /**
     * Given a scale returns the corresponding decimal places 'step' (ie. lowest unit of decrease/increase for a number
     * in the given scale).
     * for example given the scale 1 result in 0.1, for 2 -> 0.01, etc.
     * @param {number} scale an integer number.
     * @returns {number} 'step' for the given scale.
     */
    function scaleToDecimalPlaces(scale) {
      // Using toFixed to correct for bad js arithmetic precision, resulting
      // in 0.000009999999999999999 for Math.pow(10, -5) instead of the expected
      // 0.00001
      const resultAsString = Math.pow(10, -parseInt(scale, 10)).toFixed(scale);
      return parseFloat(resultAsString);
    }

    const NUMBER_TYPES = [Fields.DECIMAL, Fields.INT, Fields.PERCENT, Fields.CURRENCY, Fields.DOUBLE];
    const STATE_CODE = 'StateCode';
    const COUNTRY_CODE = 'CountryCode';

    function uncapitalize(str) {
      return `${str[0].toLowerCase()}${str.slice(1)}`;
    }

    function isUnsupportedReferenceField(name) {
      return UNSUPPORTED_REFERENCE_FIELDS.indexOf(name) !== -1;
    } // Returns a normalized string name by removing the prefix (e.g. removes 'Billing' from 'BillingStreet' for Address fields)


    function removePrefix(str, prefix) {
      return prefix ? str.replace(prefix, '') : str;
    } // Adds a prefix to the string (e.g. adds 'Billing' to 'Street' for Address fields)


    function addPrefix(str, prefix) {
      return prefix ? prefix + str : str;
    }

    function isEmptyObject$1(obj) {
      // fastest way to do this!
      // eslint-disable-next-line guard-for-in
      for (const name in obj) {
        return false;
      }

      return true;
    }
    /**
     * Returns a map of changed values from a compound field,
     * normalizing the names and capitalization rules
     * @param {Object} originalValue A map of the original values
     * @param {Object} changedValues Values that have changed
     * @param {Object} fieldPrefix The field prefix in the map of original values (e.g. 'Billing' in 'BillingStreet')
     *
     * @returns {Object} Map of changed values
     */


    function normalizeCompoundFieldValues(originalValue, changedValues, fieldPrefix) {
      return Object.keys(originalValue).reduce((ret, rawKey) => {
        const key = removePrefix(rawKey, fieldPrefix); // map state and country values to code if code is present,
        // rather than raw value

        let normalizedKey;

        if (key === STATE_CODE || uncapitalize(key) === 'state') {
          normalizedKey = 'province';
        } else if (key === COUNTRY_CODE) {
          normalizedKey = 'country';
        } else {
          normalizedKey = uncapitalize(key);
        }

        const normalizedValue = changedValues[normalizedKey] ? changedValues[normalizedKey] : null;

        if (normalizedValue !== originalValue[key]) {
          ret[addPrefix(key, fieldPrefix)] = normalizedValue;
        }

        return ret;
      }, {});
    }

    const VARIANT_MAPPING = {
      stacked: VARIANT.LABEL_STACKED,
      horizontal: VARIANT.LABEL_INLINE
    };
    /**
     * Represents an editable input for a field on a Salesforce object.
     */

    class LightningInputField extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.readonly = false;
        this.uiField = {};
        this.failed = false;
        this.errorMessage = '';
        this.ready = false;
        this.picklistOptions = void 0;
        this.isCompoundField = false;
        this.nameField = {};
        this.addressField = {};
        this.label = '';
        this._uiFieldRequired = false;
        this._externalRequired = false;
        this.inlineHelpText = '';
        this._disabled = void 0;
        this.internalValue = void 0;
        this.objectInfos = void 0;
        this.record = void 0;
        this._fieldName = void 0;
        this._street = void 0;
        this._country = void 0;
        this._postalCode = void 0;
        this._state = void 0;
        this._city = void 0;
        this._labelAlignment = '';
        this._variant = void 0;
        this._rawFieldName = void 0;
        this.originalValue = void 0;
        this.isDirty = false;
        this.serverError = void 0;
        this.serverErrorValue = void 0;
        this._inChangeCycle = false;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.isStackedLabel() && !this.isTypeAddress && !this.isTypeName,
          'slds-form-element_horizontal': this.isHorizontalLabel() && !this.isTypeAddress && !this.isTypeName
        });
      }

      isStackedLabel() {
        // only add the form class if density or variant is stacked
        return this._labelAlignment === 'stacked' && !this.variant || this.variant === VARIANT.LABEL_STACKED;
      }

      isHorizontalLabel() {
        // only add the form class if density or variant is horizontal
        return this._labelAlignment === 'horizontal' && !this.variant || this.variant === VARIANT.LABEL_INLINE;
      }
      /**
       * The variant changes the label position of an input field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * If variant is specified, the label position is determined by the variant.
       * Otherwise, it is determined by the density setting of the parent form.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = value;
        this.updateClassList();
      }
      /**
       * Reserved for internal use.
       * @param {*} record Reserved for internal use.
       */


      wireRecordUi(record) {
        let uiField; // TODO break up wireRecordUi method, too much stuff happening here

        try {
          uiField = getUiField(this.fieldName, record.record, record.objectInfo);
        } catch (e) {
          this.failed = true;
          this.errorMessage = `Field "${this.fieldName}" not found in response.`;
          return;
        }

        this.record = record;
        this.uiField = uiField;
        this.label = uiField.label;
        this._uiFieldRequired = uiField.required;
        this.objectInfos = record.objectInfos;
        this.inlineHelpText = uiField.inlineHelpText;
        this._labelAlignment = record.labelAlignment ? record.labelAlignment : '';
        this.updateClassList();

        if (!this.isDirty) {
          this.internalValue = uiField.value;
        }

        if (this._rawFieldName && this._rawFieldName.objectApiName && this._rawFieldName.objectApiName !== record.objectInfo.apiName) {
          throw new Error(`objectApiName (${this._rawFieldName.objectApiName}) for field ${this.fieldName} does not match the objectApiName provided for the form (${record.objectInfo.apiName}).`);
        }

        this.originalValue = uiField.value;

        if (isCompoundField(this.fieldName, record.objectInfo, isPersonAccount(record.record))) {
          this.isCompoundField = true;
          this.fieldPrefix = this.getFieldPrefix();
          this.initializeCompoundField(uiField, record);
        } else if (!record.createMode && uiField.updateable === false || record.createMode && uiField.createable === false) {
          this._disabled = true;
          this.readonly = true;
        }

        if (!this.isAnyPicklistType && !this.isCompoundField) {
          // compound fields without picklists will be marked ready in initializeCompoundField
          // picklists and compound fields that have picklist constituents will be marked ready after the options are wired
          this.ready = true;
        }
      }

      get inputVariant() {
        // precendence to variant over density
        if (this.variant) {
          return this.variant;
        }

        if (VARIANT_MAPPING[this._labelAlignment]) {
          return VARIANT_MAPPING[this._labelAlignment];
        }

        return this.variant;
      }
      /**
       * Reserved for internal use.
       * @param {*} picklistValues Reserved for internal use
       */


      wirePicklistValues(picklistValues) {
        // picklist fields rely on the record for dependency management.
        // The initialization logic will fail if record-ui isn't already wired.
        if (!this.record) {
          return;
        }

        this._picklistValues = picklistValues;

        if (this.isAnyPicklistType) {
          this.initializePicklist(this.fieldName);
        } else if (this.isCompoundField) {
          this.initializePicklistsForCompoundField(this.uiField, this.record);
        } else if (this.isTypeCheckbox) {
          // Also need to register checkbox fields that are part of a dependency chain
          this.registerCheckboxDependency();
        }

        this.ready = true;
      }

      updateAddressField(changedValues = {}) {
        let address = {
          country: this.getNormalizedStateCountryField('Country').value,
          postalCode: this.addressField.PostalCode.value,
          city: this.addressField.City.value,
          province: this.getNormalizedStateCountryField('State').value,
          street: this.addressField.Street.value
        };
        address = Object.assign(address, changedValues);
        this._country = address.country;
        this._postalCode = address.postalCode;
        this._state = address.province;
        this._street = address.street;
        this._city = address.city;
      }

      initializeCompoundField(uiField, record) {
        const compoundFields = getCompoundFields(this.fieldName, record.record, record.objectInfo);
        let compoundField = this.addressField;

        if (uiField.extraTypeInfo === Fields.PERSON_NAME) {
          compoundField = this.nameField;
        }

        if (!compoundFieldIsUpdateable(compoundFields, record.record, record.objectInfo)) {
          this._disabled = true;
        }

        let hasPicklists = false;
        compoundFields.forEach(field => {
          const fieldName = removePrefix(field, this.fieldPrefix);
          compoundField[fieldName] = getUiField(field, record.record, record.objectInfo);

          if (compoundField[fieldName].type === Fields.PICKLIST) {
            hasPicklists = true;
          }
        }); // if the compound field doesn't have a picklist constituent, mark it ready

        if (!hasPicklists) {
          this.ready = true;
        }

        if (this.isTypeAddress) {
          this.updateAddressField();
        }
      }
      /**
       * Resets the form fields to their initial values.
       */


      reset() {
        this.isDirty = false;
        this.wireRecordUi(this.record);

        if (this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
        }
      } // TODO this should be removed after records experience updates their code to not rely on this method

      /**
       * Reserved for internal use.
       * @param {*} fieldName Reserved for internal use.
       * @param {*} options Reserved for internal use.
       */


      updateDependentField(fieldName, options) {
        this.updateFieldOptions(fieldName, options); // make sure the component is marked ready

        this.ready = true;
      }
      /**
       * Reserved for internal use.
       * @param {*} errors Reserved for internal use.
       */


      setErrors(errors) {
        if (errors.body && errors.body.output && errors.body.output.fieldErrors && errors.body.output.fieldErrors[this.fieldName]) {
          this.setCustomValidity(errors.body.output.fieldErrors[this.fieldName][0].message);
          this.serverError = errors.body.output.fieldErrors[this.fieldName];
          this.serverErrorValue = this.value;
        } else {
          this.serverError = undefined;
        }
      }
      /**
       * The field value, which overrides the existing value.
       * @type {string}
       *
       */


      get value() {
        return this.internalValue;
      }

      set fieldName(name) {
        this._rawFieldName = name;

        if (name && name.fieldApiName) {
          this._fieldName = name.fieldApiName;
        } else {
          this._fieldName = name;
        }
      }
      /**
       * The API name of the field to be displayed.
       * @type {string}
       */


      get fieldName() {
        return this._fieldName;
      }

      set value(val) {
        if (this._inChangeCycle && this.isTypeReference) {
          // reject values being set from outside
          return;
        } // uninitialized values passed through
        // templates are undefined but should not
        // mark the field as dirty


        if (val !== undefined) {
          this.internalValue = val;
          this.isDirty = true;
        }
      }
      /**
       * If present, the field is disabled and users cannot interact with it.
       * Read-only fields are also disabled by default.
       * @type {boolean}
       *
       */


      get disabled() {
        return this._disabled ? true : false;
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._uiFieldRequired || this._externalRequired;
      }

      set required(value) {
        this._externalRequired = normalizeBoolean(value);
      }
      /**
       * Reserved for internal use.
       * @returns {boolean} Returns true if the input field is valid.
       */


      reportValidity() {
        const input = this.getInputComponent();

        if (input) {
          return input.reportValidity();
        }

        return true;
      }

      set disabled(val) {
        this._disabled = val;
      }
      /**
       * Reserved for internal use. If present, the field has been modified by the user but not saved or submitted.
       * @type {boolean}
       * @default false
       */


      get dirty() {
        return this.isDirty;
      }

      get isTypeName() {
        return this.isCompoundField && (Fields.PERSON_NAME === this.uiField.extraTypeInfo || Fields.SWITCHABLE_PERSON_NAME === this.uiField.extraTypeInfo);
      }

      get isTypeAddress() {
        return this.uiField.compound && Fields.ADDRESS === this.uiField.type;
      }

      get country() {
        return this.getNormalizedStateCountryField('Country');
      }

      get state() {
        return this.getNormalizedStateCountryField('State');
      }

      getNormalizedStateCountryField(fieldName) {
        if (this.addressField && this.addressField[`${fieldName}Code`]) {
          return this.addressField[`${fieldName}Code`];
        } else if (this.addressField && this.addressField[fieldName]) {
          return this.addressField[fieldName];
        }

        return {};
      }

      get isTypeNumber() {
        return NUMBER_TYPES.includes(this.uiField.type);
      }

      get numberFormatter() {
        let formatter = 'decimal';

        switch (this.uiField.type) {
          case 'Currency':
            formatter = 'currency';
            break;

          case 'Percent':
            formatter = 'percent-fixed';
            break;

          default:
        }

        return formatter;
      }

      get numberStep() {
        switch (this.uiField.type) {
          case 'Currency':
            return 0.01;

          case 'Percent':
          case 'Double':
          case 'Decimal':
            return scaleToDecimalPlaces(this.uiField.scale);

          default:
            return 1;
        }
      } // text type is the default


      get isTypeText() {
        return !this.isTypeNumber && !this.isTypeRichText && !this.isTypeTextArea && !this.isTypeCheckbox && !this.isTypeDate && !this.isTypeDateTime && !this.isTypeEmail && !this.isTypePicklist && !this.isTypeMultiPicklist && !this.isTypeName && !this.isTypeReference && !this.isTypeLocation && !this.isTypeUnsupportedReference && !this.isTypeAddress;
      }

      get isTypeRichText() {
        return Fields.TEXTAREA === this.uiField.type && Fields.RICH_TEXTAREA === this.uiField.extraTypeInfo && this.uiField.htmlFormatted;
      }

      get isTypeTextArea() {
        return Fields.TEXTAREA === this.uiField.type && Fields.PLAIN_TEXTAREA === this.uiField.extraTypeInfo && !this.uiField.htmlFormatted;
      }

      get isTypeCheckbox() {
        return Fields.BOOLEAN === this.uiField.type;
      }

      get isTypeEmail() {
        return Fields.EMAIL === this.uiField.type;
      }

      get isTypeDate() {
        return Fields.DATE === this.uiField.type;
      }

      get isTypeDateTime() {
        return Fields.DATETIME === this.uiField.type;
      }

      get isTypePicklist() {
        return Fields.PICKLIST === this.uiField.type;
      }

      get isTypeMultiPicklist() {
        return Fields.MULTI_PICKLIST === this.uiField.type;
      }

      get canBeControllingField() {
        return this.isTypePicklist || this.isTypeCheckbox;
      }

      get isAnyPicklistType() {
        return this.isTypePicklist || this.isTypeMultiPicklist;
      }

      get isTypeReference() {
        if (this.isTypeUnsupportedReference) {
          return false;
        }

        return Fields.REFERENCE === this.uiField.type;
      }

      get isTypeLocation() {
        return Fields.LOCATION === this.uiField.type;
      }

      get isTypeUnsupportedReference() {
        return isUnsupportedReferenceField(this.fieldName);
      }

      get displayValue() {
        return this.uiField.displayValue;
      }
      /**
       * Lookup needs an array,
       * so this casts the value to an array
       */


      get lookupValue() {
        if (this.value === undefined) {
          return [];
        } else if (Array.isArray(this.value)) {
          return this.value;
        }

        return [this.value];
      }

      renderedCallback() {
        if (!this.ready) {
          this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
          new CustomEvent('registerinputfield', {
            bubbles: true,
            composed: true,
            cancelable: true
          }));
        }
      }

      setCustomValidity(message) {
        const input = this.getInputComponent();

        if (input && input.setCustomValidity) {
          input.setCustomValidity(message ? message : '');
          input.showHelpMessageIfInvalid();
        }
      } // TODO refactor this function into smaller pieces


      handleChange(e) {
        // ignore change events until ready
        if (!this.ready) {
          return;
        } // change events without detail should be ignored


        if (!e.detail) {
          return;
        }

        if (this.isTypeName || this.isTypeAddress || this.isTypeLocation) {
          this.handleCompoundFieldChange(e);
          return;
        }

        if (e.detail.checked !== undefined) {
          this.internalValue = e.detail.checked;
        } else if (this.isTypeReference) {
          // multiselect doesn't actually work yet,
          // normalize falsey values
          this.internalValue = e.detail.value[0] ? e.detail.value[0] : ''; // ignore reset of value from bubble to interop

          this._inChangeCycle = true; // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(() => {
            this._inChangeCycle = false;
          }, 0);
        } else {
          this.internalValue = e.detail.value;
        }

        if (this.internalValue !== this.originalValue) {
          this.isDirty = true;

          if (this.serverError) {
            this.setCustomValidity();
            this.serverError = false;
          }
        } else {
          this.isDirty = false;
        }

        if (this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
        }
      }

      handleCompoundFieldChange(e) {
        const newValue = normalizeCompoundFieldValues(this.originalValue, e.detail, this.fieldPrefix);
        const countryCodeField = addPrefix(COUNTRY_CODE, this.fieldPrefix); // currently input-address return 'province' as both stateCode and state. Having both of these
        // set to the same value returns an API error.

        if (this.originalValue.hasOwnProperty(countryCodeField)) {
          delete newValue[this.fieldPrefix + 'Country'];
          delete newValue[this.fieldPrefix + 'State'];
        } // if the newValue is not an empty object
        // this is a dirty record


        if (!isEmptyObject$1(newValue)) {
          this.isDirty = true; // CountryCode is a controlling picklist, so we need to update the options for StateCode

          if (newValue[countryCodeField] !== this.internalValue[countryCodeField]) {
            this.dispatchControllerFieldChangeEvent(countryCodeField, newValue[countryCodeField]);
          }

          const modifiedObject = Object.assign({}, this.internalValue, newValue);
          this.internalValue = modifiedObject;

          if (this.isTypeAddress) {
            this.updateAddressField(e.detail);
          }
        }
      }

      registerCheckboxDependency() {
        // no need to bother with dependency management if there are no picklists in the form.
        if (!this._picklistValues) {
          return;
        }

        const hasDependents$$1 = hasDependents(this.uiField, this.record.objectInfo.fields, this._picklistValues); // register checkboxes that are part of a dependency chain

        if (hasDependents$$1) {
          this.dispatchRegisterDependencyEvent(this.fieldName);
        }
      }

      initializePicklistsForCompoundField() {
        const compoundFields = getCompoundFields(this.fieldName, this.record.record, this.record.objectInfo);
        let compoundField = this.addressField;

        if (this.uiField.extraTypeInfo === Fields.PERSON_NAME) {
          compoundField = this.nameField;
        }

        compoundFields.forEach(field => {
          const fieldName = removePrefix(field, this.fieldPrefix);

          if (compoundField[fieldName].type === Fields.PICKLIST) {
            this.initializePicklist(field);
          }
        });
      }

      initializePicklist(fieldName) {
        if (!this._picklistValues || !this._picklistValues[fieldName]) {
          throw new Error(`Could not find picklist values for field [${fieldName}]`);
        } // should disable the picklist if the controlling field is missing


        const controllerMissing = isControllerMissing(this.uiField, this.record.objectInfo.fields, this._picklistValues);

        if (controllerMissing) {
          this.internalValue = '';
          this.picklistOptions = [];
          throw new Error(`Field [${this.uiField.controllerName}] controls the field [${fieldName}] but was not found in the form`);
        } // state and country picklists are in a dependency chain, no need to check.


        let isInDependencyChain$$1 = false;

        if (this.isTypeAddress) {
          isInDependencyChain$$1 = true;
        } else {
          isInDependencyChain$$1 = this.isAnyPicklistType && isInDependencyChain(this.uiField, this.record.objectInfo.fields, this._picklistValues);
        }

        if (isInDependencyChain$$1) {
          // initializing picklists in empty state, dependency manager will later update the options.
          this.picklistOptions = [];
          this.dispatchRegisterDependencyEvent(fieldName);
        } else {
          // regular picklist field not within a dependency chain
          this.picklistOptions = this._picklistValues[fieldName].values;
        }
      }

      updateFieldOptions(fieldName, options) {
        if (this.isTypeAddress) {
          const field = removePrefix(fieldName, this.fieldPrefix);
          this.addressField[field].options = options;
        } else if (this.isAnyPicklistType) {
          this.picklistOptions = options;
        }
      }

      getFieldPrefix() {
        if (this.isTypeAddress) {
          // Address fields usually have a prefix, e.g. `BillingStreet` or `ShippingStreet`
          return this.fieldName.split(/Address$/)[0];
        }

        return null;
      }

      dispatchRegisterDependencyEvent(fieldName) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('registerfielddependency', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            fieldName,
            // field-dependency-manager only needs the update method and the live value of the input-field
            fieldElement: {
              updateFieldOptions: this.updateFieldOptions.bind(this),
              getFieldValue: () => {
                return this.value;
              }
            }
          }
        }));
      }

      dispatchControllerFieldChangeEvent(fieldName, value) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatedependentfields', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            fieldName,
            value
          }
        }));
      }

      getInputComponent() {
        return this.template.querySelector('lightning-input,lightning-textarea,lightning-picklist,lightning-lookup');
      }

    }

    lwc.registerDecorators(LightningInputField, {
      publicProps: {
        readonly: {
          config: 0
        },
        variant: {
          config: 3
        },
        value: {
          config: 3
        },
        fieldName: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        dirty: {
          config: 1
        }
      },
      publicMethods: ["wireRecordUi", "wirePicklistValues", "reset", "updateDependentField", "setErrors", "reportValidity"],
      track: {
        uiField: 1,
        failed: 1,
        errorMessage: 1,
        ready: 1,
        picklistOptions: 1,
        isCompoundField: 1,
        nameField: 1,
        addressField: 1,
        label: 1,
        _uiFieldRequired: 1,
        _externalRequired: 1,
        inlineHelpText: 1,
        _disabled: 1,
        internalValue: 1,
        objectInfos: 1,
        record: 1,
        _fieldName: 1,
        _street: 1,
        _country: 1,
        _postalCode: 1,
        _state: 1,
        _city: 1,
        _labelAlignment: 1,
        _variant: 1
      }
    });

    var _lightningInputField = lwc.registerComponent(LightningInputField, {
      tmpl: _tmpl$H
    });

    function tmpl$M($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_custom_element("lightning-record-edit-form", _lightningRecordEditForm, {
        props: {
          "objectApiName": "Lead"
        },
        key: 2,
        on: {
          "success": _m0 || ($ctx._m0 = api_bind($cmp.handleSuccess))
        }
      }, [api_custom_element("lightning-messages", _lightningMessages, {
        key: 3
      }, []), api_element("div", {
        classMap: {
          "slds-m-around_medium": true
        },
        key: 4
      }, [api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": "Id",
          "value": $cmp.accountId
        },
        key: 5
      }, []), api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": "Name",
          "value": "Fleminks"
        },
        key: 6
      }, []), api_element("div", {
        classMap: {
          "slds-m-top_medium": true
        },
        key: 7
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "variant": "brand",
          "type": "submit",
          "name": "save",
          "label": "Create Account"
        },
        key: 8
      }, [])])])])];
    }

    var _tmpl$I = lwc.registerTemplate(tmpl$M);
    tmpl$M.stylesheets = [];
    tmpl$M.stylesheetTokens = {
      hostAttribute: "lwc-amfContactDetails_amfContactDetails-host",
      shadowAttribute: "lwc-amfContactDetails_amfContactDetails"
    };

    class amfContactDetails extends lwc.LightningElement {}

    var _cAmfContactDetails = lwc.registerComponent(amfContactDetails, {
      tmpl: _tmpl$I
    });

    function tmpl$N($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        gid: api_scoped_id,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "container": true
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "titleCon": true
        },
        key: 3
      }, [api_element("h1", {
        key: 4
      }, [api_text("Request a Test Drive")])]), api_element("div", {
        classMap: {
          "slds-section": true,
          "slds-is-open": true,
          "vehicleChoice": true
        },
        key: 5
      }, [api_element("h3", {
        classMap: {
          "slds-section__title": true
        },
        key: 6,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.toggleSection))
        }
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-section__title-action": true
        },
        attrs: {
          "aria-controls": `${api_scoped_id("expando-unique-id")}`,
          "aria-expanded": "true"
        },
        key: 7
      }, [api_element("svg", {
        classMap: {
          "slds-section__title-action-icon": true,
          "slds-button__icon": true,
          "slds-button__icon_left": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 8
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#switch")
        },
        key: 9
      }, [])]), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": "Section Title"
        },
        key: 10
      }, [api_text("Select a car")])])]), api_element("div", {
        classMap: {
          "slds-section__content": true
        },
        attrs: {
          "aria-hidden": "false"
        },
        key: 11
      }, [api_element("div", {
        classMap: {
          "sectionContent": true
        },
        key: 12
      }, [api_custom_element("c-amf-vehicle-choice", _cAmfVehicleChoice, {
        key: 13
      }, []), api_element("div", {
        classMap: {
          "btnContainer": true
        },
        key: 14
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true,
          "nextButton": true
        },
        key: 15,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.clickNext))
        }
      }, [api_text("Next")])])])])]), api_element("div", {
        classMap: {
          "slds-section": true
        },
        key: 16
      }, [api_element("h3", {
        classMap: {
          "slds-section__title": true
        },
        key: 17,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.toggleSection))
        }
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-section__title-action": true
        },
        attrs: {
          "aria-controls": `${api_scoped_id("expando-unique-id")}`,
          "aria-expanded": "false"
        },
        key: 18
      }, [api_element("svg", {
        classMap: {
          "slds-section__title-action-icon": true,
          "slds-button__icon": true,
          "slds-button__icon_left": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 19
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#switch")
        },
        key: 20
      }, [])]), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": "Section Title"
        },
        key: 21
      }, [api_text("Test drive location")])])]), api_element("div", {
        classMap: {
          "slds-section__content": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 22
      }, [api_element("div", {
        classMap: {
          "sectionContent": true
        },
        key: 23
      }, [api_custom_element("c-amf-test-drive-location", _cAmfTestDriveLocation, {
        key: 24
      }, []), api_element("div", {
        classMap: {
          "btnContainer": true
        },
        key: 25
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true,
          "nextButton": true
        },
        key: 26,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.clickNext))
        }
      }, [api_text("Next")])])])])]), api_element("div", {
        classMap: {
          "slds-section": true
        },
        key: 27
      }, [api_element("h3", {
        classMap: {
          "slds-section__title": true
        },
        key: 28,
        on: {
          "click": _m4 || ($ctx._m4 = api_bind($cmp.toggleSection))
        }
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-section__title-action": true
        },
        attrs: {
          "aria-controls": `${api_scoped_id("expando-unique-id")}`,
          "aria-expanded": "false"
        },
        key: 29
      }, [api_element("svg", {
        classMap: {
          "slds-section__title-action-icon": true,
          "slds-button__icon": true,
          "slds-button__icon_left": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 30
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#switch")
        },
        key: 31
      }, [])]), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": "Section Title"
        },
        key: 32
      }, [api_text("Contact details")])])]), api_element("div", {
        classMap: {
          "slds-section__content": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 33
      }, [api_element("div", {
        classMap: {
          "sectionContent": true
        },
        key: 34
      }, [api_custom_element("c-amf-contact-details", _cAmfContactDetails, {
        key: 35
      }, []), api_element("div", {
        classMap: {
          "btnContainer": true
        },
        key: 36
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true,
          "nextButton": true
        },
        key: 37,
        on: {
          "click": _m5 || ($ctx._m5 = api_bind($cmp.clickNext))
        }
      }, [api_text("Next")])])])])])])];
    }

    var _tmpl$J = lwc.registerTemplate(tmpl$N);
    tmpl$N.stylesheets = [];

    if (_implicitStylesheets) {
      tmpl$N.stylesheets.push.apply(tmpl$N.stylesheets, _implicitStylesheets);
    }
    tmpl$N.stylesheetTokens = {
      hostAttribute: "lwc-amfTestDriveForm_amfTestDriveForm-host",
      shadowAttribute: "lwc-amfTestDriveForm_amfTestDriveForm"
    };

    class amfTestDriveForm extends lwc.LightningElement {
      toggleSection(event) {
        let el = event.target.closest(".slds-section");
        console.log(el);

        if (event.target.closest(".slds-section").classList.contains('slds-is-open')) {
          el.classList.remove('slds-is-open');
        } else {
          el.classList.add('slds-is-open');
        }
      }

      clickNext(event) {
        let el = event.target.closest(".slds-section");
        event.target.closest(".nextButton").style.display = 'none';
        el.classList.remove('slds-is-open');
        console.log(el.nextElementSibling);
        el.nextElementSibling.classList.add('slds-is-open');
      }

    }

    var amfTestDriveForm$1 = lwc.registerComponent(amfTestDriveForm, {
      tmpl: _tmpl$J
    });

    return amfTestDriveForm$1;

});
